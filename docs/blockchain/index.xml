<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blockchains on hsiaosiyuan</title>
    <link>http://hsiaosiyuan0.github.io/blockchain/</link>
    <description>Recent content in Blockchains on hsiaosiyuan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 13 Jun 2019 00:00:00 +0000</lastBuildDate><atom:link href="http://hsiaosiyuan0.github.io/blockchain/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>crypto-conditions 简述</title>
      <link>http://hsiaosiyuan0.github.io/blockchain/crypto-conditions/</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://hsiaosiyuan0.github.io/blockchain/crypto-conditions/</guid>
      <description>crypto-conditions 简述  下文将 crypto-conditions 简称为 cc cc 的详细的文档描述见 ietf
 在现有的 public-key 这样的签名策略下，消息的传递过程如下:
 消息发送方 A 先将需要发送给消息接受方 B 的消息 M 进行摘要 H = hash(M) A 用自己的私钥对摘要进行加密得到 AEH (A&amp;rsquo;s encrypted hash 即 signature) A 将要发送的消息 M 以及签名 AEH 发送给 B B 接受到 M 后，对 M 进行摘要得到 BH B 使用 A 的公钥对 AEH 进行解密，得到 AH B 通过判断 BH == AH 是否成立来确定消息是否来自于 A  可以看到在 public-key 策略下，对一个消息的合法性的校验，发送方被限制成了单个实体 (one keypair)、单个条件 (签名匹配)
而 cc，则提供一个将现有加密验证算法进行条件组合的功能，比如上面的例子是 A 给 B 发送了消息，B 希望验证这个消息是 A 发送的。通过 cc，可以实现 A、C、D 一起给 B 发送了一个消息，B 可以验证 A、C、D 一起发送的，又或者 A、C、D 一起给 B 发送了一个消息，同时告诉 B，它们之间只要确定两个人，就可以证明消息的正确性，那么当 B 验证时，只要确保三人之间通过两人即可。</description>
    </item>
    
    <item>
      <title>实用拜占庭容错简介</title>
      <link>http://hsiaosiyuan0.github.io/blockchain/practical-byzantine-fault-tolerance/</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://hsiaosiyuan0.github.io/blockchain/practical-byzantine-fault-tolerance/</guid>
      <description>实用拜占庭容错简介 容错性一直是分布式系统中需要处理的问题，而拜占庭将军问题被认为是容错性问题中最难的问题类型之一。分布式账本作为一个分布式系统，也面临该问题，著名的比特币则是采用的 PoW 来应对该问题，类似的还有以太坊中的 PoS 等。本文则简单介绍了另一种解决方案，即实用拜占庭容错算法(Practical Byzantine Fault Tolerance) 该算法的衍生版本也在一些分布式账本系统中得到应用，比如 Neo。
关于拜占庭将军问题的简单描述如下：
 一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。
 以上内容摘自 维基百科-拜占庭将军问题。
在早期 1982 年的论文中提出的算法，并不具备非常高的实用性。因为为了达成共识，节点需要观察其余节点对消息的反应，这就需要消息需要以一个类似“递归”的形式在不同的轮次中的各个节点间传递。如果需要进一步了解其中的细节，除了参考论文实现外，还可以参考这篇文章 Mark Nelson - The Byzantine Generals Problem 。
而实用拜占庭容错算法，则提供了一个相对于早期算法而言，更易于实现、更高效的算法。
实用拜占庭容错算法，其实是将拜占庭将军问题简化成以下两点来考虑：
 系统中的消息，存在不可达的可能性，由于网络问题，软件自身错误等，简称 fail-stop 系统中可能存在恶意节点，故意破坏系统的一致性，简称 malicious  当系统只存在问题 1 时，该问题的其实就回到类似内网中的节点同步问题。Viewstamped Replication 或者 paxos 等算法都提供了对该问题的解决方案。而实用拜占庭容错算法，实际是在 Viewstamped Replication 算法上的升级、额外提供了对问题 2 的解决方案。
实用拜占庭容错算法，可以粗略的描述为：
在实用拜占庭容错算法中，将每次的共识称之为 view，在每次共识中，都会选择其中一个节点作为 primary，其余节点为 backups。每次的共识，即 view 都有一个自增的 id。当次 view 中的 primary 的选取规则为 P = v mod |R| v 表示 view id，|R| 表示节点总数，R 为 replica 的简写。</description>
    </item>
    
  </channel>
</rss>
