<!DOCTYPE html><html><head><title>Libuv 之上的 Node</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1, user-scalable=no, viewport-fit=cover"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.5.0/themes/prism-vsc-dark-plus.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/toolbar/prism-toolbar.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-highlight/prism-line-highlight.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/material-icons@0.3.1/iconfont/material-icons.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/material-icons@0.3.1/css/material-icons.min.css"/><link rel="stylesheet" href="/outlet__outlets_default_tsx.css"/><link rel="stylesheet" href="/shared-outlets_index_scss.css"/><link rel="stylesheet" href="/pages/post.css"/></head><body><div id="__gadget__"><div><div class="" style="position:fixed;top:0;left:0;height:2px;background:transparent;z-index:99999999999;width:100%"><div style="height:100%;background:#2998ff;transition:all 500ms ease;width:0%"><div style="box-shadow:0 0 10px #2998ff, 0 0 10px #2998ff;width:5%;opacity:1;position:absolute;height:100%;transition:all 500ms ease;transform:rotate(3deg) translate(0px, -4px);left:-10rem"></div></div></div><div class="_3k0uOgdSRfNa0MZs6QS7ku"><div class="_1G63502GZaEXBXykcWz6cX">The hard ways</div><div class="_3HRY5_KLp8kngNq9437Zqi"><a href="/sitemap.html">all</a></div></div><div class="Z_a6ax5LrTSVASNRR2aN6 _11dH37BK8JkWofQgbOzM4L"><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>v8</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/v8/debug-v8-in-vscode.html"><i class=""></i><span>debug-v8-in-vscode</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/v8/common-data-types.html"><i class=""></i><span>v8 常见数据类型</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>deno</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/deno/native-plugin.html"><i class=""></i><span>deno native plugin 内部实现机制</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>crypto</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/crypto/brief-crypto.html"><i class=""></i><span>加密算法调研</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>nodejs</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/Cluster 模块分析.html"><i class=""></i><span>Cluster 模块分析</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/build-from-source.html"><i class=""></i><span>build-from-source</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/node-addon.html"><i class=""></i><span>node-addon</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/common-snippet.html"><i class=""></i><span>common-snippet</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/heap-snapshot.html"><i class=""></i><span>v8 Heapsnapshot 文件解析</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/libuv.html"><i class=""></i><span>Libuv 之 - 只看这篇是不够的</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/object-in-v8.html"><i class=""></i><span>Objects in V8</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/node-on-libuv.html"><i class=""></i><span>Libuv 之上的 Node</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>websocket</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/websocket/WebSocket 协议 1~4 节.html"><i class=""></i><span>WebSocket 协议 1~4 节</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/websocket/WebSocket 协议 5~10 节.html"><i class=""></i><span>WebSocket 协议 5~10 节</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>assembly</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/assembly/汇编语言学习小结.html"><i class=""></i><span>汇编语言学习小结</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>typescript</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/typescript/decorator.html"><i class=""></i><span>Decorator in babel and tsc</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>rust</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/rust/lifetime.html"><i class=""></i><span>Lifetime</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>oop</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/oop/ioc.html"><i class=""></i><span>midway 分析</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>php</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/php/为什么 PHP 不适合长时间运行.html"><i class=""></i><span>为什么 PHP 不适合长时间运行</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>blockchain</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/blockchain/crypto-conditions 简述.html"><i class=""></i><span>crypto-conditions 简述</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/blockchain/实用拜占庭容错简介.html"><i class=""></i><span>实用拜占庭容错简介</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>browser</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/browser/浏览器异步加载和同源策略.html"><i class=""></i><span>浏览器异步加载和同源策略</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>cpp</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/cpp/the-as-if-rule.html"><i class=""></i><span>The as-if rule</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>work</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/work/parsing-in-practice.html"><i class=""></i><span>Parsing in practice</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>os</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/大小端序.html"><i class=""></i><span>大小端序</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/UTF-8 编码及检查其完整性.html"><i class=""></i><span>UTF-8 编码及检查其完整性</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/魔数0x7c00.html"><i class=""></i><span>魔数 0x7c00</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/字符集和字符编码.html"><i class=""></i><span>字符集和字符编码</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>javascript</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/generator function.html"><i class=""></i><span>Generator Function</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/解析 JSON 的成本.html"><i class=""></i><span>解析 JSON 的成本</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/Javascript 内部的字符编码.html"><i class=""></i><span>Javascript 内部的字符编码</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/闭包的作用.html"><i class=""></i><span>闭包的作用</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/闭包是什么.html"><i class=""></i><span>闭包是什么</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>static-analysis</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/static-analysis/ternjs.html"><i class=""></i><span>使用 Rust 重写 ternjs</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>craft</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/craft/create_your_own_lang.html"><i class=""></i><span>制作一个属于自己的语言</span></a><ul></ul></div></li></ul></div></div><div class="rWpFqfkPbEcRx8xnnjlEm line-numbers"><div><div><h1 id="Libuv之上的Node">Libuv 之上的 Node</h1>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9011621161/6e10/2fb0/da79/dda3ac51a84ee2baf9378417cfef618f.png" alt=""/></p>
<blockquote>
<p>图片来源：<a href="https://medium.datadriveninvestor.com/the-node-js-architecture-f86e2337bcd2">The Node.js Architecture</a></p>
</blockquote>
<blockquote>
<p>本文作者：<a href="https://github.com/hsiaosiyuan0">hsy</a></p>
</blockquote>
<p>之前有一篇对于 Libuv 的学习记录 - <a href="https://juejin.cn/post/6945702722645524517">Libuv 之 - 只看这篇是不够的</a>，该记录集中在对 Libuv 的学习，并未涉及 Node 是如何使用 Libuv 的，本文将在其基础上，继续学习和记录 Node 是如何运行于 Libuv 之上的</p>
<h2 id="Node的启动过程">Node 的启动过程</h2>
<p>我们首先调查的是 Node 的启动过程（只记录了与本次学习目的相关的环节）：</p>
<ul>
<li><a href="https://github.com/nodejs/node/blob/c276e7fb23d5ef31a951ace86ba3b6deebc4e4ee/src/node_main.cc#L111">main</a>
<ul>
<li><a href="https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L1069">node::Start</a>
<ul>
<li><a href="https://github.com/nodejs/node/blob/f0be9f52992d7f75f0b7e7f06fc6a0d4a2634656/src/node_main_instance.cc#L107">NodeMainInstance::Run</a>
<ul>
<li>
<p><a href="https://github.com/nodejs/node/blob/f0be9f52992d7f75f0b7e7f06fc6a0d4a2634656/src/node_main_instance.cc#L176">NodeMainInstance::CreateMainEnvironment</a></p>
<ul>
<li><a href="https://github.com/nodejs/node/blob/93f947af0a691297cab478b8a3631863494eca50/src/api/environment.cc#L339">node:CreateEnvironment</a>
<ul>
<li><a href="https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L384">Environment::RunBootstrapping</a></li>
<li><a href="https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L326">Environment::BootstrapNode</a>
<ul>
<li>
<p>运行 <a href="https://github.com/nodejs/node/blob/0477e000bfd2fbf14b327c0615c78bf9ea7f6809/lib/internal/bootstrap/node.js">internal/bootstrap/node.js</a></p>
<p>其中的 <a href="https://github.com/nodejs/node/blob/0477e000bfd2fbf14b327c0615c78bf9ea7f6809/lib/internal/bootstrap/node.js#L248">setupTimers(processImmediate, processTimers)</a> 注册了 <code>processImmediate</code> 和 <code>processTimers</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://github.com/nodejs/node/blob/93f947af0a691297cab478b8a3631863494eca50/src/api/environment.cc#L414">node::LoadEnvironment</a></p>
<ul>
<li>
<p><a href="https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L484">Environment::InitializeLibuv</a></p>
<p>仅把各式的 handle 初始化，仅通过 <code>uv_check_start</code> 启动了 <code>immediate_check_handle()</code>，其对应的回调是 <a href="https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L830">Environment::CheckImmediate</a></p>
</li>
<li>
<p><a href="https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L441">node::StartExecution</a></p>
<p>根据不同的启动方式（比如 REPL 或 worker thread）选择不同的入口脚本，我们 <code>node your_script.js</code> 的方式，将会进入到分支 <a href="https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L500">node.cc#L500</a></p>
<ul>
<li>
<p><a href="https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L417">node::StartExecution</a></p>
<p><code>main_script_id</code> 的实参是 <code>internal/main/run_main_module</code></p>
<ul>
<li>
<p>运行应用脚本 <a href="https://github.com/nodejs/node/blob/efce655c0f1671d0e86b5c89092ac93db983ef94/lib/internal/main/run_main_module.js#L17">internal/main/run_main_module.js</a></p>
<p>即命令 <code>node your_script.js</code> 中的 <code>your_script.js</code>，此时 event_loop 还未运行</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://github.com/nodejs/node/blob/f0be9f52992d7f75f0b7e7f06fc6a0d4a2634656/src/node_main_instance.cc#L133">uv_run</a> event_loop 开始运行</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>上面的启动环节中，<a href="https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L484">Environment::InitializeLibuv</a> 初始化了下面的 handles：</p>
<ul>
<li><code>timer_handle()</code></li>
<li><code>immediate_check_handle()</code></li>
<li><code>immediate_idle_handle()</code></li>
<li><code>task_queues_async_</code></li>
</ul>
<p>启动的过程可以粗略的概括成这样：</p>
<ul>
<li>初始化环境（一些内置的前置变量和函数），方便执行后续的用户脚本</li>
<li>执行用户脚本</li>
<li>进入事件循环</li>
</ul>
<p>进入事件循环之后，上面提到的 handles 就成了对 Node 后续流程解读的关键点，因此接下来会每个 handle 的作用进行介绍</p>
<h2 id="immediate_check_handle()">immediate_check_handle()</h2>
<p><code>immediate_check_handle()</code> 有几点值得关注：</p>
<ul>
<li>
<p>它在 <a href="https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L496">env.cc#L496</a> 处被启动</p>
</li>
<li>
<p>它对应的回调是 <a href="https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L830">Environment::CheckImmediate</a></p>
</li>
<li>
<p><code>Environment::CheckImmediate</code> 实际执行两块内容：</p>
<ul>
<li>
<p>通过 <a href="https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L838">env-&gt;RunAndClearNativeImmediates()</a> 来执行那些在 cpp 侧、使用 <a href="https://github.com/nodejs/node/blob/789798bedf760451a2b61bee51f3890950f44fee/src/env-inl.h#L752">Environment::SetImmediate</a> 或者 <a href="https://github.com/nodejs/node/blob/789798bedf760451a2b61bee51f3890950f44fee/src/env-inl.h#L764">Environment::SetImmediateThreadsafe</a> 注册的回调</p>
</li>
<li>
<p>通过 <a href="https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L844">MakeCallback(env-&gt;immediate_callback_function())</a> 执行那些在 js 侧、使用 <a href="https://github.com/nodejs/node/blob/cca0372022632465f1cf14febf8f848f989c8999/lib/timers.js#L277">setImmediate</a> 注册的回调 。其中的 <code>immediate_callback_function()</code> 就是上面启动步骤中 <code>setupTimers</code> 所注册的 <a href="https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L418">processImmediate</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="immediate_idle_handle()">immediate_idle_handle()</h2>
<p><code>immediate_idle_handle()</code> 并没有在初始化之后随即被启动，而是需要后续通过 <a href="https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L856">Environment::ToggleImmediateRef</a> 来启动或停止</p>
<p>按照源码的注释，<code>immediate_idle_handle()</code> 的作用就是防止事件循环在 io-polling 阶段进入阻塞模式：</p>
<blockquote>
<p>Idle handle is needed only to stop the event loop from blocking in poll.</p>
</blockquote>
<p>那么这里就有几个问题：</p>
<ul>
<li>io-polling 阶段在什么情况下会进入阻塞模式</li>
<li>为什么通过对 <code>immediate_idle_handle()</code> 使用 <code>uv_idle_start</code> 就能防止 io-polling 进入阻塞模式</li>
<li>为什么要防止 io-polling 进入阻塞模式</li>
</ul>
<p>详细的答案可以在之前的记录 <a href="https://juejin.cn/post/6945702722645524517#heading-19">io-poll timeout</a> 处找到</p>
<p>这里简单回答一下上面问题：</p>
<ul>
<li>当除了 io 事件监听队列外，没有其他待处理的事件监听队列</li>
<li>因为 <code>uv_idle_start</code> 增加了 idle 事件监听队列，结合上一条，所以可以防止 io-polling 进入阻塞模式</li>
<li>因为 libuv 需尽可能的为各个事件监听队列都分配到 CPU 时间，所以不能让某类任务占据的时间过长</li>
</ul>
<p>如果我们回顾一下 libuv 的内部执行流程：</p>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9001695906/534b/3c2b/119e/3232ec8d96aeec8c50f1d48419dd4ae0.png" alt=""/></p>
<p>会发现有另一个疑问 - <strong>为什么不把 <code>Environment::CheckImmediate</code> 直接放到 idle 阶段呢</strong>，这样岂不是可以省去单独再配置一个 <code>immediate_idle_handle()</code> 的环节</p>
<p>对于这个问题，可以观察下面这幅图，当应用启动完成后，后续应用的时间片将在 cpp 和 js 之间进行切换：</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9004190232/71ed/a1b6/ea2c/eba027e466a16722b3c9b96ae257b9ac.png" alt=""/></p>
<p>在处理 js 回调的过程中，会经过 cpp -&gt; js 然后 js -&gt; cpp 的过程</p>
<p>io-polling 会在当次循环中，依次执行符合触发条件的 js 回调，如果在回调中调用了 <code>setImmediate</code> 而其对应的处理又在 idle 阶段，那么会导致对应的回调需要延迟到下一次循环才会被处理，这样的行为就和 <code>setImmediate</code> 本身的功能定位产生了偏差</p>
<h2 id="task_queues_async_">task_queues_async_</h2>
<p><code>task_queues_async_</code> 的作用是为了在多线程环境下实现 <code>setImmediate</code> 功能，因为 cpp 扩展很可能运行在多线程环境下，所以利用 <a href="http://docs.libuv.org/en/v1.x/async.html#c.uv_async_t">uv_async_t</a> 来实现在主线程外的线程、添加 immediate 并通知主线程进行处理的功能</p>
<p>在 <a href="https://juejin.cn/post/6945702722645524517#heading-21">Thead pool</a> 一节中，我们已经知道 <code>uv_async_t</code> 在 linux 下的核心实现就是利用 <code>epoll_create</code> 创建虚拟的 fd 来利用 epoll 的功能，因此 <code>uv_async_t</code> 和未来可能接触到的 <code>uv_work_t</code> 其回调都是在事件循环的 io-polling 阶段被处理的</p>
<h2 id="timer_handle()">timer_handle()</h2>
<p>上文我们提到，Node 内部在使用 libuv 处理 js 回调的时候，会出现 cpp -&gt; js 和 js -&gt; cpp 这样来回切换的情况。因为 cpp 代码和 js 经过 JIT 后的代码在内存分布上相隔比较远，来回跳跃会导致程序无法有效利用 CPU 指令缓存</p>
<p>并且在 Node 应用中，通常会有很多的 timers 需要处理，因此 Node 中将 timers 回调移动到 js 执行环境中处理，这样就能够减少 cpp 和 js 来回切换的次数，以此提高应用整体的性能表现。在 <a href="https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L5">timers.js#L548</a> 文件开头的注释中，也有一些相关说明</p>
<p>我们在 <a href="https://juejin.cn/post/6945702722645524517#heading-11">timer</a> 一节中，介绍过 timer 在实现上主要依赖的数据结构就是 min heap，现在为了将 timers 的处理移动到 js 执行环境中，Node 中使用 js 也实现了一些类似的数据结构</p>
<p>为了方便在 js 环境下处理 timers，Node 中将一些更细颗粒度的 API 封装到了模块 <a href="https://github.com/nodejs/node/blob/90c4113d2675adbae76e59fc52843bfcd42636bf/src/timers.cc#L65">timers</a> 中。比如，在内部 js 实现中使用 timers 模块提供的 <code>scheduleTimer</code> 方法，就可以设置一个 libuv 层面的定时器，因为该方法对应的 native 实现是 <a href="https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L755">Environment::ScheduleTimer</a>：</p>
<pre><code class="language-cpp">void Environment::ScheduleTimer(int64_t duration_ms) {
  if (started_cleanup_) return;
  uv_timer_start(timer_handle(), RunTimers, duration_ms, 0);
}
</code></pre>
<p>通过上面的代码，我们可以知道定时器对应的回调是方法 <code>RunTimers</code></p>
<p>而如果我们进一步调查 <a href="https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L768">RunTimers</a> 的实现，会发现其中的主要逻辑就是调用 <code>env-&gt;timers_callback_function()</code> 上的 js 方法，该方法就是上文提到的启动阶段中的 <code>setupTimers</code> 注册的 js 方法 <a href="https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L482">processTimers</a></p>
<h2 id="setTimeout,setInterval">setTimeout, setInterval</h2>
<p><code>setInterval</code> 和 <code>setTimeout</code> 从内部实现来相差不大，前者会在一次 timer 超时后，再次添加一个新的 timer，详见 <a href="https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L548">timers.js#L548</a></p>
<p>为了了解 <code>setTimeout</code> 内部的实现方式，文件 <a href="https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L34">开头的注释</a> 非常重要：</p>
<pre><code class="language-js">// ╔════ &gt; Object Map
// ║
// ╠══
// ║ lists: { &#x27;40&#x27;: { }, &#x27;320&#x27;: { etc } } (keys of millisecond duration)
// ╚══          ┌────┘
//              │
// ╔══          │
// ║ TimersList { _idleNext: { }, _idlePrev: (self) }
// ║         ┌────────────────┘
// ║    ╔══  │                              ^
// ║    ║    { _idleNext: { },  _idlePrev: { }, _onTimeout: (callback) }
// ║    ║      ┌───────────┘
// ║    ║      │                                  ^
// ║    ║      { _idleNext: { etc },  _idlePrev: { }, _onTimeout: (callback) }
// ╠══  ╠══
// ║    ║
// ║    ╚════ &gt;  Actual JavaScript timeouts
// ║
// ╚════ &gt; Linked List
</code></pre>
<p>通过上面的注释所描述的数据结构，我们可以知道 timers 都按它们的 timeout 被汇集到了 <code>lists</code> 中。其中的 key 就是每个具体的 timeout 值，每个 key 下汇集了具有相同 timeout 值的 timers</p>
<p>然后 js 中会使用 <code>scheduleTimer</code> 来设置仅一个 libuv 定时器（如果有正在运行的定时器、且该定时期的超时范围涵盖了当前要添加的定时器的话），并在其回调中尽可能处理多的 timers</p>
<p>当然，将 timers 都按照它们的 timeout 汇集到一起也存在一个问题：</p>
<pre><code class="language-js">setTimeout(() =&gt; {}, 100); // 1
setTimeout(() =&gt; {}, 100); // 2
</code></pre>
<p>上面我们添加了两个 timers，分别称之为 timer1 和 timer2，按照目前的规则，它们会被归纳到 <code>lists</code> 中的 key 为 <code>100</code> 的链表中，然后 <code>scheduleTimer</code> 会设置一个 100 毫秒的定时器（假设当前没有正在运行的定时器）</p>
<ul>
<li>我们使用 <code>s0</code> 表示<code>scheduleTimer</code> 调用的时间，<code>FT0</code> 表示定时器未来触发的时间</li>
<li>使用 <code>s1</code> 表示第一个 <code>setTimeout</code> 调用的时间，那么 timer1 的回调时间 <code>FT1</code> 预期在 <code>&gt;= s1 + 100</code> 的时间被调用才是合理的</li>
<li>使用 <code>s2</code> 表示第二个 <code>setTimeout</code> 调用的时间，那么 timer2 的回调时间 <code>FT2</code> 预期在 <code>&gt;= s2 + 100</code> 的时间被调用才是合理的</li>
</ul>
<p>根据上面的定义我们绘制出下面的时间线：</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9013040965/6b3e/53fc/c7cb/6f08de4bc43641c09c979a59565dfdd4.png" alt=""/></p>
<p>s0 在 s1 之后，是因为 <code>scheduleTimer</code> 是由第一次 <code>setTimeout</code> 调用的</p>
<p>通过图例，我们可以发现 FT0 的可能时间范围是大于 FT2 的，因此实际的 FT0 可能并不落在 FT2 的范围之内，若出现这样的情况，那么执行 timer2 就为时尚早。因此在 js 实现的 <code>processTimers</code> 中是有一部分 <a href="https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L514">逻辑</a> 来处理这个问题的。处理的方式就是，对于未到时间的 timers 当次不执行，并重新设置定时器，在未来的时间点执行它们</p>
<p><code>processTimers</code> 和 <code>processImmediate</code> 中另一个关键部分是其中都会穿插执行 <a href="https://github.com/nodejs/node/blob/9a4a283b30402fb4fb43be5593ce1d1458ab6170/lib/internal/process/task_queues.js#L56">runNextTicks</a>，而 runNextTicks 中会分别执行 ticks 和 Microtask Queue 中的内容</p>
<p>后面会有整体的图例，因此目前我们只要对细节有一些了解即可</p>
<h2 id="microtasks">microtasks</h2>
<p>microtasks 是 v8 为了提高 <code>async/await</code> 和 promise 的执行效率而引入的元素，详细的介绍可以参考 <a href="https://v8.dev/blog/fast-async">Faster async functions and promises</a>，这里我们只借用文中的一幅图来大致理解一下内部的运行方式：</p>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9006953106/93d1/5ab4/ef67/d9a2f95eded095bb39657f827ad18144.png" alt=""/></p>
<p>图中有两个数据结构：Execution Stack 和  Microtask Queue，我们的同步代码都在 Execution Stack 中执行，同步代码中涉及的 <code>async/await</code> 和 promise 都被装载到 Microtask Queue 中。引擎提供了 API 让嵌入方（比如 Node）选择性地执行 Microtask Queue 中的任务，也提供了 API 让嵌入方可以往 Microtask Queue 中追加任务</p>
<p>每次由 cpp -&gt; js 的调用，都会借助 <a href="https://github.com/nodejs/node/blob/5a85d4f2c68e207d3868e9c8e8b511a6aaba2144/src/api/callback.cc#L76">InternalCallbackScope::~InternalCallbackScope</a> 来<strong>层层调用</strong>到 <a href="https://github.com/nodejs/node/blob/93f947af0a691297cab478b8a3631863494eca50/src/node_task_queue.cc#L101">node::RunMicrotasks</a> 以执行 Microtask Queue 中的任务</p>
<p>关于上述层层调用的细节：</p>
<ul>
<li>InternalCallbackScope 使用 cpp 中 <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> 范式，在其 <a href="https://github.com/nodejs/node/blob/5a85d4f2c68e207d3868e9c8e8b511a6aaba2144/src/api/callback.cc#L76">析构函数</a> 逻辑中调用 <a href="https://github.com/nodejs/node/blob/5a85d4f2c68e207d3868e9c8e8b511a6aaba2144/src/api/callback.cc#L81">InternalCallbackScope::Close</a> 方法</li>
<li>InternalCallbackScope::Close 中会调用 <a href="https://github.com/nodejs/node/blob/5a85d4f2c68e207d3868e9c8e8b511a6aaba2144/src/api/callback.cc#L135">env_-&gt;tick_callback_function()</a></li>
<li>env_-&gt;tick_callback_function() 是在 <a href="https://github.com/nodejs/node/blob/9a4a283b30402fb4fb43be5593ce1d1458ab6170/lib/internal/process/task_queues.js#L175">task_queues.js#L175</a> 注册的</li>
<li>所以每次 cpp -&gt; js 的调用结束都会（大部分）调用 <a href="https://github.com/nodejs/node/blob/9a4a283b30402fb4fb43be5593ce1d1458ab6170/lib/internal/process/task_queues.js#L65">processTicksAndRejections</a> 来执行 ticks 和 Microtask Queue 中的内容</li>
</ul>
<p>下面这幅图提供了一个整体的视角：</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9010638475/33a5/94a7/e116/5823e1cd5f9d2be5d485ff49bbf92e07.png" alt=""/></p>
<p>虽然在源码上 <code>processTicksAndRejections</code> 是在内部调用的 <code>runMicrotasks</code>，不过为了方便理解，在图中对它们进行了独立展示</p>
<p>通过上面的图，我们可以稍微小结一下，对于 Node 应用而言：</p>
<ul>
<li>其时间片被分割到不同的回调函数中</li>
<li>回调会由 libuv 的事件触发，发生由 cpp -&gt; js 的调用</li>
<li>js 回调执行完毕后，都会对 ticks 和 Microtask Queue 中积累的内容进行一次处理</li>
<li><code>async/await</code> 和 promise（除构造函数） 会被装载到 Microtask Queue 中</li>
</ul>
<h2 id="小结">小结</h2>
<p>文本作为 <a href="https://juejin.cn/post/6945702722645524517">Libuv 之 - 只看这篇是不够的</a> 的姊妹篇，对 Node 是如何运行于 Libuv 之上做了简单的学习记录，希望可以为有兴趣深入的同学抛砖引玉。同时欢迎大家对文中的纰漏进行指正，一起探索 Node 的内部机理</p></div></div></div><div class="_3a4jt6lr4yLRJnQge009wv"><ul><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#Node的启动过程">Node 的启动过程</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#immediate_check_handle()">immediate_check_handle()</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#immediate_idle_handle()">immediate_idle_handle()</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#task_queues_async_">task_queues_async_</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#timer_handle()">timer_handle()</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#setTimeout,setInterval">setTimeout, setInterval</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#microtasks">microtasks</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#小结">小结</a></span></div><ul></ul></div></li></ul></div><div class="_1UY_ItV2UTWKutKs5b7NKg">Made with <a target="_blank" href="https://github.com/hsiaosiyuan0/gadget">gadget</a></div></div></div><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-core.min.js" data-manual="true"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-markup.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-clike.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-json.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-javascript.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-jsx.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-typescript.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-tsx.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-bash.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-python.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-xml-doc.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-docker.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-rust.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-nasm.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-c.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-cpp.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-xml-doc.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/toolbar/prism-toolbar.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-highlight/prism-line-highlight.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/show-language/prism-show-language.min.js"></script><script src="https://cdn.jsdelivr.net/gh/cferdinandi/gumshoe@5.1.1/dist/gumshoe.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react@16.14.0/umd/react.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react-dom@16.14.0/umd/react-dom.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react@16.14.0/umd/react.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react-dom@16.14.0/umd/react-dom.production.min.js"></script><script>window["__gadget__"]={"initialProps":{"data":{"post":{"filename":"node-on-libuv","rawMeta":{"title":"Libuv 之上的 Node"},"content":"# Libuv 之上的 Node\n\n![](https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9011621161/6e10/2fb0/da79/dda3ac51a84ee2baf9378417cfef618f.png)\n\n> 图片来源：[The Node.js Architecture](https://medium.datadriveninvestor.com/the-node-js-architecture-f86e2337bcd2)\n\n> 本文作者：[hsy](https://github.com/hsiaosiyuan0)\n\n\n之前有一篇对于 Libuv 的学习记录 - [Libuv 之 - 只看这篇是不够的](https://juejin.cn/post/6945702722645524517)，该记录集中在对 Libuv 的学习，并未涉及 Node 是如何使用 Libuv 的，本文将在其基础上，继续学习和记录 Node 是如何运行于 Libuv 之上的\n\n## Node 的启动过程\n\n我们首先调查的是 Node 的启动过程（只记录了与本次学习目的相关的环节）：\n\n- [main](https://github.com/nodejs/node/blob/c276e7fb23d5ef31a951ace86ba3b6deebc4e4ee/src/node_main.cc#L111)\n  - [node::Start](https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L1069)\n    - [NodeMainInstance::Run](https://github.com/nodejs/node/blob/f0be9f52992d7f75f0b7e7f06fc6a0d4a2634656/src/node_main_instance.cc#L107)\n      - [NodeMainInstance::CreateMainEnvironment](https://github.com/nodejs/node/blob/f0be9f52992d7f75f0b7e7f06fc6a0d4a2634656/src/node_main_instance.cc#L176)\n        - [node:CreateEnvironment](https://github.com/nodejs/node/blob/93f947af0a691297cab478b8a3631863494eca50/src/api/environment.cc#L339)\n          - [Environment::RunBootstrapping](https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L384)\n          - [Environment::BootstrapNode](https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L326) \n            - 运行 [internal/bootstrap/node.js](https://github.com/nodejs/node/blob/0477e000bfd2fbf14b327c0615c78bf9ea7f6809/lib/internal/bootstrap/node.js) \n            \n              其中的 [setupTimers(processImmediate, processTimers)](https://github.com/nodejs/node/blob/0477e000bfd2fbf14b327c0615c78bf9ea7f6809/lib/internal/bootstrap/node.js#L248) 注册了 `processImmediate` 和 `processTimers`\n\n      - [node::LoadEnvironment](https://github.com/nodejs/node/blob/93f947af0a691297cab478b8a3631863494eca50/src/api/environment.cc#L414)\n        - [Environment::InitializeLibuv](https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L484) \n        \n          仅把各式的 handle 初始化，仅通过 `uv_check_start` 启动了 `immediate_check_handle()`，其对应的回调是 [Environment::CheckImmediate](https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L830)\n\n        - [node::StartExecution](https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L441) \n        \n          根据不同的启动方式（比如 REPL 或 worker thread）选择不同的入口脚本，我们 `node your_script.js` 的方式，将会进入到分支 [node.cc#L500](https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L500)\n          - [node::StartExecution](https://github.com/nodejs/node/blob/1e1cb94e69c65f2d2b4307315286f4181c974f1a/src/node.cc#L417) \n          \n            `main_script_id` 的实参是 `internal/main/run_main_module`\n\n            - 运行应用脚本 [internal/main/run_main_module.js](https://github.com/nodejs/node/blob/efce655c0f1671d0e86b5c89092ac93db983ef94/lib/internal/main/run_main_module.js#L17) \n            \n              即命令 `node your_script.js` 中的 `your_script.js`，此时 event_loop 还未运行\n\n      - [uv_run](https://github.com/nodejs/node/blob/f0be9f52992d7f75f0b7e7f06fc6a0d4a2634656/src/node_main_instance.cc#L133) event_loop 开始运行\n\n\n上面的启动环节中，[Environment::InitializeLibuv](https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L484) 初始化了下面的 handles：\n\n- `timer_handle()`\n- `immediate_check_handle()`\n- `immediate_idle_handle()`\n- `task_queues_async_`\n\n启动的过程可以粗略的概括成这样：\n\n- 初始化环境（一些内置的前置变量和函数），方便执行后续的用户脚本\n- 执行用户脚本\n- 进入事件循环\n\n进入事件循环之后，上面提到的 handles 就成了对 Node 后续流程解读的关键点，因此接下来会每个 handle 的作用进行介绍\n\n## immediate_check_handle()\n\n`immediate_check_handle()` 有几点值得关注：\n\n- 它在 [env.cc#L496](https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L496) 处被启动\n- 它对应的回调是 [Environment::CheckImmediate](https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L830)\n- `Environment::CheckImmediate` 实际执行两块内容：\n\n  - 通过 [env->RunAndClearNativeImmediates()](https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L838) 来执行那些在 cpp 侧、使用 [Environment::SetImmediate](https://github.com/nodejs/node/blob/789798bedf760451a2b61bee51f3890950f44fee/src/env-inl.h#L752) 或者 [Environment::SetImmediateThreadsafe](https://github.com/nodejs/node/blob/789798bedf760451a2b61bee51f3890950f44fee/src/env-inl.h#L764) 注册的回调 \n\n  - 通过 [MakeCallback(env->immediate_callback_function())](https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L844) 执行那些在 js 侧、使用 [setImmediate](https://github.com/nodejs/node/blob/cca0372022632465f1cf14febf8f848f989c8999/lib/timers.js#L277) 注册的回调 。其中的 `immediate_callback_function()` 就是上面启动步骤中 `setupTimers` 所注册的 [processImmediate](https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L418)\n\n\n## immediate_idle_handle()\n\n`immediate_idle_handle()` 并没有在初始化之后随即被启动，而是需要后续通过 [Environment::ToggleImmediateRef](https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L856) 来启动或停止\n\n按照源码的注释，`immediate_idle_handle()` 的作用就是防止事件循环在 io-polling 阶段进入阻塞模式：\n\n> Idle handle is needed only to stop the event loop from blocking in poll.\n\n那么这里就有几个问题：\n\n- io-polling 阶段在什么情况下会进入阻塞模式\n- 为什么通过对 `immediate_idle_handle()` 使用 `uv_idle_start` 就能防止 io-polling 进入阻塞模式\n- 为什么要防止 io-polling 进入阻塞模式\n\n详细的答案可以在之前的记录 [io-poll timeout](https://juejin.cn/post/6945702722645524517#heading-19) 处找到\n\n这里简单回答一下上面问题：\n\n- 当除了 io 事件监听队列外，没有其他待处理的事件监听队列\n- 因为 `uv_idle_start` 增加了 idle 事件监听队列，结合上一条，所以可以防止 io-polling 进入阻塞模式\n- 因为 libuv 需尽可能的为各个事件监听队列都分配到 CPU 时间，所以不能让某类任务占据的时间过长\n\n如果我们回顾一下 libuv 的内部执行流程：\n\n![](https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9001695906/534b/3c2b/119e/3232ec8d96aeec8c50f1d48419dd4ae0.png)\n\n会发现有另一个疑问 - **为什么不把 `Environment::CheckImmediate` 直接放到 idle 阶段呢**，这样岂不是可以省去单独再配置一个 `immediate_idle_handle()` 的环节\n\n对于这个问题，可以观察下面这幅图，当应用启动完成后，后续应用的时间片将在 cpp 和 js 之间进行切换：\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9004190232/71ed/a1b6/ea2c/eba027e466a16722b3c9b96ae257b9ac.png)\n\n在处理 js 回调的过程中，会经过 cpp -> js 然后 js -> cpp 的过程\n\nio-polling 会在当次循环中，依次执行符合触发条件的 js 回调，如果在回调中调用了 `setImmediate` 而其对应的处理又在 idle 阶段，那么会导致对应的回调需要延迟到下一次循环才会被处理，这样的行为就和 `setImmediate` 本身的功能定位产生了偏差\n\n## task_queues_async_\n\n`task_queues_async_` 的作用是为了在多线程环境下实现 `setImmediate` 功能，因为 cpp 扩展很可能运行在多线程环境下，所以利用 [uv_async_t](http://docs.libuv.org/en/v1.x/async.html#c.uv_async_t) 来实现在主线程外的线程、添加 immediate 并通知主线程进行处理的功能\n\n在 [Thead pool](https://juejin.cn/post/6945702722645524517#heading-21) 一节中，我们已经知道 `uv_async_t` 在 linux 下的核心实现就是利用 `epoll_create` 创建虚拟的 fd 来利用 epoll 的功能，因此 `uv_async_t` 和未来可能接触到的 `uv_work_t` 其回调都是在事件循环的 io-polling 阶段被处理的\n\n## timer_handle()\n\n上文我们提到，Node 内部在使用 libuv 处理 js 回调的时候，会出现 cpp -> js 和 js -> cpp 这样来回切换的情况。因为 cpp 代码和 js 经过 JIT 后的代码在内存分布上相隔比较远，来回跳跃会导致程序无法有效利用 CPU 指令缓存\n\n并且在 Node 应用中，通常会有很多的 timers 需要处理，因此 Node 中将 timers 回调移动到 js 执行环境中处理，这样就能够减少 cpp 和 js 来回切换的次数，以此提高应用整体的性能表现。在 [timers.js#L548](https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L5) 文件开头的注释中，也有一些相关说明\n\n我们在 [timer](https://juejin.cn/post/6945702722645524517#heading-11) 一节中，介绍过 timer 在实现上主要依赖的数据结构就是 min heap，现在为了将 timers 的处理移动到 js 执行环境中，Node 中使用 js 也实现了一些类似的数据结构\n\n为了方便在 js 环境下处理 timers，Node 中将一些更细颗粒度的 API 封装到了模块 [timers](https://github.com/nodejs/node/blob/90c4113d2675adbae76e59fc52843bfcd42636bf/src/timers.cc#L65) 中。比如，在内部 js 实现中使用 timers 模块提供的 `scheduleTimer` 方法，就可以设置一个 libuv 层面的定时器，因为该方法对应的 native 实现是 [Environment::ScheduleTimer](https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L755)：\n\n```cpp\nvoid Environment::ScheduleTimer(int64_t duration_ms) {\n  if (started_cleanup_) return;\n  uv_timer_start(timer_handle(), RunTimers, duration_ms, 0);\n}\n```\n\n通过上面的代码，我们可以知道定时器对应的回调是方法 `RunTimers`\n\n而如果我们进一步调查 [RunTimers](https://github.com/nodejs/node/blob/73ef3f2f050a874712d1770ddd4e02930a638eda/src/env.cc#L768) 的实现，会发现其中的主要逻辑就是调用 `env->timers_callback_function()` 上的 js 方法，该方法就是上文提到的启动阶段中的 `setupTimers` 注册的 js 方法 [processTimers](https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L482)\n\n\n## setTimeout, setInterval\n\n`setInterval` 和 `setTimeout` 从内部实现来相差不大，前者会在一次 timer 超时后，再次添加一个新的 timer，详见 [timers.js#L548](https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L548)\n\n为了了解 `setTimeout` 内部的实现方式，文件 [开头的注释](https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L34) 非常重要：\n\n```js\n// ╔════ > Object Map\n// ║\n// ╠══\n// ║ lists: { '40': { }, '320': { etc } } (keys of millisecond duration)\n// ╚══          ┌────┘\n//              │\n// ╔══          │\n// ║ TimersList { _idleNext: { }, _idlePrev: (self) }\n// ║         ┌────────────────┘\n// ║    ╔══  │                              ^\n// ║    ║    { _idleNext: { },  _idlePrev: { }, _onTimeout: (callback) }\n// ║    ║      ┌───────────┘\n// ║    ║      │                                  ^\n// ║    ║      { _idleNext: { etc },  _idlePrev: { }, _onTimeout: (callback) }\n// ╠══  ╠══\n// ║    ║\n// ║    ╚════ >  Actual JavaScript timeouts\n// ║\n// ╚════ > Linked List\n```\n\n通过上面的注释所描述的数据结构，我们可以知道 timers 都按它们的 timeout 被汇集到了 `lists` 中。其中的 key 就是每个具体的 timeout 值，每个 key 下汇集了具有相同 timeout 值的 timers\n\n然后 js 中会使用 `scheduleTimer` 来设置仅一个 libuv 定时器（如果有正在运行的定时器、且该定时期的超时范围涵盖了当前要添加的定时器的话），并在其回调中尽可能处理多的 timers\n\n当然，将 timers 都按照它们的 timeout 汇集到一起也存在一个问题：\n\n```js\nsetTimeout(() => {}, 100); // 1\nsetTimeout(() => {}, 100); // 2\n```\n\n上面我们添加了两个 timers，分别称之为 timer1 和 timer2，按照目前的规则，它们会被归纳到 `lists` 中的 key 为 `100` 的链表中，然后 `scheduleTimer` 会设置一个 100 毫秒的定时器（假设当前没有正在运行的定时器）\n\n- 我们使用 `s0` 表示`scheduleTimer` 调用的时间，`FT0` 表示定时器未来触发的时间\n- 使用 `s1` 表示第一个 `setTimeout` 调用的时间，那么 timer1 的回调时间 `FT1` 预期在 `>= s1 + 100` 的时间被调用才是合理的\n- 使用 `s2` 表示第二个 `setTimeout` 调用的时间，那么 timer2 的回调时间 `FT2` 预期在 `>= s2 + 100` 的时间被调用才是合理的\n\n根据上面的定义我们绘制出下面的时间线：\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9013040965/6b3e/53fc/c7cb/6f08de4bc43641c09c979a59565dfdd4.png)\n\ns0 在 s1 之后，是因为 `scheduleTimer` 是由第一次 `setTimeout` 调用的\n\n通过图例，我们可以发现 FT0 的可能时间范围是大于 FT2 的，因此实际的 FT0 可能并不落在 FT2 的范围之内，若出现这样的情况，那么执行 timer2 就为时尚早。因此在 js 实现的 `processTimers` 中是有一部分 [逻辑](https://github.com/nodejs/node/blob/41aac465cc52cb922ce58fb2ea002fd2587fbb74/lib/internal/timers.js#L514) 来处理这个问题的。处理的方式就是，对于未到时间的 timers 当次不执行，并重新设置定时器，在未来的时间点执行它们\n\n`processTimers` 和 `processImmediate` 中另一个关键部分是其中都会穿插执行 [runNextTicks](https://github.com/nodejs/node/blob/9a4a283b30402fb4fb43be5593ce1d1458ab6170/lib/internal/process/task_queues.js#L56)，而 runNextTicks 中会分别执行 ticks 和 Microtask Queue 中的内容\n\n后面会有整体的图例，因此目前我们只要对细节有一些了解即可\n\n## microtasks\n\nmicrotasks 是 v8 为了提高 `async/await` 和 promise 的执行效率而引入的元素，详细的介绍可以参考 [Faster async functions and promises](https://v8.dev/blog/fast-async)，这里我们只借用文中的一幅图来大致理解一下内部的运行方式：\n\n![](https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9006953106/93d1/5ab4/ef67/d9a2f95eded095bb39657f827ad18144.png)\n\n图中有两个数据结构：Execution Stack 和  Microtask Queue，我们的同步代码都在 Execution Stack 中执行，同步代码中涉及的 `async/await` 和 promise 都被装载到 Microtask Queue 中。引擎提供了 API 让嵌入方（比如 Node）选择性地执行 Microtask Queue 中的任务，也提供了 API 让嵌入方可以往 Microtask Queue 中追加任务\n\n每次由 cpp -> js 的调用，都会借助 [InternalCallbackScope::~InternalCallbackScope](https://github.com/nodejs/node/blob/5a85d4f2c68e207d3868e9c8e8b511a6aaba2144/src/api/callback.cc#L76) 来**层层调用**到 [node::RunMicrotasks](https://github.com/nodejs/node/blob/93f947af0a691297cab478b8a3631863494eca50/src/node_task_queue.cc#L101) 以执行 Microtask Queue 中的任务\n\n关于上述层层调用的细节：\n\n- InternalCallbackScope 使用 cpp 中 [RAII](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization) 范式，在其 [析构函数](https://github.com/nodejs/node/blob/5a85d4f2c68e207d3868e9c8e8b511a6aaba2144/src/api/callback.cc#L76) 逻辑中调用 [InternalCallbackScope::Close](https://github.com/nodejs/node/blob/5a85d4f2c68e207d3868e9c8e8b511a6aaba2144/src/api/callback.cc#L81) 方法\n- InternalCallbackScope::Close 中会调用 [env_->tick_callback_function()](https://github.com/nodejs/node/blob/5a85d4f2c68e207d3868e9c8e8b511a6aaba2144/src/api/callback.cc#L135)\n- env_->tick_callback_function() 是在 [task_queues.js#L175](https://github.com/nodejs/node/blob/9a4a283b30402fb4fb43be5593ce1d1458ab6170/lib/internal/process/task_queues.js#L175) 注册的\n- 所以每次 cpp -> js 的调用结束都会（大部分）调用 [processTicksAndRejections](https://github.com/nodejs/node/blob/9a4a283b30402fb4fb43be5593ce1d1458ab6170/lib/internal/process/task_queues.js#L65) 来执行 ticks 和 Microtask Queue 中的内容\n\n下面这幅图提供了一个整体的视角：\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9010638475/33a5/94a7/e116/5823e1cd5f9d2be5d485ff49bbf92e07.png)\n\n虽然在源码上 `processTicksAndRejections` 是在内部调用的 `runMicrotasks`，不过为了方便理解，在图中对它们进行了独立展示\n\n通过上面的图，我们可以稍微小结一下，对于 Node 应用而言：\n\n- 其时间片被分割到不同的回调函数中\n- 回调会由 libuv 的事件触发，发生由 cpp -> js 的调用\n- js 回调执行完毕后，都会对 ticks 和 Microtask Queue 中积累的内容进行一次处理\n- `async/await` 和 promise（除构造函数） 会被装载到 Microtask Queue 中\n\n## 小结\n\n文本作为 [Libuv 之 - 只看这篇是不够的](https://juejin.cn/post/6945702722645524517) 的姊妹篇，对 Node 是如何运行于 Libuv 之上做了简单的学习记录，希望可以为有兴趣深入的同学抛砖引玉。同时欢迎大家对文中的纰漏进行指正，一起探索 Node 的内部机理 \n","slug":"/nodejs/node-on-libuv","toc":[{"name":"Node 的启动过程","depth":2,"anchor":"#Node的启动过程","children":[]},{"name":"immediate_check_handle()","depth":2,"anchor":"#immediate_check_handle()","children":[]},{"name":"immediate_idle_handle()","depth":2,"anchor":"#immediate_idle_handle()","children":[]},{"name":"task_queues_async_","depth":2,"anchor":"#task_queues_async_","children":[]},{"name":"timer_handle()","depth":2,"anchor":"#timer_handle()","children":[]},{"name":"setTimeout, setInterval","depth":2,"anchor":"#setTimeout,setInterval","children":[]},{"name":"microtasks","depth":2,"anchor":"#microtasks","children":[]},{"name":"小结","depth":2,"anchor":"#小结","children":[]}],"keywords":[],"mtime":1621348190168},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"craft","url":"/post/craft","children":[{"name":"制作一个属于自己的语言","url":"/post/craft/create_your_own_lang.html","children":[]}]}],"title":"The hard ways"}},"currentRoute":{"pattern":"/post","href":{"pathname":"/post"}},"pageModules":{"/index":["/pages/index.js"],"/post":["/pages/post.css","/pages/post.js"],"/sitemap":["/pages/sitemap.css","/pages/sitemap.js"],"/post/*":["/pages/post.css","/pages/post.js"]},"router":{"basename":"/","hash":false,"routes":["/index","/post","/sitemap","/post/*"]}};</script><script crossorigin="anonymous" src="/app.js"></script><script crossorigin="anonymous" src="/foundation.js"></script><script crossorigin="anonymous" src="/lib.js"></script><script crossorigin="anonymous" src="/shared-pages_post_tsx.js"></script><script crossorigin="anonymous" src="/pages/post.js"></script></body></html>