<!DOCTYPE html><html><head><title>v8 Heapsnapshot 文件解析</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1, user-scalable=no, viewport-fit=cover"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.5.0/themes/prism-vsc-dark-plus.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/toolbar/prism-toolbar.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-highlight/prism-line-highlight.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/material-icons@0.3.1/iconfont/material-icons.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/material-icons@0.3.1/css/material-icons.min.css"/><link rel="stylesheet" href="/outlet__outlets_default_tsx.css"/><link rel="stylesheet" href="/shared-outlets_index_scss.css"/><link rel="stylesheet" href="/pages/post.css"/></head><body><div id="__gadget__"><div><div class="" style="position:fixed;top:0;left:0;height:2px;background:transparent;z-index:99999999999;width:100%"><div style="height:100%;background:#2998ff;transition:all 500ms ease;width:0%"><div style="box-shadow:0 0 10px #2998ff, 0 0 10px #2998ff;width:5%;opacity:1;position:absolute;height:100%;transition:all 500ms ease;transform:rotate(3deg) translate(0px, -4px);left:-10rem"></div></div></div><div class="_3k0uOgdSRfNa0MZs6QS7ku"><div class="_1G63502GZaEXBXykcWz6cX">The hard ways</div><div class="_3HRY5_KLp8kngNq9437Zqi"><a href="/sitemap.html">all</a></div></div><div class="Z_a6ax5LrTSVASNRR2aN6 _11dH37BK8JkWofQgbOzM4L"><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>v8</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/v8/debug-v8-in-vscode.html"><i class=""></i><span>debug-v8-in-vscode</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/v8/common-data-types.html"><i class=""></i><span>v8 常见数据类型</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>deno</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/deno/native-plugin.html"><i class=""></i><span>deno native plugin 内部实现机制</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>crypto</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/crypto/brief-crypto.html"><i class=""></i><span>加密算法调研</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>nodejs</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/Cluster 模块分析.html"><i class=""></i><span>Cluster 模块分析</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/build-from-source.html"><i class=""></i><span>build-from-source</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/node-addon.html"><i class=""></i><span>node-addon</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/common-snippet.html"><i class=""></i><span>common-snippet</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/heap-snapshot.html"><i class=""></i><span>v8 Heapsnapshot 文件解析</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/libuv.html"><i class=""></i><span>Libuv 之 - 只看这篇是不够的</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/object-in-v8.html"><i class=""></i><span>Objects in V8</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/node-on-libuv.html"><i class=""></i><span>Libuv 之上的 Node</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>websocket</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/websocket/WebSocket 协议 1~4 节.html"><i class=""></i><span>WebSocket 协议 1~4 节</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/websocket/WebSocket 协议 5~10 节.html"><i class=""></i><span>WebSocket 协议 5~10 节</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>assembly</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/assembly/汇编语言学习小结.html"><i class=""></i><span>汇编语言学习小结</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>typescript</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/typescript/decorator.html"><i class=""></i><span>Decorator in babel and tsc</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>rust</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/rust/lifetime.html"><i class=""></i><span>Lifetime</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>oop</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/oop/ioc.html"><i class=""></i><span>midway 分析</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>php</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/php/为什么 PHP 不适合长时间运行.html"><i class=""></i><span>为什么 PHP 不适合长时间运行</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>blockchain</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/blockchain/crypto-conditions 简述.html"><i class=""></i><span>crypto-conditions 简述</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/blockchain/实用拜占庭容错简介.html"><i class=""></i><span>实用拜占庭容错简介</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>browser</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/browser/浏览器异步加载和同源策略.html"><i class=""></i><span>浏览器异步加载和同源策略</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>cpp</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/cpp/the-as-if-rule.html"><i class=""></i><span>The as-if rule</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>work</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/work/parsing-in-practice.html"><i class=""></i><span>Parsing in practice</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>os</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/大小端序.html"><i class=""></i><span>大小端序</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/UTF-8 编码及检查其完整性.html"><i class=""></i><span>UTF-8 编码及检查其完整性</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/魔数0x7c00.html"><i class=""></i><span>魔数 0x7c00</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/字符集和字符编码.html"><i class=""></i><span>字符集和字符编码</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>javascript</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/generator function.html"><i class=""></i><span>Generator Function</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/解析 JSON 的成本.html"><i class=""></i><span>解析 JSON 的成本</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/Javascript 内部的字符编码.html"><i class=""></i><span>Javascript 内部的字符编码</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/闭包的作用.html"><i class=""></i><span>闭包的作用</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/闭包是什么.html"><i class=""></i><span>闭包是什么</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>static-analysis</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/static-analysis/ternjs.html"><i class=""></i><span>使用 Rust 重写 ternjs</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>craft</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/craft/create_your_own_lang.html"><i class=""></i><span>制作一个属于自己的语言</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>go</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/go/bad_in_generic_syntax.html"><i class=""></i><span>Go 语言中的 Generic 设计缺陷</span></a><ul></ul></div></li></ul></div></div><div class="rWpFqfkPbEcRx8xnnjlEm line-numbers"><div><div><h1 id="v8Heapsnapshot文件解析">v8 Heapsnapshot 文件解析</h1>
<p>在 node 中可以通过 <a href="https://nodejs.org/api/v8.html#v8_v8_getheapsnapshot">v8.getHeapSnapshot</a> 来获取应用当前的堆快照信息，该调用会生成一份 <code>.heapsnapshot</code> 文件，官方并没有对该文件的内容有一个详细的解释，本文将主要对该文件内容进行解析，并演示了一个了解文件内容后可以做的有趣的事情</p>
<h2 id="v8.getHeapSnapshot">v8.getHeapSnapshot</h2>
<p>首先简单回顾下 <code>v8.getHeapSnapshot</code> 是如何使用的：</p>
<pre><code class="language-js">// test.js
const { writeHeapSnapshot } = require(&quot;v8&quot;);

class HugeObj {
  constructor() {
    this.hugeData = Buffer.alloc((1 &lt;&lt; 20) * 50, 0);
  }
}

// 注意下面的用法在实际应用中通常是 anti-pattern，
// 这里只是为了方便演示，才将对象挂到 module 上以防止被 GC 释放
module.exports.data = new HugeObj();

writeHeapSnapshot();
</code></pre>
<p>将上面的代码保存到 <code>test.js</code> 中，然后运行 <code>node test.js</code>，会生成文件名类似 <code>Heap.20210228.154141.9320.0.001.heapsnapshot</code> 的文件，该文件可以使用 <a href="https://developers.google.com/web/tools/chrome-devtools">Chrome Dev Tools</a> 进行查看</p>
<blockquote>
<p>对于上面的步骤我们也可以直接 <a href="https://musicfe.nos-jd.163yun.com/8eaba450-ff7b-4401-b307-8aa69a57c582.mp4">查看视频演示</a></p>
</blockquote>
<p>当我们将 <code>.heapsnapshot</code> 文件导入到 Chrome Dev Tools 之后，我们会看到类似下面的内容：</p>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812327984/da1e/748d/869a/8b718377c7a767895fd9d5410e601aae.png" alt=""/></p>
<p>上图表格列出了当前堆中的所有对象，其中列的含义是：</p>
<ul>
<li>
<p>Constructor，表示对象是使用该函数构造而来</p>
</li>
<li>
<p>Constructor 对应的实例的数量，在 Constructor 后面的 <code>x2</code> 中显示</p>
</li>
<li>
<p>Shallow size，对象自身大小（单位是 Byte），比如上面的 <code>HugeObj</code>，它的实例的 Shallow size 就是自身占用的内存大小，比如，对象内部为了维护属性和值的对应关系所占用的内存，并不包含持有对象的大小</p>
<p>比如 <code>hugeData</code> 属性引用的 <code>Buffer</code> 对象的大小，并不会计算在 <code>HugeObj</code> 实例的 Shallow size 中</p>
</li>
<li>
<p>Retained size，对象自身大小加上它依赖链路上的所有对象的自身大小（Shallow size）之和</p>
</li>
<li>
<p>Distance，表示从根节点（Roots）到达该对象经过的最短路径的长度</p>
</li>
</ul>
<h2 id="heapsnapshot文件">heapsnapshot 文件</h2>
<p>Chrome Dev Tools 只是 <code>.heapsnapshot</code> 文件的一种展现形式，如果我们希望最大程度利用这些信息，则需要进一步了解其文件格式</p>
<p>我们可以使用任意的文本编辑器打开该文件，可以发现文件内容其实是 JSON 格式的：</p>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812727100/e0fb/c34a/de03/6ecf5b8a52040c4de57006c4682c7ed3.png" alt=""/></p>
<p>因为目前没有具体的说明文档，后面的内容我们将结合源码来分析该文件的内容</p>
<h2 id="文件内容概览">文件内容概览</h2>
<p>在原始输出的文件内容中，可以发现 <code>snapshot</code> 字段部分是去除空白的，而 <code>nodes</code> 和 <code>edges</code> 字段的内容都是有换行分隔的，整体文件有非常多的行数</p>
<p>为了方便理解，我们可以将节点折叠，这样可以看出该文件的整体内容：</p>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812751100/a7a4/9e92/a1ef/0d8e594dc6d6672b0c84a2810d77ff68.png" alt=""/></p>
<p>随后我们在源码中，以该 <code>v8.getHeapSnapshot</code> 的 <code>binding</code> 着手，定位到该文件内容是方法 <a href="https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2027">HeapSnapshotGenerator::GenerateSnapshot</a> 的运行结果</p>
<p>并且我们知道对象在内存中的拓扑形式需要使用 <a href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">Graph 数据结构</a> 来表示，因此输出文件中有 <code>nodes</code> 和 <code>edges</code> 字段分别用于表示堆中的对象，以及对象间的连接关系：</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812905466/70a8/2f14/2e84/bf9a2eb0f2232a0637207bbb2267efe9.png" alt=""/></p>
<blockquote>
<p>图片引用自 [Graphs</p>
</blockquote>
<p>](<a href="https://guides.codepath.com/compsci/Graphs">https://guides.codepath.com/compsci/Graphs</a>)</p>
<p>不过 <code>nodes</code> 和 <code>edges</code> 中并没有直接存储对象的信息，而都是一连串数字，我们需要进一步分析其中的内容</p>
<h3 id="nodes">nodes</h3>
<p>nodes 中的每一个 Node 的序列化方法是：<a href="https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2344">HeapSnapshotJSONSerializer::SerializeNode</a></p>
<p>从源码来看，每输出完 node 的所有属性值后，会跟着输出 <code>\n\0</code>，这也是输出结果中 <code>nodes</code> 数组是一行行数字的原因。不过我们知道 <code>\n\0</code> 在 JSON 反序列化的时候因为会因为自身符合空白的定义而被忽略掉，所以这样的换行可以理解是为了方便直接查看源文件</p>
<p>我们来看一个例子，比如：</p>
<pre><code class="language-json">{
&quot;nodes&quot;:[9,1,1,0,10,0 // 第一行
,9,2,3,0,23,0         // 第二行
}
</code></pre>
<p>上面的内容，每行分别表示一个 node，每一行都是对象的属性的 <code>value</code>（我们先不用考虑为什么 value 都是数值）。而属性的 <code>name</code> 我们通过源码中输出的顺序可以整理出来：</p>
<pre><code>0. type
1. name
2. id
3. self_size
4. edge_count
5. trace_node_id
</code></pre>
<p>因为 <code>value</code> 的输出顺序和上面的 <code>name</code> 是对应的，所以我们可以根据属性 <code>name</code> 的顺序作为索引，去关联其 <code>value</code> 的值</p>
<p>不过实际上并不能省略属性名称列表的输出，因为属性的内容是可能在后续的 node 版本中变化的（主要是跟随 v8 的变化），为了和对应的数据消费端解耦，文件中会将属性 <code>name</code> 列出输出，保存在 <code>snapshot.meta.node_fields</code> 中</p>
<h3 id="FieldType">Field Type</h3>
<p>接下来我们来看为什么 nodes 数组保存的属性 value 为什么都是数值</p>
<p>还是上面的例子，因为我们已经知道了属性名称和属性值是按索引对应上的，那么对于上面第一个 node 的 <code>propertyName(propertyValue)</code> 列表可以表示为：</p>
<pre><code>0. type(9)
1. name(1)
2. id(1)
3. self_size(0)
4. edge_count(10)
5. trace_node_id(0)
</code></pre>
<p>比如第 1 号属性 <code>name</code>，它就是对象的名称，不过根据对象的类型不同，该值也会有不同的取值方式。比如对于一般对象而言，它的内容就是其构造函数的名称，对于 Regexp 对象而言，它的值就是 <code>pattern</code> 字符串，更多得可以参考 <a href="https://github.com/nodejs/node/blob/master/deps/v8/src/profiler/heap-snapshot-generator.cc#L587">V8HeapExplorer::AddEntry</a></p>
<p>假如我们直接保存属性的值，那么如果堆中有 1000 个由 <code>HugeObj</code> 构造的对象，那么 <code>HugeObj</code> 字符串就要保存 1000 个拷贝</p>
<p>因为 heapdump 顾名思义，输出大小几乎就和当前 Node 应用所占内存大小一致（并不完全一致，这里 heapdump 只包含受 GC 管理的内容），为了让输出的结果尽可能的紧凑，v8 在输出属性值的时候，按一定的规则进行了压缩，压缩的秘诀是：</p>
<ul>
<li>
<p>增加一条记录 <code>snapshot.meta.node_types</code>，来存放属性的类型，和 <code>snapshot.meta.node_fields</code> 类似，它们和属性值之间也是通过索引（顺序）关联的</p>
</li>
<li>
<p><code>nodes</code> 中只存放属性值，我们需要计算一下偏移量（下面会讲到），来确定属性的类型：</p>
<ul>
<li>如果是数值类型，那么该值就是本身的内容</li>
<li>如果是数组，则对应数组中的索引</li>
<li>如果是字符串，则对应 <code>strings</code> 数组的内容</li>
</ul>
</li>
</ul>
<p>我们可以用下面的图来表示三者之间的关系：</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7814264688/4239/09c1/ddef/d80baf4f620f2c84a358522f3d3533b3.png" alt=""/></p>
<p>我们通过一个例子来串联上面的内容。比如我们要看索引为 1000 的对象（注意区别 <code>id</code> 属性）的 <code>name</code> 属性的值，使用下面的方式：</p>
<ul>
<li>取 <code>name</code> 属性在 <code>snapshot.meta.node_fields</code> 中的索引为 <code>1</code></li>
<li>取 <code>snapshot.meta.node_fields</code> 数组的长度为 <code>6</code></li>
<li>则索引为 1000 的对象的起始索引为：<code>1000 * 6</code>（因为对象属性的数量是固定的）</li>
<li>加上 <code>name</code> 属性的偏移量 <code>1</code>，则 <code>name</code> 在 <code>nodes</code> 数组中的索引为 <code>6001 = 1000 * 6 + 1</code></li>
<li>取 <code>name</code> 属性在 <code>snapshot.meta.node_types</code> 中的类型，即 <code>snapshot.meta.node_types[1]</code>，在这个例子中是 <code>string</code></li>
<li>则 <code>strings[6001]</code> 的内容就是 <code>name</code> 属性值的最终内容</li>
</ul>
<p>其余一些字段的含义是：</p>
<ul>
<li>
<p>id，对象的 id，v8 会确保该对象在本次应用生命周期中的多次的 dump 下中保持相同的 id</p>
</li>
<li>
<p>self_size，也就是上文提到的 shallow size</p>
</li>
<li>
<p>edge_count，就是从该对象出去的边的条数，也就是子对象的数量</p>
</li>
<li>
<p>trace_node_id，可以暂时不去考虑，只有在同时使用 <code>node --track-heap-objects</code> 启动应用的情况下，该内容才不会为 <code>0</code>。它可以结合 <code>trace_tree</code> 和 <code>trace_function_infos</code> 一起知道对象是在什么调用栈下被创建的，换句话说就是知道经过一系列什么调用创了该对象。文本不会讨论这部分内容，或许会在以后的章节中展开</p>
</li>
<li>
<p>trace_tree 中的 node 属性对应 snapshot.meta.trace_node_fields</p>
</li>
<li>
<p>trace_node_id 对应 trace_tree 中的 node id 即 snapshot.meta.trace_node_fields[&#x27;id&#x27;]</p>
</li>
<li>
<p>snapshot.meta.trace_node_fields[&#x27;function_info_index&#x27;] 对应 trace_function_infos 的索引</p>
</li>
<li>
<p>trace_function_info_fields[&#x27;function_id&#x27;] 对应 nodes 中的 id 属性</p>
</li>
</ul>
<h3 id="edges">edges</h3>
<p>edges 中的 Edge 的序列化方式是：<a href="https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2311">HeapSnapshotJSONSerializer::SerializeEdge</a></p>
<p>字段内容分别是：</p>
<pre><code>0. type
1. edge_name_or_index(idx or stringId)
2. to
</code></pre>
<p>和上面的 nodes 数组类似，edges 数组也是都存的属性的值，因此在取最终值的时候，需要结合 <code>snapshot.meta.edge_fields</code> <code>snapshot.meta.edge_types</code> 来操作</p>
<p>唯一的问题在于，我们知道 Edge 表示的对象之间的关系，而且这里是有向图，那么一定有 <code>From</code> 和 <code>To</code> 两个字段，而上面的字段内容只有 <code>To</code>，那么 nodes 和 edges 是如何对应的呢？</p>
<h3 id="Node和Edge的对应关系">Node 和 Edge 的对应关系</h3>
<p>从头以 <a href="https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2027">HeapSnapshotGenerator::GenerateSnapshot</a> 方法开始分析，看看 nodes 和 edges 是如何产生的，下面是该方法中的相关主要内容：</p>
<pre><code class="language-cpp">bool HeapSnapshotGenerator::GenerateSnapshot() {
  // ...

  // 加入 Root 节点，作为活动对象的起点
  snapshot_-&gt;AddSyntheticRootEntries();

  // 即 HeapSnapshotGenerator::FillReferences 方法，nodes 和 edges
  // 都是由该方法构建的，这里的 nodes 和 edges 指的是 HeapSnapshot 的
  // 数据成员 `entries_` 和 `edges_`
  if (!FillReferences()) return false;

  // 输出文件中的 edges 实际是通过 `FillChildren` 重新组织顺序的，
  // 重新组织后的内容保存在 HeapSnapshot 的数据成员 children_ 中
  snapshot_-&gt;FillChildren();
  snapshot_-&gt;RememberLastJSObjectId();

  progress_counter_ = progress_total_;
  if (!ProgressReport(true)) return false;

  // ...
}
</code></pre>
<p>可以暂时不去深入了解 Node 和 Edge 是如何生成的，看一下 <a href="https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L252">HeapSnapshot::FillChildren</a> 方法是如何重新组织输出的 edges 内容的：</p>
<pre><code class="language-cpp">void HeapSnapshot::FillChildren() {
  // ...
  int children_index = 0;
  for (HeapEntry&amp; entry : entries()) {
    children_index = entry.set_children_index(children_index);
  }

  // ...
  children().resize(edges().size());
  for (HeapGraphEdge&amp; edge : edges()) {
    edge.from()-&gt;add_child(&amp;edge);
  }
}
</code></pre>
<p>其中 <code>entry.set_children_index</code> 和 <code>edge.from()-&gt;add_child</code> 方法内容分别是：</p>
<pre><code class="language-cpp">int HeapEntry::set_children_index(int index) {
  // Note: children_count_ and children_end_index_ are parts of a union.
  int next_index = index + children_count_;
  children_end_index_ = index;
  return next_index;
}

void HeapEntry::add_child(HeapGraphEdge* edge) {
  snapshot_-&gt;children()[children_end_index_++] = edge;
}
</code></pre>
<p>所以对于每个 entry（即 node）都有一个属性 <code>children_index</code>，它表示 entry 的 children 在 <code>children_</code> 数组中的起始索引（上面注释中已经提到，heapsnapshot 文件中的 <code>edges</code> 数组的内容就是根据 <code>children_</code> 数组输出的）</p>
<p>综合来看，<code>edges</code> 数组的内容和 <code>nodes</code> 之间的对应关系大致是：</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7814657666/5104/b17d/faf0/c7d6c6432b156c51b8ea0f9e842321cc.png" alt=""/></p>
<p>比如上面 <code>edge0</code> 的 <code>From</code> 就是 <code>nodes[0 + 2]</code>，其中：</p>
<ul>
<li><code>nodes</code> 表示 nodes 数组</li>
<li><code>0</code> 的位置表示该 node 在 <code>nodes</code> 数组中的索引，这里也就是第一个元素</li>
<li><code>2</code> 表示 <code>id</code> 属性在 <code>snapshot.meta.node_fields</code> 数组中的偏移量</li>
</ul>
<p><code>node0</code> 的 <code>edge_count</code> 可以表示成 <code>nodes[0 + 4]</code>：</p>
<ul>
<li>其中 <code>4</code> 表示 <code>edge_count</code> 属性在 <code>snapshot.meta.node_fields</code> 数组中的偏移量</li>
<li>其他部分同上</li>
</ul>
<p>所以 <code>edges</code> 数组中，从 <code>0</code> 开始的 <code>node0.edge_count</code> 个 edge 的 <code>From</code> 都是 <code>node0.id</code></p>
<p>因为 <code>node[n].edge_count</code> 是变量，所以我们无法快速根据索引定位到某个 edge 的 From，我们必须从索引 <code>0</code> 开始，然后步进 <code>node[n].edge_count</code> 次（<code>n</code> 从 <code>0</code> 开始），步进次数内的 edge 的 From 都为 <code>node[n].id</code>，步进结束后对 <code>n = n + 1</code> ，进而在下一次迭代中关联下一个 node 的 edges</p>
<h2 id="heapquery">heapquery</h2>
<p>我们开头说了解文件内容可以做一些有趣的事情，接下来我们将演示一个小程序 <a href="https://github.com/hsiaosiyuan0/heapquery-js">heapquery</a>（<a href="https://github.com/hsiaosiyuan0/heapquery">Rust 劝入版</a>），它可以将 <code>.heapsnapshot</code> 文件的内容导入到 sqlite 中，然后我们就可以通过 SQL 来查询自己感兴趣的内容了（虽然远没有 <a href="https://github.com/osquery/osquery">osquery</a> 高级，但是直接通过 SQL 来查询堆上的内容，想想都会很有趣吧）</p>
<p>除此以外，它还可以：</p>
<ul>
<li>验证上文对 heapsnapshot 文件格式的分析</li>
<li>对上文的文字描述提供一个可运行的代码的补充解释</li>
</ul>
<p>因为 heapquery 的程序内容非常简单（仅仅是解析格式并导入而已），所以就不赘述了。只简单看一下涉及的表结构，因为仅仅是演示用，到最后其实只有两张表：</p>
<p><strong>Node 表</strong></p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS node (
  id INTEGER PRIMARY KEY,   /* 对象 id  */
  name VARCHAR(50),         /* 对象所属类型名称 */
  type VARCHAR(50),         /* 对象所属类型枚举，取自 `snapshot.meta.node_types` */
  self_size INTEGER,        /* 对象自身大小 */
  edge_count INTEGER,       /* 对象持有的子对象数量 */
  trace_node_id INTEGER
);
</code></pre>
<p><strong>Edge 表</strong></p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS edge (
  from_node INTEGER,              /* 父对象 id */
  to_node INTEGER,                /* 子对象 id */
  type VARCHAR(50),               /* 关系类型，取自 `snapshot.meta.edge_types` */
  name_or_index VARCHAR(50)       /* 关系名称，属性名称或者索引 */
);
</code></pre>
<h3 id="小演练">小演练</h3>
<p>在本文开头的位置，我们定义了一个 <code>HugeObj</code> 类，在实例化该类的时候，会创建一个大小为 50M 的 <code>Buffer</code> 对象，并关联到其属性 <code>hugeData</code> 上</p>
<p>接下来我们将进行一个小演练，假设我们事先并不知道 <code>HugeObj</code>，我们如何通过可能的内存异常现象反推定位到它</p>
<p>首先我们需要将 <code>.heapsnapshot</code> 导入到 sqlite 中：</p>
<pre><code class="language-bash">npx heapquery path_to_your_heapdump.heapsnapshot
</code></pre>
<p>命令运行完成后，会在当前目录下生成 <code>path_to_your_heapdump.db</code> 文件，我们可以选择自己喜欢的 sqlite browser 打开它，比如这里使用的 <a href="https://sqlitebrowser.org/">DB Browser for SQLite</a></p>
<p>然后我们执行一条 SQL 语句，将 node 按 <code>self_size</code> 倒序排列后输出：</p>
<pre><code class="language-sql">SELECT * FROM node ORDER By self_size DESC
</code></pre>
<p>我们会得到类似下面的结果：</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821543808/d63b/015b/ef74/3146cf019e1ed0b59095bbc5a96a2660.png" alt=""/></p>
<p>我们接着从大小可疑的对象入手，当然这里就是先看截图中 <code>id</code> 为 <code>51389</code> 的这条数据了</p>
<p>接下来我们再执行一条 SQL 语句，看看是哪个对象持有了对象 <code>51389</code></p>
<pre><code class="language-sql">SELECT  from_node, B.name AS from_node_name 
  FROM edge AS A  
  JOIN  node AS B ON A.from_node = B.id 
  WHERE A.to_node = 51389
</code></pre>
<p>我们会得到类似下面的输出：</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821638826/cab4/7b69/79a7/0e314fd9da82c3baaba0cb244045cb7d.png" alt=""/></p>
<p>上面的输出中，我们知道持有 <code>51389</code> 的对象是 <code>51387</code>，并且该对象的类型是 <code>ArrayBuffer</code></p>
<p>因为 <code>ArrayBuffer</code> 是环境内置的类，我们并不能看出什么问题，因此需要利用上面的 SQL，继续查看 <code>51387</code> 是被哪个对象持有的：</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821698116/9593/f678/38e1/040be5ca537c340b85d595a2add4bc07.png" alt=""/></p>
<p>和上面的输出类似，这次的 <code>Buffer</code> 依然是内置对象，所以我们继续重复上面的步骤：</p>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821713282/c794/782d/993f/2dfe3d049aeb53e64bea45029d1b1512.png" alt=""/></p>
<p>这次我们得到了一个业务对象 <code>HugeObj</code>，我们看看它是在哪里定义的。对象的定义就是它的构造函数，因此我们需要找到它的 <code>constructor</code>，为此我们先列出对象的所有属性：</p>
<pre><code class="language-sql">SELECT * FROM edge WHERE from_node = 46141 AND `type` = &quot;property&quot;
</code></pre>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821804474/f2a8/7a1e/0fb6/2e1484cb66cc62333e1686a10bcfe864.png" alt=""/></p>
<p>接着我们在原型中继续查找：</p>
<pre><code class="language-sql">SELECT * FROM edge WHERE from_node = 4575 AND `type` = &quot;property&quot;
</code></pre>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821825537/a9bb/f4ad/513c/18a8a4f9f4f2f0762b6c051f6b3e746c.png" alt=""/></p>
<p>我们找到了 <code>constructor</code> 对象 <code>4577</code>，接着我们来找到它的 <code>shared</code> 内部属性：</p>
<pre><code class="language-sql">SELECT * FROM edge WHERE from_node = 4577 AND name_or_index = &quot;shared&quot;
</code></pre>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821872592/e072/1f71/8b93/b88001c0495153cf83691803dafc56e3.png" alt=""/></p>
<p>我们简单解释一下 <code>shared</code> 属性的作用是什么。首先，通常函数包含的信息有：</p>
<ul>
<li>定义所在的源文件位置</li>
<li>原始代码（在具有 JIT 的运行时中用于 Deoptimize）</li>
<li>一组在业务上可复用的指令（Opcode or JITed）</li>
<li>PC 寄存器信息，表示当然执行到内部哪一个指令，并在未来恢复时可以继续执行</li>
<li>BP 寄存器信息，表示当前调用栈帧在栈上的起始地址</li>
<li>函数对象创建时对应的闭包引用</li>
</ul>
<p>其中「定义所在的源文件位置」、「原始代码」、「一组在业务上可复用的指令（Opcode or JITed）」是没有必要制造出多份拷贝的，因此类似这样的内容，在 v8 中就会放到 <code>shared</code> 对象中</p>
<p>接下来我们可以输出 <code>shared</code> 对象 <code>43271</code> 的属性：</p>
<pre><code class="language-sql">SELECT * FROM edge WHERE from_node = 43271
</code></pre>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7822067402/efd4/f1dd/6457/72bd851b9cfbc9084141b6e367521ba8.png" alt=""/></p>
<p>我们继续输出 <code>script_or_debug_info</code> 属性持有的对象 <code>8463</code>：</p>
<pre><code class="language-sql">SELECT * FROM edge WHERE from_node = 8463
</code></pre>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7822092885/b0e1/733b/abac/a1a71e171f415ae8033901838bffcadf.png" alt=""/></p>
<p>最后我们输出 <code>name</code> 属性持有的对象 <code>4587</code>：</p>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7822116292/0952/c86e/eb63/24c7bbb3b6ce0e48fda52e2c6d55a80c.png" alt=""/></p>
<p>这样我们就找到了对象定义的文件，然后就可以在该文件中继续确定业务代码是否存在泄漏的可能</p>
<p>或许有人会对上面的步骤感到繁琐，其实不必担心，我们可以结合自己实际的查询需求，将常用的查询功能编写成子程序，这样以后只要给一个输入，就能帮助我们分析出想要的结果了</p>
<h2 id="小结">小结</h2>
<p>本文以分析 <code>.heapsnapshot</code> 文件的格式为切入点，结合 node 的源码，解释了 <code>.heapsnapshot</code> 文件格式和其生成的方式，并提供了个 heapquery 的小程序，演示了了解其结构可以帮助我们获得不局限于现有工具的信息。最后祝大家上分愉快！</p></div></div></div><div class="_3a4jt6lr4yLRJnQge009wv"><ul><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#v8.getHeapSnapshot">v8.getHeapSnapshot</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#heapsnapshot文件">heapsnapshot 文件</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#文件内容概览">文件内容概览</a></span></div><ul><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#nodes">nodes</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#FieldType">Field Type</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#edges">edges</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#Node和Edge的对应关系">Node 和 Edge 的对应关系</a></span></div><ul></ul></div></li></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#heapquery">heapquery</a></span></div><ul><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#小演练">小演练</a></span></div><ul></ul></div></li></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#小结">小结</a></span></div><ul></ul></div></li></ul></div><div class="_1UY_ItV2UTWKutKs5b7NKg">Made with <a target="_blank" href="https://github.com/hsiaosiyuan0/gadget">gadget</a></div></div></div><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-core.min.js" data-manual="true"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-markup.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-clike.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-json.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-javascript.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-jsx.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-typescript.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-tsx.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-bash.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-python.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-xml-doc.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-docker.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-rust.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-nasm.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-c.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-cpp.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-xml-doc.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-go.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/toolbar/prism-toolbar.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-highlight/prism-line-highlight.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/show-language/prism-show-language.min.js"></script><script src="https://cdn.jsdelivr.net/gh/cferdinandi/gumshoe@5.1.1/dist/gumshoe.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react@16.14.0/umd/react.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react-dom@16.14.0/umd/react-dom.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react@16.14.0/umd/react.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react-dom@16.14.0/umd/react-dom.production.min.js"></script><script>window["__gadget__"]={"initialProps":{"data":{"post":{"filename":"heap-snapshot","rawMeta":{"title":"v8 Heapsnapshot 文件解析"},"content":"# v8 Heapsnapshot 文件解析\n\n在 node 中可以通过 [v8.getHeapSnapshot](https://nodejs.org/api/v8.html#v8_v8_getheapsnapshot) 来获取应用当前的堆快照信息，该调用会生成一份 `.heapsnapshot` 文件，官方并没有对该文件的内容有一个详细的解释，本文将主要对该文件内容进行解析，并演示了一个了解文件内容后可以做的有趣的事情\n\n## v8.getHeapSnapshot\n\n首先简单回顾下 `v8.getHeapSnapshot` 是如何使用的：\n\n```js\n// test.js\nconst { writeHeapSnapshot } = require(\"v8\");\n\nclass HugeObj {\n  constructor() {\n    this.hugeData = Buffer.alloc((1 << 20) * 50, 0);\n  }\n}\n\n// 注意下面的用法在实际应用中通常是 anti-pattern，\n// 这里只是为了方便演示，才将对象挂到 module 上以防止被 GC 释放\nmodule.exports.data = new HugeObj();\n\nwriteHeapSnapshot();\n```\n\n将上面的代码保存到 `test.js` 中，然后运行 `node test.js`，会生成文件名类似 `Heap.20210228.154141.9320.0.001.heapsnapshot` 的文件，该文件可以使用 [Chrome Dev Tools](https://developers.google.com/web/tools/chrome-devtools) 进行查看\n\n> 对于上面的步骤我们也可以直接 [查看视频演示](https://musicfe.nos-jd.163yun.com/8eaba450-ff7b-4401-b307-8aa69a57c582.mp4)\n\n当我们将 `.heapsnapshot` 文件导入到 Chrome Dev Tools 之后，我们会看到类似下面的内容：\n\n![](https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812327984/da1e/748d/869a/8b718377c7a767895fd9d5410e601aae.png)\n\n上图表格列出了当前堆中的所有对象，其中列的含义是：\n\n- Constructor，表示对象是使用该函数构造而来\n- Constructor 对应的实例的数量，在 Constructor 后面的 `x2` 中显示\n- Shallow size，对象自身大小（单位是 Byte），比如上面的 `HugeObj`，它的实例的 Shallow size 就是自身占用的内存大小，比如，对象内部为了维护属性和值的对应关系所占用的内存，并不包含持有对象的大小\n\n  比如 `hugeData` 属性引用的 `Buffer` 对象的大小，并不会计算在 `HugeObj` 实例的 Shallow size 中\n- Retained size，对象自身大小加上它依赖链路上的所有对象的自身大小（Shallow size）之和\n- Distance，表示从根节点（Roots）到达该对象经过的最短路径的长度\n\n## heapsnapshot 文件\n\nChrome Dev Tools 只是 `.heapsnapshot` 文件的一种展现形式，如果我们希望最大程度利用这些信息，则需要进一步了解其文件格式\n\n我们可以使用任意的文本编辑器打开该文件，可以发现文件内容其实是 JSON 格式的：\n\n![](https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812727100/e0fb/c34a/de03/6ecf5b8a52040c4de57006c4682c7ed3.png)\n\n因为目前没有具体的说明文档，后面的内容我们将结合源码来分析该文件的内容\n\n## 文件内容概览\n\n在原始输出的文件内容中，可以发现 `snapshot` 字段部分是去除空白的，而 `nodes` 和 `edges` 字段的内容都是有换行分隔的，整体文件有非常多的行数\n\n为了方便理解，我们可以将节点折叠，这样可以看出该文件的整体内容：\n\n![](https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812751100/a7a4/9e92/a1ef/0d8e594dc6d6672b0c84a2810d77ff68.png)\n\n随后我们在源码中，以该 `v8.getHeapSnapshot` 的 `binding` 着手，定位到该文件内容是方法 [HeapSnapshotGenerator::GenerateSnapshot](https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2027) 的运行结果\n\n并且我们知道对象在内存中的拓扑形式需要使用 [Graph 数据结构](https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/) 来表示，因此输出文件中有 `nodes` 和 `edges` 字段分别用于表示堆中的对象，以及对象间的连接关系：\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7812905466/70a8/2f14/2e84/bf9a2eb0f2232a0637207bbb2267efe9.png)\n\n> 图片引用自 [Graphs\n](https://guides.codepath.com/compsci/Graphs)\n\n不过 `nodes` 和 `edges` 中并没有直接存储对象的信息，而都是一连串数字，我们需要进一步分析其中的内容\n\n### nodes\n\nnodes 中的每一个 Node 的序列化方法是：[HeapSnapshotJSONSerializer::SerializeNode](https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2344)\n\n从源码来看，每输出完 node 的所有属性值后，会跟着输出 `\\n\\0`，这也是输出结果中 `nodes` 数组是一行行数字的原因。不过我们知道 `\\n\\0` 在 JSON 反序列化的时候因为会因为自身符合空白的定义而被忽略掉，所以这样的换行可以理解是为了方便直接查看源文件\n\n我们来看一个例子，比如：\n\n```json\n{\n\"nodes\":[9,1,1,0,10,0 // 第一行\n,9,2,3,0,23,0         // 第二行\n}\n```\n\n上面的内容，每行分别表示一个 node，每一行都是对象的属性的 `value`（我们先不用考虑为什么 value 都是数值）。而属性的 `name` 我们通过源码中输出的顺序可以整理出来：\n\n```\n0. type\n1. name\n2. id\n3. self_size\n4. edge_count\n5. trace_node_id\n```\n因为 `value` 的输出顺序和上面的 `name` 是对应的，所以我们可以根据属性 `name` 的顺序作为索引，去关联其 `value` 的值\n\n不过实际上并不能省略属性名称列表的输出，因为属性的内容是可能在后续的 node 版本中变化的（主要是跟随 v8 的变化），为了和对应的数据消费端解耦，文件中会将属性 `name` 列出输出，保存在 `snapshot.meta.node_fields` 中\n\n### Field Type\n\n接下来我们来看为什么 nodes 数组保存的属性 value 为什么都是数值\n\n还是上面的例子，因为我们已经知道了属性名称和属性值是按索引对应上的，那么对于上面第一个 node 的 `propertyName(propertyValue)` 列表可以表示为：\n\n```\n0. type(9)\n1. name(1)\n2. id(1)\n3. self_size(0)\n4. edge_count(10)\n5. trace_node_id(0)\n```\n\n比如第 1 号属性 `name`，它就是对象的名称，不过根据对象的类型不同，该值也会有不同的取值方式。比如对于一般对象而言，它的内容就是其构造函数的名称，对于 Regexp 对象而言，它的值就是 `pattern` 字符串，更多得可以参考 [V8HeapExplorer::AddEntry](https://github.com/nodejs/node/blob/master/deps/v8/src/profiler/heap-snapshot-generator.cc#L587)\n\n假如我们直接保存属性的值，那么如果堆中有 1000 个由 `HugeObj` 构造的对象，那么 `HugeObj` 字符串就要保存 1000 个拷贝\n\n因为 heapdump 顾名思义，输出大小几乎就和当前 Node 应用所占内存大小一致（并不完全一致，这里 heapdump 只包含受 GC 管理的内容），为了让输出的结果尽可能的紧凑，v8 在输出属性值的时候，按一定的规则进行了压缩，压缩的秘诀是：\n\n- 增加一条记录 `snapshot.meta.node_types`，来存放属性的类型，和 `snapshot.meta.node_fields` 类似，它们和属性值之间也是通过索引（顺序）关联的\n\n- `nodes` 中只存放属性值，我们需要计算一下偏移量（下面会讲到），来确定属性的类型：\n  \n  - 如果是数值类型，那么该值就是本身的内容\n  - 如果是数组，则对应数组中的索引\n  - 如果是字符串，则对应 `strings` 数组的内容\n\n我们可以用下面的图来表示三者之间的关系：\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7814264688/4239/09c1/ddef/d80baf4f620f2c84a358522f3d3533b3.png)\n\n我们通过一个例子来串联上面的内容。比如我们要看索引为 1000 的对象（注意区别 `id` 属性）的 `name` 属性的值，使用下面的方式：\n\n- 取 `name` 属性在 `snapshot.meta.node_fields` 中的索引为 `1`\n- 取 `snapshot.meta.node_fields` 数组的长度为 `6`\n- 则索引为 1000 的对象的起始索引为：`1000 * 6`（因为对象属性的数量是固定的）\n- 加上 `name` 属性的偏移量 `1`，则 `name` 在 `nodes` 数组中的索引为 `6001 = 1000 * 6 + 1`\n- 取 `name` 属性在 `snapshot.meta.node_types` 中的类型，即 `snapshot.meta.node_types[1]`，在这个例子中是 `string`\n- 则 `strings[6001]` 的内容就是 `name` 属性值的最终内容\n\n其余一些字段的含义是：\n\n- id，对象的 id，v8 会确保该对象在本次应用生命周期中的多次的 dump 下中保持相同的 id\n- self_size，也就是上文提到的 shallow size\n- edge_count，就是从该对象出去的边的条数，也就是子对象的数量\n- trace_node_id，可以暂时不去考虑，只有在同时使用 `node --track-heap-objects` 启动应用的情况下，该内容才不会为 `0`。它可以结合 `trace_tree` 和 `trace_function_infos` 一起知道对象是在什么调用栈下被创建的，换句话说就是知道经过一系列什么调用创了该对象。文本不会讨论这部分内容，或许会在以后的章节中展开\n\n- trace_tree 中的 node 属性对应 snapshot.meta.trace_node_fields\n- trace_node_id 对应 trace_tree 中的 node id 即 snapshot.meta.trace_node_fields['id']\n- snapshot.meta.trace_node_fields['function_info_index'] 对应 trace_function_infos 的索引\n- trace_function_info_fields['function_id'] 对应 nodes 中的 id 属性\n\n### edges\n\nedges 中的 Edge 的序列化方式是：[HeapSnapshotJSONSerializer::SerializeEdge](https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2311)\n\n字段内容分别是：\n\n```\n0. type\n1. edge_name_or_index(idx or stringId)\n2. to\n```\n\n和上面的 nodes 数组类似，edges 数组也是都存的属性的值，因此在取最终值的时候，需要结合 `snapshot.meta.edge_fields` `snapshot.meta.edge_types` 来操作\n\n唯一的问题在于，我们知道 Edge 表示的对象之间的关系，而且这里是有向图，那么一定有 `From` 和 `To` 两个字段，而上面的字段内容只有 `To`，那么 nodes 和 edges 是如何对应的呢？\n\n### Node 和 Edge 的对应关系\n\n从头以 [HeapSnapshotGenerator::GenerateSnapshot](https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L2027) 方法开始分析，看看 nodes 和 edges 是如何产生的，下面是该方法中的相关主要内容：\n\n```cpp\nbool HeapSnapshotGenerator::GenerateSnapshot() {\n  // ...\n\n  // 加入 Root 节点，作为活动对象的起点\n  snapshot_->AddSyntheticRootEntries();\n\n  // 即 HeapSnapshotGenerator::FillReferences 方法，nodes 和 edges\n  // 都是由该方法构建的，这里的 nodes 和 edges 指的是 HeapSnapshot 的\n  // 数据成员 `entries_` 和 `edges_`\n  if (!FillReferences()) return false;\n\n  // 输出文件中的 edges 实际是通过 `FillChildren` 重新组织顺序的，\n  // 重新组织后的内容保存在 HeapSnapshot 的数据成员 children_ 中\n  snapshot_->FillChildren();\n  snapshot_->RememberLastJSObjectId();\n\n  progress_counter_ = progress_total_;\n  if (!ProgressReport(true)) return false;\n\n  // ...\n}\n```\n\n可以暂时不去深入了解 Node 和 Edge 是如何生成的，看一下 [HeapSnapshot::FillChildren](https://github.com/nodejs/node/blob/v14.x/deps/v8/src/profiler/heap-snapshot-generator.cc#L252) 方法是如何重新组织输出的 edges 内容的：\n\n```cpp\nvoid HeapSnapshot::FillChildren() {\n  // ...\n  int children_index = 0;\n  for (HeapEntry& entry : entries()) {\n    children_index = entry.set_children_index(children_index);\n  }\n\n  // ...\n  children().resize(edges().size());\n  for (HeapGraphEdge& edge : edges()) {\n    edge.from()->add_child(&edge);\n  }\n}\n```\n\n其中 `entry.set_children_index` 和 `edge.from()->add_child` 方法内容分别是：\n\n```cpp\nint HeapEntry::set_children_index(int index) {\n  // Note: children_count_ and children_end_index_ are parts of a union.\n  int next_index = index + children_count_;\n  children_end_index_ = index;\n  return next_index;\n}\n\nvoid HeapEntry::add_child(HeapGraphEdge* edge) {\n  snapshot_->children()[children_end_index_++] = edge;\n}\n```\n\n所以对于每个 entry（即 node）都有一个属性 `children_index`，它表示 entry 的 children 在 `children_` 数组中的起始索引（上面注释中已经提到，heapsnapshot 文件中的 `edges` 数组的内容就是根据 `children_` 数组输出的）\n\n综合来看，`edges` 数组的内容和 `nodes` 之间的对应关系大致是：\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7814657666/5104/b17d/faf0/c7d6c6432b156c51b8ea0f9e842321cc.png)\n\n比如上面 `edge0` 的 `From` 就是 `nodes[0 + 2]`，其中：\n\n- `nodes` 表示 nodes 数组\n- `0` 的位置表示该 node 在 `nodes` 数组中的索引，这里也就是第一个元素\n- `2` 表示 `id` 属性在 `snapshot.meta.node_fields` 数组中的偏移量\n\n`node0` 的 `edge_count` 可以表示成 `nodes[0 + 4]`：\n\n- 其中 `4` 表示 `edge_count` 属性在 `snapshot.meta.node_fields` 数组中的偏移量\n- 其他部分同上\n\n所以 `edges` 数组中，从 `0` 开始的 `node0.edge_count` 个 edge 的 `From` 都是 `node0.id`\n\n因为 `node[n].edge_count` 是变量，所以我们无法快速根据索引定位到某个 edge 的 From，我们必须从索引 `0` 开始，然后步进 `node[n].edge_count` 次（`n` 从 `0` 开始），步进次数内的 edge 的 From 都为 `node[n].id`，步进结束后对 `n = n + 1` ，进而在下一次迭代中关联下一个 node 的 edges\n\n## heapquery\n\n我们开头说了解文件内容可以做一些有趣的事情，接下来我们将演示一个小程序 [heapquery](https://github.com/hsiaosiyuan0/heapquery-js)（[Rust 劝入版](https://github.com/hsiaosiyuan0/heapquery)），它可以将 `.heapsnapshot` 文件的内容导入到 sqlite 中，然后我们就可以通过 SQL 来查询自己感兴趣的内容了（虽然远没有 [osquery](https://github.com/osquery/osquery) 高级，但是直接通过 SQL 来查询堆上的内容，想想都会很有趣吧）\n\n除此以外，它还可以：\n\n- 验证上文对 heapsnapshot 文件格式的分析\n- 对上文的文字描述提供一个可运行的代码的补充解释\n\n因为 heapquery 的程序内容非常简单（仅仅是解析格式并导入而已），所以就不赘述了。只简单看一下涉及的表结构，因为仅仅是演示用，到最后其实只有两张表：\n\n**Node 表**\n\n```sql\nCREATE TABLE IF NOT EXISTS node (\n  id INTEGER PRIMARY KEY,   /* 对象 id  */\n  name VARCHAR(50),         /* 对象所属类型名称 */\n  type VARCHAR(50),         /* 对象所属类型枚举，取自 `snapshot.meta.node_types` */\n  self_size INTEGER,        /* 对象自身大小 */\n  edge_count INTEGER,       /* 对象持有的子对象数量 */\n  trace_node_id INTEGER\n);\n```\n\n**Edge 表**\n\n```sql\nCREATE TABLE IF NOT EXISTS edge (\n  from_node INTEGER,              /* 父对象 id */\n  to_node INTEGER,                /* 子对象 id */\n  type VARCHAR(50),               /* 关系类型，取自 `snapshot.meta.edge_types` */\n  name_or_index VARCHAR(50)       /* 关系名称，属性名称或者索引 */\n);\n```\n\n### 小演练\n\n在本文开头的位置，我们定义了一个 `HugeObj` 类，在实例化该类的时候，会创建一个大小为 50M 的 `Buffer` 对象，并关联到其属性 `hugeData` 上\n\n接下来我们将进行一个小演练，假设我们事先并不知道 `HugeObj`，我们如何通过可能的内存异常现象反推定位到它\n\n首先我们需要将 `.heapsnapshot` 导入到 sqlite 中：\n\n```bash\nnpx heapquery path_to_your_heapdump.heapsnapshot\n```\n\n命令运行完成后，会在当前目录下生成 `path_to_your_heapdump.db` 文件，我们可以选择自己喜欢的 sqlite browser 打开它，比如这里使用的 [DB Browser for SQLite](https://sqlitebrowser.org/)\n\n然后我们执行一条 SQL 语句，将 node 按 `self_size` 倒序排列后输出：\n\n```sql\nSELECT * FROM node ORDER By self_size DESC\n```\n\n我们会得到类似下面的结果：\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821543808/d63b/015b/ef74/3146cf019e1ed0b59095bbc5a96a2660.png)\n\n我们接着从大小可疑的对象入手，当然这里就是先看截图中 `id` 为 `51389` 的这条数据了\n\n接下来我们再执行一条 SQL 语句，看看是哪个对象持有了对象 `51389`\n\n```sql\nSELECT  from_node, B.name AS from_node_name \n  FROM edge AS A  \n  JOIN  node AS B ON A.from_node = B.id \n  WHERE A.to_node = 51389\n```\n\n我们会得到类似下面的输出：\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821638826/cab4/7b69/79a7/0e314fd9da82c3baaba0cb244045cb7d.png)\n\n上面的输出中，我们知道持有 `51389` 的对象是 `51387`，并且该对象的类型是 `ArrayBuffer`\n\n因为 `ArrayBuffer` 是环境内置的类，我们并不能看出什么问题，因此需要利用上面的 SQL，继续查看 `51387` 是被哪个对象持有的：\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821698116/9593/f678/38e1/040be5ca537c340b85d595a2add4bc07.png)\n\n和上面的输出类似，这次的 `Buffer` 依然是内置对象，所以我们继续重复上面的步骤：\n\n![](https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821713282/c794/782d/993f/2dfe3d049aeb53e64bea45029d1b1512.png)\n\n这次我们得到了一个业务对象 `HugeObj`，我们看看它是在哪里定义的。对象的定义就是它的构造函数，因此我们需要找到它的 `constructor`，为此我们先列出对象的所有属性：\n\n```sql\nSELECT * FROM edge WHERE from_node = 46141 AND `type` = \"property\"\n```\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821804474/f2a8/7a1e/0fb6/2e1484cb66cc62333e1686a10bcfe864.png)\n\n接着我们在原型中继续查找：\n\n```sql\nSELECT * FROM edge WHERE from_node = 4575 AND `type` = \"property\"\n```\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821825537/a9bb/f4ad/513c/18a8a4f9f4f2f0762b6c051f6b3e746c.png)\n\n我们找到了 `constructor` 对象 `4577`，接着我们来找到它的 `shared` 内部属性：\n\n```sql\nSELECT * FROM edge WHERE from_node = 4577 AND name_or_index = \"shared\"\n```\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7821872592/e072/1f71/8b93/b88001c0495153cf83691803dafc56e3.png)\n\n我们简单解释一下 `shared` 属性的作用是什么。首先，通常函数包含的信息有：\n\n- 定义所在的源文件位置\n- 原始代码（在具有 JIT 的运行时中用于 Deoptimize）\n- 一组在业务上可复用的指令（Opcode or JITed）\n- PC 寄存器信息，表示当然执行到内部哪一个指令，并在未来恢复时可以继续执行\n- BP 寄存器信息，表示当前调用栈帧在栈上的起始地址\n- 函数对象创建时对应的闭包引用\n\n其中「定义所在的源文件位置」、「原始代码」、「一组在业务上可复用的指令（Opcode or JITed）」是没有必要制造出多份拷贝的，因此类似这样的内容，在 v8 中就会放到 `shared` 对象中\n\n接下来我们可以输出 `shared` 对象 `43271` 的属性：\n\n```sql\nSELECT * FROM edge WHERE from_node = 43271\n```\n\n![](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7822067402/efd4/f1dd/6457/72bd851b9cfbc9084141b6e367521ba8.png)\n\n我们继续输出 `script_or_debug_info` 属性持有的对象 `8463`：\n\n```sql\nSELECT * FROM edge WHERE from_node = 8463\n```\n\n![](https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7822092885/b0e1/733b/abac/a1a71e171f415ae8033901838bffcadf.png)\n\n最后我们输出 `name` 属性持有的对象 `4587`：\n\n![](https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/7822116292/0952/c86e/eb63/24c7bbb3b6ce0e48fda52e2c6d55a80c.png)\n\n这样我们就找到了对象定义的文件，然后就可以在该文件中继续确定业务代码是否存在泄漏的可能\n\n或许有人会对上面的步骤感到繁琐，其实不必担心，我们可以结合自己实际的查询需求，将常用的查询功能编写成子程序，这样以后只要给一个输入，就能帮助我们分析出想要的结果了\n\n## 小结\n\n本文以分析 `.heapsnapshot` 文件的格式为切入点，结合 node 的源码，解释了 `.heapsnapshot` 文件格式和其生成的方式，并提供了个 heapquery 的小程序，演示了了解其结构可以帮助我们获得不局限于现有工具的信息。最后祝大家上分愉快！\n","slug":"/nodejs/heap-snapshot","toc":[{"name":"v8.getHeapSnapshot","depth":2,"anchor":"#v8.getHeapSnapshot","children":[]},{"name":"heapsnapshot 文件","depth":2,"anchor":"#heapsnapshot文件","children":[]},{"name":"文件内容概览","depth":2,"anchor":"#文件内容概览","children":[{"name":"nodes","depth":3,"anchor":"#nodes","children":[]},{"name":"Field Type","depth":3,"anchor":"#FieldType","children":[]},{"name":"edges","depth":3,"anchor":"#edges","children":[]},{"name":"Node 和 Edge 的对应关系","depth":3,"anchor":"#Node和Edge的对应关系","children":[]}]},{"name":"heapquery","depth":2,"anchor":"#heapquery","children":[{"name":"小演练","depth":3,"anchor":"#小演练","children":[]}]},{"name":"小结","depth":2,"anchor":"#小结","children":[]}],"keywords":[],"mtime":1615455129045},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"craft","url":"/post/craft","children":[{"name":"制作一个属于自己的语言","url":"/post/craft/create_your_own_lang.html","children":[]}]},{"name":"go","url":"/post/go","children":[{"name":"Go 语言中的 Generic 设计缺陷","url":"/post/go/bad_in_generic_syntax.html","children":[]}]}],"title":"The hard ways"}},"currentRoute":{"pattern":"/post","href":{"pathname":"/post"}},"pageModules":{"/index":["/pages/index.js"],"/post":["/pages/post.css","/pages/post.js"],"/sitemap":["/pages/sitemap.css","/pages/sitemap.js"],"/post/*":["/pages/post.css","/pages/post.js"]},"router":{"basename":"/","hash":false,"routes":["/index","/post","/sitemap","/post/*"]}};</script><script crossorigin="anonymous" src="/app.js"></script><script crossorigin="anonymous" src="/foundation.js"></script><script crossorigin="anonymous" src="/lib.js"></script><script crossorigin="anonymous" src="/shared-pages_post_tsx.js"></script><script crossorigin="anonymous" src="/pages/post.js"></script></body></html>