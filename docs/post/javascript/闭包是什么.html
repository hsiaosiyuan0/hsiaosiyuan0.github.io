<!DOCTYPE html><html><head><title>闭包是什么</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1, user-scalable=no, viewport-fit=cover"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.5.0/themes/prism-vsc-dark-plus.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/toolbar/prism-toolbar.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-highlight/prism-line-highlight.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/material-icons@0.3.1/iconfont/material-icons.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/material-icons@0.3.1/css/material-icons.min.css"/><link rel="stylesheet" href="/outlet__outlets_default_tsx.css"/><link rel="stylesheet" href="/pages/post.css"/></head><body><a id="fork-me" href="https://github.com/hsiaosiyuan0/hsiaosiyuan0.github.io" style="position:fixed;top:0;right:0;border:0;width:150px;height:150px;z-index:3000"><img style="position:absolute;top:0;right:0;border:0" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"/></a><div id="__gadget__"><div><div class="" style="position:fixed;top:0;left:0;height:2px;background:transparent;z-index:99999999999;width:100%"><div style="height:100%;background:#2998ff;transition:all 500ms ease;width:0%"><div style="box-shadow:0 0 10px #2998ff, 0 0 10px #2998ff;width:5%;opacity:1;position:absolute;height:100%;transition:all 500ms ease;transform:rotate(3deg) translate(0px, -4px);left:-10rem"></div></div></div><div class="_3k0uOgdSRfNa0MZs6QS7ku"><div class="_1G63502GZaEXBXykcWz6cX">The hard ways</div><div class="_3HRY5_KLp8kngNq9437Zqi"><a href="/sitemap.html">all</a></div></div><div class="Z_a6ax5LrTSVASNRR2aN6 _11dH37BK8JkWofQgbOzM4L"><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>v8</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/v8/debug-v8-in-vscode.html"><i class=""></i><span>debug-v8-in-vscode</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/v8/common-data-types.html"><i class=""></i><span>v8 常见数据类型</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>deno</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/deno/native-plugin.html"><i class=""></i><span>deno native plugin 内部实现机制</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>crypto</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/crypto/brief-crypto.html"><i class=""></i><span>加密算法调研</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>nodejs</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/Cluster 模块分析.html"><i class=""></i><span>Cluster 模块分析</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/build-from-source.html"><i class=""></i><span>build-from-source</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/node-addon.html"><i class=""></i><span>node-addon</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/common-snippet.html"><i class=""></i><span>common-snippet</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/heap-snapshot.html"><i class=""></i><span>v8 Heapsnapshot 文件解析</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/libuv.html"><i class=""></i><span>Libuv 之 - 只看这篇是不够的</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/object-in-v8.html"><i class=""></i><span>Objects in v8</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>websocket</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/websocket/WebSocket 协议 1~4 节.html"><i class=""></i><span>WebSocket 协议 1~4 节</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/websocket/WebSocket 协议 5~10 节.html"><i class=""></i><span>WebSocket 协议 5~10 节</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>assembly</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/assembly/汇编语言学习小结.html"><i class=""></i><span>汇编语言学习小结</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>typescript</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/typescript/decorator.html"><i class=""></i><span>Decorator in babel and tsc</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>rust</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/rust/lifetime.html"><i class=""></i><span>Lifetime</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>oop</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/oop/ioc.html"><i class=""></i><span>midway 分析</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>php</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/php/为什么 PHP 不适合长时间运行.html"><i class=""></i><span>为什么 PHP 不适合长时间运行</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>blockchain</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/blockchain/crypto-conditions 简述.html"><i class=""></i><span>crypto-conditions 简述</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/blockchain/实用拜占庭容错简介.html"><i class=""></i><span>实用拜占庭容错简介</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>browser</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/browser/浏览器异步加载和同源策略.html"><i class=""></i><span>浏览器异步加载和同源策略</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>cpp</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/cpp/the-as-if-rule.html"><i class=""></i><span>The as-if rule</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>work</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/work/parsing-in-practice.html"><i class=""></i><span>Parsing in practice</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>os</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/大小端序.html"><i class=""></i><span>大小端序</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/UTF-8 编码及检查其完整性.html"><i class=""></i><span>UTF-8 编码及检查其完整性</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/魔数0x7c00.html"><i class=""></i><span>魔数 0x7c00</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/字符集和字符编码.html"><i class=""></i><span>字符集和字符编码</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>javascript</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/generator function.html"><i class=""></i><span>Generator Function</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/解析 JSON 的成本.html"><i class=""></i><span>解析 JSON 的成本</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/Javascript 内部的字符编码.html"><i class=""></i><span>Javascript 内部的字符编码</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/闭包的作用.html"><i class=""></i><span>闭包的作用</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/闭包是什么.html"><i class=""></i><span>闭包是什么</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>static-analysis</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/static-analysis/ternjs.html"><i class=""></i><span>使用 Rust 重写 ternjs</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>react</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/react/build-from-source.html"><i class=""></i><span>build-from-source</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/react/bootstrap.html"><i class=""></i><span>bootstrap</span></a><ul></ul></div></li></ul></div></div><div class="rWpFqfkPbEcRx8xnnjlEm line-numbers"><div><div><p>很多分享都会解释什么是闭包，不得不说大都管中窥豹。比如某 star 1k 的项目中描述</p>
<blockquote>
<p>所有函数都是闭包</p>
</blockquote>
<p>是不恰当的。但是在有 1k stars 的情况下，居然没有 issue 指出其中的错误。</p>
<p>首先必须说，闭包就取名和中文翻译而言，在你正在理解了它之后，会发现它恰到好处。如果你还觉得命名很奇怪，那么就说明你并不理解它。</p>
<p>就如同它的名字描述的一般，闭包表示的是一个封闭的内存空间。每个函数被创建的时候，都有一个与之关联的闭包。在了解闭包的使用场景之前，先看下面一个例子：</p>
<pre><code class="language-js">function f() {
  var i = 0;
  console.log(i);
}

f();
</code></pre>
<p>这段代码非常简单。我们知道一旦 <code>f</code> 执行完毕，那么它本次执行的栈上的数据将会被释放，所以每次调用结束后，栈上的 <code>i</code> 都会被及时的释放。</p>
<p>再来看另一个例子：</p>
<pre><code class="language-js">function f() {
  var i = 0;
  return function () { // f1
    console.log(i);
  }
}

var ff = f();
ff();
</code></pre>
<p>和第一个例子一样，这段代码同样会打印 <code>0</code>。但是这似乎打破了我们第一个例子的总结，按照第一个例子的说法，<code>f</code> 运行结束后，本次调用的栈上的 <code>i</code> 应该被释放掉了。但是我们随后调用返回的匿名函数，发现并没有报错，这就归功于闭包。</p>
<p>每个函数被创建的时候，都会有一个与之关联的闭包被同时创建。在新创建的函数内部，如果引用了外部作用域中的变量，那么这些变量都会被添加到该函数的闭包中。</p>
<p>注意上面代码的注释，为了方便描述，我们将匿名函数取名为 <code>f1</code>。当 <code>f</code> 被调用的时候，<code>f1</code> 被创建，同时与之关联的闭包也被创建。由于 <code>f1</code> 内部引用了位于其作用域之外的、<code>f</code> 作用域中的变量 <code>i</code>，因此 <code>f</code> 作用域中的 <code>i</code> 被拷贝到了 <code>f1</code> 的闭包中。这就解释了，为什么 <code>f</code> 执行完成之后，调用 <code>f1</code> 依然可以打印 <code>0</code>。</p>
<p>现在来看一下第三个例子：</p>
<pre><code class="language-js">function f() {
  var i = 0;
  function f1() { 
    console.log(i);
  }
  i = 1;
  return f1;
}

var ff = f();
ff();
</code></pre>
<p>我们会发现打印 <code>1</code>。好像又与第二个例子的结论有些冲突，<code>f</code> 中的 <code>i</code> 不是被拷贝到了 <code>f1</code> 的闭包中吗？为什么不是打印 <code>0</code> 而是打印 <code>1</code> 呢？</p>
<p>这是因为，我们还没有介绍发生拷贝的时机。如果新创建的函数，引用了外部作用域的变量，并且该变量为活动的，那么并不急于将该变量的内容拷贝到闭包中，而是将该变量所指向的内存单元的地址保存于闭包中。比如我们这里，只是先将 <code>i</code> 所绑定到的内存地址保存于闭包中，等到 <code>i</code> 为非活动状态时，才会进行拷贝。也就是这里，当 <code>f</code> 即将运行结束时，<code>i</code> 的将变为非活动状态，那么需要将其内容拷贝到引用它的闭包中，也就是这里的 <code>f1</code> 的闭包中。一旦内容被拷贝到闭包中，除了与之关联的函数对象之外，再也没有其他方式可以访问到其中的内容。</p>
<p>顺便介绍一下，那么闭包中占用的内存何时才会被释放呢？答案就是当与它关联的函数对象被释放的时候。比如我们接着上面的例子运行：</p>
<pre><code class="language-js">var ff = null
</code></pre>
<p>我们将引用 <code>f1</code> 的变量 <code>ff</code> 赋值为 <code>null</code>，这样就没有任何变量引用 <code>f1</code> 了，所以 <code>f1</code> 成为了垃圾，会在未来的某个时间点(具体要看 GC 的实现以及运行情况)，由垃圾回收器进行所占内存回收。</p>
<p>上面的例子，其实就是下面的例子的简化版：</p>
<pre><code class="language-js">function f() {
  var a = [];
  for(var i = 0; i &lt; 2; i++) {
    var ff = function () {
      console.log(i)
    };
    a.push(ff);
  }
  return a;
}

const [f1, f2] = f();
f1();
f2();
</code></pre>
<p>这里新创建的两个函数都会打印 <code>2</code>，想必这个例子大家都很熟悉了，就不再赘述了。只是有一个问题需要注意，既然上面提到了说，新创建的函数引用的外部作用域上的变量内容、最终都会拷贝到该函数的闭包中，那么上面的例子中，<code>i</code> 是不是被拷贝了两次？</p>
<p>再来看一个例子：</p>
<pre><code class="language-js">function f() {
  var a = [];
  for(var i = 0; i &lt; 2; i++) {
    var ff = function () {
      console.log(i)
    };
    a.push(ff);
  }
  a.push(function () {
    i++;
  });
  return a;
}

const [f1, f2, f3] = f();
f1();
f3();
f2();
</code></pre>
<p>这个例子会打印什么？答案是 <code>2</code> 和 <code>3</code>。这是因为闭包的另一个机制，同一个变量被引用它的多个闭包所共享。我们在 <code>for</code> 循环内部创建了两个函数，在循环外部创建了一个函数，这三个函数的都引用了 <code>f</code> 中的 <code>i</code>，因而 <code>i</code> 被这三个函数的闭包所共享，也就是说在 <code>i</code> 离开自己所属的作用域时(<code>f</code> 退出前)，将只会发生一次拷贝，并将新创建的三个函数的闭包中的 <code>i</code> 的对应的指针设定为那一份拷贝的内存地址即可。对于这一个共享的拷贝地址，除了这三个闭包之外，没有其他方式可以访问到它。</p>
<p>必须再次强调的是，被引用的变量拷贝到闭包中的时机发生在、被引用的变量离开自己所属的作用域时，即状态为非活动时。考虑下面的例子：</p>
<pre><code class="language-js">function f() {
  const a = [];
  for(let i = 0; i &lt; 2; i++) {
    var ff = function () {
      console.log(i)
    };
    a.push(ff);
  }
  return a;
}

const [f1, f2] = f();
f1();
f2();
</code></pre>
<p>我们知道 ES6 中引入了 <code>let</code> 关键字，由它声明的变量所属块级作用域。在上面的例子中，我们在 <code>for</code> 循环体的初始化部分使用了 <code>let</code>，这样一来 <code>i</code> 的作用域被设定为了该循环的块级作用域内。不过另一个细节是，循环体中的 <code>i</code> ，也就是 <code>ff</code> 中引用的 <code>i</code>，在每次迭代中都会进行重新绑定，换句话说循环体中的 <code>i</code> 的作用域是每一次的迭代。因此在循环体中，当每次迭代的 <code>i</code> 离开作用域时，它的状态变为非活动的，因此它的内容被拷贝到引用它的闭包中。</p>
<p>闭包常常会和 <a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE">IIFE</a> 一起使用，比如：</p>
<pre><code class="language-js">var a = [];
for(var i = 0; i &lt; 2; i++) {
  a.push((function (i) { // f1, i1
    return function () { // f2
      console.log(i) // i2
    }
  })(i)); // i3
};

const [f1, f2] = a;
f1();
f2();
</code></pre>
<p>在上面的例子中，让人迷惑的除了闭包的部分之外，就是 <code>i1</code>，<code>i2</code> 和 <code>i3</code> 了。</p>
<ul>
<li><code>i1</code> 是 <code>f1</code> 的形参</li>
<li><code>i2</code> 是 <code>f2</code> 中对外层作用域中的变量的引用</li>
<li><code>i3</code> 是全局的变量 <code>i</code>，IIFE 执行时 <code>i</code> 对应的值将被作为实参来调用 <code>f1</code></li>
<li>当 <code>f1</code> 被调用时，也就是 IIFE 执行阶段，它内部创建了一个新的函数 <code>f2</code>，同时也创建了 <code>f2</code> 对应的闭包</li>
<li>由于 <code>f2</code> 中引用了外层作用域中的 <code>i</code>，即 <code>f1</code> 执行期间的 <code>i</code>，且 <code>i</code> 为活动内容，所以 <code>f2</code> 的闭包中添加一条 Key 为 <code>i</code>，Value 为指向 <code>f1</code> 中活动的 <code>i</code> 绑定到的内存单元的地址</li>
<li>当 IIFE 执行完毕，即 <code>f1</code> 要退出的时候，其栈上活动对象 <code>i</code> 就会离开作用域，因此需要将 <code>i</code> 拷贝到引用它的闭包中。</li>
</ul>
<p>到目前为止，我们看到的例子都引用的直接外层作用域中的变量，那么我们再来看一个例子：</p>
<pre><code class="language-js">function f(x) { // f1
  return function (y) { // f2
    return function (z) { // f3
      console.log(x + y + z)
    }
  }
}

const xy = f(1);
const xyz = xy(2);
xyz(3);
</code></pre>
<p>为了方便描述，我们分别标记了 <code>f1</code>，<code>f2</code>，<code>f3</code>。我们在 <code>f3</code> 内部，引用了 <code>x</code> 和 <code>y</code>，并且 <code>x</code> 并不是 <code>f3</code> 的直接外部作用域。那么这个闭包的构建过程时怎样的？</p>
<p>在 JS 中，函数也是以对象的形式存在的，如果将与函数关联的闭包想象成函数对象的一个类型为 Map&lt;string, Value&gt; 的属性也不过份，比如：</p>
<pre><code class="language-ts">const CLOSURE = Symbol(&#x27;closure&#x27;);
const FUN_BODY = Symbol(&#x27;fun-body&#x27;);
const FUN_PARAMS = Symbol(&#x27;fun-params&#x27;);

const funObj = {
  [FUN_PARAMS]: [/* parameters list */],
  [FUN_BODY]: [/* instructions */],
  [CLOSURE]: new Map&lt;string, Value&gt;(), // Value 可以被多个 closure 共享
}
</code></pre>
<p>即使在引擎的实现阶段，因为性能或者实现差异不采用这样的设计，但本质上与这个结构含义是一致的。为了能在运行阶段创建函数对象，在编译阶段就需要收集到必要的信息：</p>
<ul>
<li>形参列表</li>
<li>函数体</li>
<li>引用的外部变量</li>
</ul>
<p>比如在编译 <code>f3</code> 的阶段，我们发现它内部引用了外部的 <code>x</code> 和 <code>y</code>，由于 <code>x</code> 不是直接存在于父及作用域 <code>f2</code> 中的，为了使得未来使用 <code>f2</code> 创建 <code>f3</code> 的时候，仍能够找到 <code>x</code> 的绑定，我们需要将 <code>x</code> 加入到 <code>f2</code> 的闭包中。所以在编译阶段，我们会在 <code>f2</code> 的信息中标注它内部引用了外部变量 <code>x</code>。这样在创建 <code>f2</code> 的时候，<code>x</code> 就会被拷贝到它的闭包中了，等到使用它再创建 <code>f3</code> 的时候，<code>f3</code> 中的 <code>x</code> 也就有了着落。</p>
<p>最后来一个拓展练习：</p>
<pre><code class="language-js">function f(x) { 
  return [
    function () { x++ }, 
    function (y) { 
      return function (z) { 
        console.log(x + y + z)
      }
    }
  ]
}

const [f1, xy] = f(1);
const xyz = xy(2);
f1();
xyz(3);
</code></pre>
<p>如果想要了解跟多引擎层面实现闭包的细节，可以参考我的另外的项目，<a href="https://github.com/hsiaosiyuan0/naive">Naive - 使用 Rust 编写的 JS 引擎</a></p></div></div></div><div class="_3a4jt6lr4yLRJnQge009wv"><ul></ul></div><div class="_1UY_ItV2UTWKutKs5b7NKg">Made with <a target="_blank" href="https://github.com/hsiaosiyuan0/gadget">gadget</a></div></div></div><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-core.min.js" data-manual="true"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-markup.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-clike.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-json.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-javascript.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-jsx.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-typescript.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-tsx.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-bash.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-python.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-xml-doc.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-docker.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-rust.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-nasm.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-c.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-cpp.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-xml-doc.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/toolbar/prism-toolbar.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-highlight/prism-line-highlight.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/show-language/prism-show-language.min.js"></script><script src="https://cdn.jsdelivr.net/gh/cferdinandi/gumshoe@5.1.1/dist/gumshoe.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react@16.14.0/umd/react.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react-dom@16.14.0/umd/react-dom.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react@16.14.0/umd/react.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react-dom@16.14.0/umd/react-dom.production.min.js"></script><script>window["__gadget__"]={"initialProps":{"data":{"post":{"filename":"闭包是什么","rawMeta":{"title":"闭包是什么"},"content":"很多分享都会解释什么是闭包，不得不说大都管中窥豹。比如某 star 1k 的项目中描述\n\n> 所有函数都是闭包\n\n是不恰当的。但是在有 1k stars 的情况下，居然没有 issue 指出其中的错误。\n\n首先必须说，闭包就取名和中文翻译而言，在你正在理解了它之后，会发现它恰到好处。如果你还觉得命名很奇怪，那么就说明你并不理解它。\n\n就如同它的名字描述的一般，闭包表示的是一个封闭的内存空间。每个函数被创建的时候，都有一个与之关联的闭包。在了解闭包的使用场景之前，先看下面一个例子：\n\n```js\nfunction f() {\n  var i = 0;\n  console.log(i);\n}\n\nf();\n```\n\n这段代码非常简单。我们知道一旦 `f` 执行完毕，那么它本次执行的栈上的数据将会被释放，所以每次调用结束后，栈上的 `i` 都会被及时的释放。\n\n再来看另一个例子：\n\n```js\nfunction f() {\n  var i = 0;\n  return function () { // f1\n    console.log(i);\n  }\n}\n\nvar ff = f();\nff();\n```\n\n和第一个例子一样，这段代码同样会打印 `0`。但是这似乎打破了我们第一个例子的总结，按照第一个例子的说法，`f` 运行结束后，本次调用的栈上的 `i` 应该被释放掉了。但是我们随后调用返回的匿名函数，发现并没有报错，这就归功于闭包。\n\n每个函数被创建的时候，都会有一个与之关联的闭包被同时创建。在新创建的函数内部，如果引用了外部作用域中的变量，那么这些变量都会被添加到该函数的闭包中。\n\n注意上面代码的注释，为了方便描述，我们将匿名函数取名为 `f1`。当 `f` 被调用的时候，`f1` 被创建，同时与之关联的闭包也被创建。由于 `f1` 内部引用了位于其作用域之外的、`f` 作用域中的变量 `i`，因此 `f` 作用域中的 `i` 被拷贝到了 `f1` 的闭包中。这就解释了，为什么 `f` 执行完成之后，调用 `f1` 依然可以打印 `0`。\n\n现在来看一下第三个例子：\n\n```js\nfunction f() {\n  var i = 0;\n  function f1() { \n    console.log(i);\n  }\n  i = 1;\n  return f1;\n}\n\nvar ff = f();\nff();\n```\n\n我们会发现打印 `1`。好像又与第二个例子的结论有些冲突，`f` 中的 `i` 不是被拷贝到了 `f1` 的闭包中吗？为什么不是打印 `0` 而是打印 `1` 呢？\n\n这是因为，我们还没有介绍发生拷贝的时机。如果新创建的函数，引用了外部作用域的变量，并且该变量为活动的，那么并不急于将该变量的内容拷贝到闭包中，而是将该变量所指向的内存单元的地址保存于闭包中。比如我们这里，只是先将 `i` 所绑定到的内存地址保存于闭包中，等到 `i` 为非活动状态时，才会进行拷贝。也就是这里，当 `f` 即将运行结束时，`i` 的将变为非活动状态，那么需要将其内容拷贝到引用它的闭包中，也就是这里的 `f1` 的闭包中。一旦内容被拷贝到闭包中，除了与之关联的函数对象之外，再也没有其他方式可以访问到其中的内容。\n\n顺便介绍一下，那么闭包中占用的内存何时才会被释放呢？答案就是当与它关联的函数对象被释放的时候。比如我们接着上面的例子运行：\n\n```js\nvar ff = null\n```\n\n我们将引用 `f1` 的变量 `ff` 赋值为 `null`，这样就没有任何变量引用 `f1` 了，所以 `f1` 成为了垃圾，会在未来的某个时间点(具体要看 GC 的实现以及运行情况)，由垃圾回收器进行所占内存回收。\n\n上面的例子，其实就是下面的例子的简化版：\n\n```js\nfunction f() {\n  var a = [];\n  for(var i = 0; i < 2; i++) {\n    var ff = function () {\n      console.log(i)\n    };\n    a.push(ff);\n  }\n  return a;\n}\n\nconst [f1, f2] = f();\nf1();\nf2();\n```\n\n这里新创建的两个函数都会打印 `2`，想必这个例子大家都很熟悉了，就不再赘述了。只是有一个问题需要注意，既然上面提到了说，新创建的函数引用的外部作用域上的变量内容、最终都会拷贝到该函数的闭包中，那么上面的例子中，`i` 是不是被拷贝了两次？\n\n再来看一个例子：\n\n```js\nfunction f() {\n  var a = [];\n  for(var i = 0; i < 2; i++) {\n    var ff = function () {\n      console.log(i)\n    };\n    a.push(ff);\n  }\n  a.push(function () {\n    i++;\n  });\n  return a;\n}\n\nconst [f1, f2, f3] = f();\nf1();\nf3();\nf2();\n```\n\n这个例子会打印什么？答案是 `2` 和 `3`。这是因为闭包的另一个机制，同一个变量被引用它的多个闭包所共享。我们在 `for` 循环内部创建了两个函数，在循环外部创建了一个函数，这三个函数的都引用了 `f` 中的 `i`，因而 `i` 被这三个函数的闭包所共享，也就是说在 `i` 离开自己所属的作用域时(`f` 退出前)，将只会发生一次拷贝，并将新创建的三个函数的闭包中的 `i` 的对应的指针设定为那一份拷贝的内存地址即可。对于这一个共享的拷贝地址，除了这三个闭包之外，没有其他方式可以访问到它。\n\n必须再次强调的是，被引用的变量拷贝到闭包中的时机发生在、被引用的变量离开自己所属的作用域时，即状态为非活动时。考虑下面的例子：\n\n```js\nfunction f() {\n  const a = [];\n  for(let i = 0; i < 2; i++) {\n    var ff = function () {\n      console.log(i)\n    };\n    a.push(ff);\n  }\n  return a;\n}\n\nconst [f1, f2] = f();\nf1();\nf2();\n```\n\n我们知道 ES6 中引入了 `let` 关键字，由它声明的变量所属块级作用域。在上面的例子中，我们在 `for` 循环体的初始化部分使用了 `let`，这样一来 `i` 的作用域被设定为了该循环的块级作用域内。不过另一个细节是，循环体中的 `i` ，也就是 `ff` 中引用的 `i`，在每次迭代中都会进行重新绑定，换句话说循环体中的 `i` 的作用域是每一次的迭代。因此在循环体中，当每次迭代的 `i` 离开作用域时，它的状态变为非活动的，因此它的内容被拷贝到引用它的闭包中。\n\n闭包常常会和 [IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE) 一起使用，比如：\n\n```js\nvar a = [];\nfor(var i = 0; i < 2; i++) {\n  a.push((function (i) { // f1, i1\n    return function () { // f2\n      console.log(i) // i2\n    }\n  })(i)); // i3\n};\n\nconst [f1, f2] = a;\nf1();\nf2();\n```\n\n在上面的例子中，让人迷惑的除了闭包的部分之外，就是 `i1`，`i2` 和 `i3` 了。\n\n* `i1` 是 `f1` 的形参\n* `i2` 是 `f2` 中对外层作用域中的变量的引用\n* `i3` 是全局的变量 `i`，IIFE 执行时 `i` 对应的值将被作为实参来调用 `f1`\n* 当 `f1` 被调用时，也就是 IIFE 执行阶段，它内部创建了一个新的函数 `f2`，同时也创建了 `f2` 对应的闭包\n* 由于 `f2` 中引用了外层作用域中的 `i`，即 `f1` 执行期间的 `i`，且 `i` 为活动内容，所以 `f2` 的闭包中添加一条 Key 为 `i`，Value 为指向 `f1` 中活动的 `i` 绑定到的内存单元的地址\n* 当 IIFE 执行完毕，即 `f1` 要退出的时候，其栈上活动对象 `i` 就会离开作用域，因此需要将 `i` 拷贝到引用它的闭包中。\n\n到目前为止，我们看到的例子都引用的直接外层作用域中的变量，那么我们再来看一个例子：\n\n```js\nfunction f(x) { // f1\n  return function (y) { // f2\n    return function (z) { // f3\n      console.log(x + y + z)\n    }\n  }\n}\n\nconst xy = f(1);\nconst xyz = xy(2);\nxyz(3);\n```\n\n为了方便描述，我们分别标记了 `f1`，`f2`，`f3`。我们在 `f3` 内部，引用了 `x` 和 `y`，并且 `x` 并不是 `f3` 的直接外部作用域。那么这个闭包的构建过程时怎样的？\n\n在 JS 中，函数也是以对象的形式存在的，如果将与函数关联的闭包想象成函数对象的一个类型为 Map<string, Value> 的属性也不过份，比如：\n\n```ts\nconst CLOSURE = Symbol('closure');\nconst FUN_BODY = Symbol('fun-body');\nconst FUN_PARAMS = Symbol('fun-params');\n\nconst funObj = {\n  [FUN_PARAMS]: [/* parameters list */],\n  [FUN_BODY]: [/* instructions */],\n  [CLOSURE]: new Map<string, Value>(), // Value 可以被多个 closure 共享\n}\n```\n\n即使在引擎的实现阶段，因为性能或者实现差异不采用这样的设计，但本质上与这个结构含义是一致的。为了能在运行阶段创建函数对象，在编译阶段就需要收集到必要的信息：\n\n* 形参列表\n* 函数体\n* 引用的外部变量\n\n比如在编译 `f3` 的阶段，我们发现它内部引用了外部的 `x` 和 `y`，由于 `x` 不是直接存在于父及作用域 `f2` 中的，为了使得未来使用 `f2` 创建 `f3` 的时候，仍能够找到 `x` 的绑定，我们需要将 `x` 加入到 `f2` 的闭包中。所以在编译阶段，我们会在 `f2` 的信息中标注它内部引用了外部变量 `x`。这样在创建 `f2` 的时候，`x` 就会被拷贝到它的闭包中了，等到使用它再创建 `f3` 的时候，`f3` 中的 `x` 也就有了着落。\n\n最后来一个拓展练习：\n\n```js\nfunction f(x) { \n  return [\n    function () { x++ }, \n    function (y) { \n      return function (z) { \n        console.log(x + y + z)\n      }\n    }\n  ]\n}\n\nconst [f1, xy] = f(1);\nconst xyz = xy(2);\nf1();\nxyz(3);\n```\n\n如果想要了解跟多引擎层面实现闭包的细节，可以参考我的另外的项目，[Naive - 使用 Rust 编写的 JS 引擎](https://github.com/hsiaosiyuan0/naive)","slug":"/javascript/闭包是什么","toc":[],"keywords":[],"mtime":1615393171084},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in v8","url":"/post/nodejs/object-in-v8.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"react","url":"/post/react","children":[{"name":"build-from-source","url":"/post/react/build-from-source.html","children":[]},{"name":"bootstrap","url":"/post/react/bootstrap.html","children":[]}]}],"title":"The hard ways"}},"currentRoute":{"pattern":"/post","href":{"pathname":"/post"}},"pageModules":{"/index":["/pages/index.js"],"/post":["/pages/post.css","/pages/post.js"],"/sitemap":["/pages/sitemap.css","/pages/sitemap.js"],"/post/*":["/pages/post.css","/pages/post.js"]},"router":{"basename":"/","hash":false,"routes":["/index","/post","/sitemap","/post/*"]}};</script><script crossorigin="anonymous" src="/app.js"></script><script crossorigin="anonymous" src="/foundation.js"></script><script crossorigin="anonymous" src="/lib.js"></script><script crossorigin="anonymous" src="/shared-pages_post_tsx.js"></script><script crossorigin="anonymous" src="/pages/post.js"></script></body></html>