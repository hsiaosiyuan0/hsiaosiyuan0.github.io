<!DOCTYPE html><html><head><title>浏览器异步加载和同源策略</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1, user-scalable=no, viewport-fit=cover"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.5.0/themes/prism-vsc-dark-plus.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/toolbar/prism-toolbar.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-highlight/prism-line-highlight.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/material-icons@0.3.1/iconfont/material-icons.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/material-icons@0.3.1/css/material-icons.min.css"/><link rel="stylesheet" href="/outlet__outlets_default_tsx.css"/><link rel="stylesheet" href="/shared-outlets_index_scss.css"/><link rel="stylesheet" href="/pages/post.css"/></head><body><div id="__gadget__"><div><div class="" style="position:fixed;top:0;left:0;height:2px;background:transparent;z-index:99999999999;width:100%"><div style="height:100%;background:#2998ff;transition:all 500ms ease;width:0%"><div style="box-shadow:0 0 10px #2998ff, 0 0 10px #2998ff;width:5%;opacity:1;position:absolute;height:100%;transition:all 500ms ease;transform:rotate(3deg) translate(0px, -4px);left:-10rem"></div></div></div><div class="_3k0uOgdSRfNa0MZs6QS7ku"><div class="_1G63502GZaEXBXykcWz6cX">The hard ways</div><div class="_3HRY5_KLp8kngNq9437Zqi"><a href="/sitemap.html">all</a></div></div><div class="Z_a6ax5LrTSVASNRR2aN6 _11dH37BK8JkWofQgbOzM4L"><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>v8</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/v8/debug-v8-in-vscode.html"><i class=""></i><span>debug-v8-in-vscode</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/v8/common-data-types.html"><i class=""></i><span>v8 常见数据类型</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>deno</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/deno/native-plugin.html"><i class=""></i><span>deno native plugin 内部实现机制</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>crypto</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/crypto/brief-crypto.html"><i class=""></i><span>加密算法调研</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>nodejs</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/Cluster 模块分析.html"><i class=""></i><span>Cluster 模块分析</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/build-from-source.html"><i class=""></i><span>build-from-source</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/node-addon.html"><i class=""></i><span>node-addon</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/common-snippet.html"><i class=""></i><span>common-snippet</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/heap-snapshot.html"><i class=""></i><span>v8 Heapsnapshot 文件解析</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/libuv.html"><i class=""></i><span>Libuv 之 - 只看这篇是不够的</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/object-in-v8.html"><i class=""></i><span>Objects in V8</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/nodejs/node-on-libuv.html"><i class=""></i><span>Libuv 之上的 Node</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>websocket</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/websocket/WebSocket 协议 1~4 节.html"><i class=""></i><span>WebSocket 协议 1~4 节</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/websocket/WebSocket 协议 5~10 节.html"><i class=""></i><span>WebSocket 协议 5~10 节</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>assembly</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/assembly/汇编语言学习小结.html"><i class=""></i><span>汇编语言学习小结</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>typescript</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/typescript/decorator.html"><i class=""></i><span>Decorator in babel and tsc</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>rust</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/rust/lifetime.html"><i class=""></i><span>Lifetime</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>oop</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/oop/ioc.html"><i class=""></i><span>midway 分析</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>php</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/php/为什么 PHP 不适合长时间运行.html"><i class=""></i><span>为什么 PHP 不适合长时间运行</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>blockchain</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/blockchain/crypto-conditions 简述.html"><i class=""></i><span>crypto-conditions 简述</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/blockchain/实用拜占庭容错简介.html"><i class=""></i><span>实用拜占庭容错简介</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>browser</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/browser/浏览器异步加载和同源策略.html"><i class=""></i><span>浏览器异步加载和同源策略</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>cpp</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/cpp/the-as-if-rule.html"><i class=""></i><span>The as-if rule</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>work</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/work/parsing-in-practice.html"><i class=""></i><span>Parsing in practice</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>os</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/大小端序.html"><i class=""></i><span>大小端序</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/UTF-8 编码及检查其完整性.html"><i class=""></i><span>UTF-8 编码及检查其完整性</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/魔数0x7c00.html"><i class=""></i><span>魔数 0x7c00</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/os/字符集和字符编码.html"><i class=""></i><span>字符集和字符编码</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>javascript</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/generator function.html"><i class=""></i><span>Generator Function</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/解析 JSON 的成本.html"><i class=""></i><span>解析 JSON 的成本</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/Javascript 内部的字符编码.html"><i class=""></i><span>Javascript 内部的字符编码</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/闭包的作用.html"><i class=""></i><span>闭包的作用</span></a><ul></ul></div></li><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/javascript/闭包是什么.html"><i class=""></i><span>闭包是什么</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>static-analysis</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/static-analysis/ternjs.html"><i class=""></i><span>使用 Rust 重写 ternjs</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>craft</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/craft/create_your_own_lang.html"><i class=""></i><span>制作一个属于自己的语言</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>go</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/go/bad_in_generic_syntax.html"><i class=""></i><span>Go 语言中的 Generic 设计缺陷</span></a><ul></ul></div></li></ul></div><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><div class="_15sI_H5F3ci3xYIfWDB4vZ"><i class="mi mi-arrow-drop-down"></i><span>daily</span></div><ul><li><div class="_3quX88R9lR5BSdfAKHIoaF _1lO9qEBu6kafjPHlc111Kf"><a class="_15sI_H5F3ci3xYIfWDB4vZ" style="padding-left:15px" href="/post/daily/初唐四杰.html"><i class=""></i><span>初唐四杰</span></a><ul></ul></div></li></ul></div></div><div class="rWpFqfkPbEcRx8xnnjlEm line-numbers"><div><div><h2 id="静态页面">静态页面</h2>
<p>在浏览器脚本的概念没有出现之前，所有的网页都是静态的。我们知道浏览器的工作模式是：</p>
<ol>
<li>浏览器向网站服务器发起请求</li>
<li>网站接受浏览器的请求，返回一些字符串（比如一些组成页面的 HTML 字符串）</li>
<li>浏览器接收到网站返回的用于组成页面的字符串后，就可以关闭连接了</li>
<li>浏览器将组成页面的字符串渲染到屏幕上，使得用户可以看到一个可视化的结果</li>
</ol>
<p>看起来就像下面这样：</p>
<pre><code>                                                                                  
                                       Client Request                              
              +-------------+                                     +--------+       
+------+      |  User Agent | +--------------------------------&gt;  |        |       
| User +------&gt;             |                                     | Server |       
+--^---+      |  (Browser)  | &lt;--------------------------------+  |        |       
   |          +-------+-----+                                     +--------+       
   |                  |                Server Response                             
   |                  |                                                            
   |                  |                                                            
   |        +---------v--------+                                                   
   |        | Close Connection |                                                   
   |        +---------+--------+                                                   
   |                  |                                                            
   |                  |                                                            
   |         +--------v--------+                                                   
   ^---------+ Render response |                                                   
             +-----------------+                                                   
</code></pre>
<p>我们看到，一旦用户代理（浏览器）关闭了和服务器之间的链接之后，客户端和服务器之间将不能继续通信。</p>
<h2 id="动态页面">动态页面</h2>
<p>为了让页面可以给用户带来更多的交互，浏览器开发厂商们制造出了名为浏览器脚本的东西。比如你在浏览一个页面的时候，你觉得页面的字体太小了。在静态页面的时候，页面制作者在右上角给你提供了名为 “放大字体” 的按钮，你点击那个按钮，然后开启一轮新的请求，显著的说就是说你感觉到浏览器刷新了。这其实是浏览器重新从服务器加载页面的资源，只不过这一次的资源是用于显示字体放大后的页面。(尽管这个例子现在看来有些奇怪，因为如果仅仅是改变页面字体大小的话，似乎直接操作 <code>element.style.fontSize</code> 就可以了，不过请求另外一个包含更大字体的内联 CSS 页面在最终效果上也是说得通的，所以这里还请多多包含了。)</p>
<p>浏览器脚本就是一小段由浏览器执行的代码，页面制作者将这一小段代码，和网页面的内容（比如一篇优美的散文，和它右上角的 “放大字体” 按钮）一起返回给浏览器。浏览器接收到页面资源后，首先就是先将散文和 “放大字体” 按钮显示出来。注意到返回的内容实际上还有一段由浏览器执行的代码，页面制作者在这段带代码中告诉浏览器：如果用户点击了 “放大字体” 按钮，那么你就将页面的字体放大。于是，当你点击 “放大字体” 按钮之后，浏览器严格执行页面制作者在脚本中撰写的内容 - 将页面的字体放大。</p>
<h2 id="异步加载">异步加载</h2>
<p>注意在静态页面中浏览器和服务器之间的通信过程。浏览器在向服务器发起了对页面的请求之后，在服务器没有将页面的内容返回之前，页面是无法被显示出来的，最显著的特征就是我们在点击了浏览器的 “刷新” 按钮之后，页面会 “白屏” 一小段时间。</p>
<p>起初浏览器脚本是没有网络通信的功能的，只能做一些页面的特效，比如“点击按钮放大了字体”。不过浏览器厂商发现，如果给脚本赋予网络通信的功能，将使得页面制作者可以给用户提供更好的页面交互体验。于是在早期的 IE 浏览器中，首先赋予了浏览器脚本的通信功能。</p>
<p>浏览器脚本可以和服务器进行网络通信之后，页面制作者可以做出具有更好体验的页面。比如你现在需要搜索商品，假设是要买一本编程的书，你在网页的搜索框中输入了 “编程的数”，很明显是输错了，你将 “书” 错输成了 “数”。在你点击了 “搜索” 按钮之后，进过短暂的白屏之后，页面中显示了：</p>
<blockquote>
<p>找不到关于 “编程的数” 的产品，你是不是要找 “编程的书”</p>
</blockquote>
<p>很不错，网站给了我们一个提示，这样我们就可以发现自己的输入错误。不过这个体验还是有待提高的，因为每一次的搜索都会有一个短暂的 “白屏”，在白屏期间用户只能等待。在浏览器脚本可以通信之后，搜索就可以以一个异步的方式进行：</p>
<ol>
<li>用户在浏览器中输入搜索页面的地址 “<a href="http://search.shop.com%E2%80%9D">http://search.shop.com”</a></li>
<li>浏览器会向网站请求搜索页面的内容，用于显示这个页面</li>
<li>网站在返回页面的显示内容的同时，包含了一小段脚本，脚本的内容是告诉浏览器 “用户在点击了搜索之后，你给用户一个提示，让用户知道服务器正在紧张的搜索用户所需的资源，然后你显示了提示后，你再向服务器请求搜索的结果，当得到搜索结果后，你再把搜索结果显示给用户”</li>
</ol>
<p>这样的话，用户不必在搜索时面对页面的刷新时的 “白屏” 了，有一个提示框告诉用户稍等片刻。</p>
<h2 id="同源策略">同源策略</h2>
<p>为了定位网络上的资源，我们采用了统一资源定位符 URL，就像是一个门牌号一样， URL 标识出资源在网络上的位置。我们浏览的网页，其中的内容可能会来自不同的提供者，比如散文来自一位作家，而其中的配图来自一位美术家。散文的 URL 是 <code>http://writer.com/new-world</code>，配图的 URL 是 <code>http://artist.com/new-world</code>。</p>
<p>我们需要有一种方式将网络上的资源（比如散文和图画）标识出来，区别它们是来自于不同的作者。如果我们将颗粒度定位到每一个独立的资源，理论上是可行的，但是我们知道作家不可能只有一篇散文，而美术家也不会只有一幅画。于是我们选择了使用：通信协议，完整的域名，以及端口号去描述一个源，只有三者都相同，才标识两个资源是同源的。</p>
<p>下面的几个资源是同源的：</p>
<pre><code>http://example.com/ 
http://example.com:80/ 
http://example.com/path/file
</code></pre>
<p>下面的资源是不同源的：</p>
<pre><code>http://example.com/ 
http://example.com:8080/ 
http://www.example.com/ 
https://example.com:80/ 
https://example.com/ 
http://example.org/ 
http://ietf.org/
</code></pre>
<p>现在知道了同源，那么同源策略是什么意思呢？同源策略就是，两个不同源的资源相互是不能访问对方的资源的。同源策略主要就是限制脚本的网络访问。</p>
<p>比如我们打开了一个页面 <code>http://example.com</code>，这个页面有两段脚本，一个段使用的内联的方式称为 A，它主要就是在用户点击了按钮之后显示一段文字，告诉用户点击了按钮；另一段作为外部资源进行加载称为 B，B 是 A 的基础代码，比如 B 是 jQuery，它被放在了 <code>http://cdn.jquery.com</code> 上。首先我们知道，这两段代码如果按照同源的定义，肯定是不同源的。也就是说我们在 <code>http://example.com</code> 的页面上是不能加载 <code>http://cdn.jquery.com</code> 上的资源的。</p>
<p>好像与现实情况有点矛盾。之所以现在可以，是因为浏览器为了适应实际的生产情况，放宽了对同源策略的检查，因为我们知道，不可能将所有的资源都放在同一台机器上。那么在页面完全加载好之后，页面中的脚本（内联的和外部引入）的都被浏览器归纳到了和当前页面相同的源，都属于 <code>http://example.com</code> 了。这么做的意思就是，脚本无法访问与之不同源的资源，也就是此时的脚本（内联的和外部引入的）无法访问资源 <code>https://example.com/user-info</code>。</p>
<h2 id="绕过同源策略">绕过同源策略</h2>
<p>有时比如上面的例子，我们确实需要在脚本中加载和当前页面不同源的资源，比如在 <code>http://example.com</code> 页面中使用脚本加载 <code>https://example.com/user-info</code> 中的内容。那么如何绕过浏览器的同源策略呢？</p>
<p>我们知道直接在页面中载入不同源的外部资源是可以的，那么我们就可以动态的载入一段外部的脚本。</p>
<p>首先，我们的 <code>http://example.com</code> 中有这么一段脚本：</p>
<pre><code>(function () {
    window[&#x27;showNickname&#x27;] = function (json) {
        alert(json[&#x27;nickname&#x27;]);
    };

    var userInfoServiceUrl = &#x27;https://example.com/user-info&#x27;;

    var doCrossSiteRequest = function (url, callback) {
        var script = document.createElement(&#x27;script&#x27;);
        script.src = url + &#x27;?callback=&#x27; + callback;
        var head = document.getElementsByTagName(&#x27;head&#x27;);
        if (head[0]) {
            head.append(script);
        }
    };

    document.querySelector(&#x27;#btnShowNickName&#x27;).addEventListener(&#x27;click&#x27;, function () {
        doCrossSiteRequest(userInfoServiceUrl, &#x27;showNickname&#x27;);
    });
})();
</code></pre>
<p>而 <code>https://example.com/user-info</code> 的服务端内容为：</p>
<pre><code>&lt;?php

$callback = isset($_GET[&#x27;callback&#x27;]) ? $_GET[&#x27;callback&#x27;] : null;
if ($callback === null) die(&#x27;invalid request&#x27;);

$userInfo = [
    &#x27;nickname&#x27; =&gt; &#x27;net-user&#x27;
];
$json = json_encode($userInfo);

echo &quot;{$callback}({$json});&quot;;
</code></pre>
<p>那么在浏览器加载了 <code>https://example.com/user-info</code> 的脚本为，得到的是：</p>
<pre><code>showNickname({&quot;nickname&quot;:&quot;net-user&quot;});
</code></pre>
<p>这就和我们最先在 <code>http://example.com</code> 留下的 <code>window[&#x27;showNickname&#x27;]</code> 对接上了。</p></div></div></div><div class="_3a4jt6lr4yLRJnQge009wv"><ul><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#静态页面">静态页面</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#动态页面">动态页面</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#异步加载">异步加载</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#同源策略">同源策略</a></span></div><ul></ul></div></li><li><div class="pr9M2Qxu3rP9KbtpZMUZy"><div class="_3BS2IRzowIlPVoY1ThvbNb"><span><a class="" href="#绕过同源策略">绕过同源策略</a></span></div><ul></ul></div></li></ul></div><div class="_1UY_ItV2UTWKutKs5b7NKg">Made with <a target="_blank" href="https://github.com/hsiaosiyuan0/gadget">gadget</a></div></div></div><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-core.min.js" data-manual="true"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-markup.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-clike.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-json.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-javascript.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-jsx.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-typescript.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-tsx.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-bash.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-python.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-xml-doc.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-docker.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-rust.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-nasm.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-c.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-cpp.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-xml-doc.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-go.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-nim.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/toolbar/prism-toolbar.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-highlight/prism-line-highlight.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/show-language/prism-show-language.min.js"></script><script src="https://cdn.jsdelivr.net/gh/cferdinandi/gumshoe@5.1.1/dist/gumshoe.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react@16.14.0/umd/react.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react-dom@16.14.0/umd/react-dom.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react@16.14.0/umd/react.production.min.js"></script><script src="https://cdn.jsdelivr.net/npm/react-dom@16.14.0/umd/react-dom.production.min.js"></script><script>window["__gadget__"]={"initialProps":{"data":{"post":{"filename":"浏览器异步加载和同源策略","rawMeta":{"title":"浏览器异步加载和同源策略"},"content":"## 静态页面\n在浏览器脚本的概念没有出现之前，所有的网页都是静态的。我们知道浏览器的工作模式是：\n\n1. 浏览器向网站服务器发起请求\n2. 网站接受浏览器的请求，返回一些字符串（比如一些组成页面的 HTML 字符串）\n3. 浏览器接收到网站返回的用于组成页面的字符串后，就可以关闭连接了\n4. 浏览器将组成页面的字符串渲染到屏幕上，使得用户可以看到一个可视化的结果\n\n看起来就像下面这样：\n\n```\n                                                                                  \n                                       Client Request                              \n              +-------------+                                     +--------+       \n+------+      |  User Agent | +-------------------------------->  |        |       \n| User +------>             |                                     | Server |       \n+--^---+      |  (Browser)  | <--------------------------------+  |        |       \n   |          +-------+-----+                                     +--------+       \n   |                  |                Server Response                             \n   |                  |                                                            \n   |                  |                                                            \n   |        +---------v--------+                                                   \n   |        | Close Connection |                                                   \n   |        +---------+--------+                                                   \n   |                  |                                                            \n   |                  |                                                            \n   |         +--------v--------+                                                   \n   ^---------+ Render response |                                                   \n             +-----------------+                                                   \n```\n\n我们看到，一旦用户代理（浏览器）关闭了和服务器之间的链接之后，客户端和服务器之间将不能继续通信。\n\n## 动态页面\n为了让页面可以给用户带来更多的交互，浏览器开发厂商们制造出了名为浏览器脚本的东西。比如你在浏览一个页面的时候，你觉得页面的字体太小了。在静态页面的时候，页面制作者在右上角给你提供了名为 “放大字体” 的按钮，你点击那个按钮，然后开启一轮新的请求，显著的说就是说你感觉到浏览器刷新了。这其实是浏览器重新从服务器加载页面的资源，只不过这一次的资源是用于显示字体放大后的页面。(尽管这个例子现在看来有些奇怪，因为如果仅仅是改变页面字体大小的话，似乎直接操作 `element.style.fontSize` 就可以了，不过请求另外一个包含更大字体的内联 CSS 页面在最终效果上也是说得通的，所以这里还请多多包含了。)\n\n浏览器脚本就是一小段由浏览器执行的代码，页面制作者将这一小段代码，和网页面的内容（比如一篇优美的散文，和它右上角的 “放大字体” 按钮）一起返回给浏览器。浏览器接收到页面资源后，首先就是先将散文和 “放大字体” 按钮显示出来。注意到返回的内容实际上还有一段由浏览器执行的代码，页面制作者在这段带代码中告诉浏览器：如果用户点击了 “放大字体” 按钮，那么你就将页面的字体放大。于是，当你点击 “放大字体” 按钮之后，浏览器严格执行页面制作者在脚本中撰写的内容 - 将页面的字体放大。\n\n## 异步加载\n注意在静态页面中浏览器和服务器之间的通信过程。浏览器在向服务器发起了对页面的请求之后，在服务器没有将页面的内容返回之前，页面是无法被显示出来的，最显著的特征就是我们在点击了浏览器的 “刷新” 按钮之后，页面会 “白屏” 一小段时间。\n\n起初浏览器脚本是没有网络通信的功能的，只能做一些页面的特效，比如“点击按钮放大了字体”。不过浏览器厂商发现，如果给脚本赋予网络通信的功能，将使得页面制作者可以给用户提供更好的页面交互体验。于是在早期的 IE 浏览器中，首先赋予了浏览器脚本的通信功能。\n\n浏览器脚本可以和服务器进行网络通信之后，页面制作者可以做出具有更好体验的页面。比如你现在需要搜索商品，假设是要买一本编程的书，你在网页的搜索框中输入了 “编程的数”，很明显是输错了，你将 “书” 错输成了 “数”。在你点击了 “搜索” 按钮之后，进过短暂的白屏之后，页面中显示了：\n\n> 找不到关于 “编程的数” 的产品，你是不是要找 “编程的书”\n\n很不错，网站给了我们一个提示，这样我们就可以发现自己的输入错误。不过这个体验还是有待提高的，因为每一次的搜索都会有一个短暂的 “白屏”，在白屏期间用户只能等待。在浏览器脚本可以通信之后，搜索就可以以一个异步的方式进行：\n\n1. 用户在浏览器中输入搜索页面的地址 “http://search.shop.com”\n2. 浏览器会向网站请求搜索页面的内容，用于显示这个页面\n3. 网站在返回页面的显示内容的同时，包含了一小段脚本，脚本的内容是告诉浏览器 “用户在点击了搜索之后，你给用户一个提示，让用户知道服务器正在紧张的搜索用户所需的资源，然后你显示了提示后，你再向服务器请求搜索的结果，当得到搜索结果后，你再把搜索结果显示给用户”\n\n这样的话，用户不必在搜索时面对页面的刷新时的 “白屏” 了，有一个提示框告诉用户稍等片刻。\n\n## 同源策略\n为了定位网络上的资源，我们采用了统一资源定位符 URL，就像是一个门牌号一样， URL 标识出资源在网络上的位置。我们浏览的网页，其中的内容可能会来自不同的提供者，比如散文来自一位作家，而其中的配图来自一位美术家。散文的 URL 是 `http://writer.com/new-world`，配图的 URL 是 `http://artist.com/new-world`。\n\n我们需要有一种方式将网络上的资源（比如散文和图画）标识出来，区别它们是来自于不同的作者。如果我们将颗粒度定位到每一个独立的资源，理论上是可行的，但是我们知道作家不可能只有一篇散文，而美术家也不会只有一幅画。于是我们选择了使用：通信协议，完整的域名，以及端口号去描述一个源，只有三者都相同，才标识两个资源是同源的。\n\n下面的几个资源是同源的：\n\n```\nhttp://example.com/ \nhttp://example.com:80/ \nhttp://example.com/path/file\n```\n\n下面的资源是不同源的：\n\n```\nhttp://example.com/ \nhttp://example.com:8080/ \nhttp://www.example.com/ \nhttps://example.com:80/ \nhttps://example.com/ \nhttp://example.org/ \nhttp://ietf.org/\n```\n\n现在知道了同源，那么同源策略是什么意思呢？同源策略就是，两个不同源的资源相互是不能访问对方的资源的。同源策略主要就是限制脚本的网络访问。\n\n比如我们打开了一个页面 `http://example.com`，这个页面有两段脚本，一个段使用的内联的方式称为 A，它主要就是在用户点击了按钮之后显示一段文字，告诉用户点击了按钮；另一段作为外部资源进行加载称为 B，B 是 A 的基础代码，比如 B 是 jQuery，它被放在了 `http://cdn.jquery.com` 上。首先我们知道，这两段代码如果按照同源的定义，肯定是不同源的。也就是说我们在 `http://example.com` 的页面上是不能加载 `http://cdn.jquery.com` 上的资源的。\n\n好像与现实情况有点矛盾。之所以现在可以，是因为浏览器为了适应实际的生产情况，放宽了对同源策略的检查，因为我们知道，不可能将所有的资源都放在同一台机器上。那么在页面完全加载好之后，页面中的脚本（内联的和外部引入）的都被浏览器归纳到了和当前页面相同的源，都属于 `http://example.com` 了。这么做的意思就是，脚本无法访问与之不同源的资源，也就是此时的脚本（内联的和外部引入的）无法访问资源 `https://example.com/user-info`。\n\n## 绕过同源策略\n有时比如上面的例子，我们确实需要在脚本中加载和当前页面不同源的资源，比如在 `http://example.com` 页面中使用脚本加载 `https://example.com/user-info` 中的内容。那么如何绕过浏览器的同源策略呢？\n\n我们知道直接在页面中载入不同源的外部资源是可以的，那么我们就可以动态的载入一段外部的脚本。\n\n首先，我们的 `http://example.com` 中有这么一段脚本：\n\n```\n(function () {\n    window['showNickname'] = function (json) {\n        alert(json['nickname']);\n    };\n\n    var userInfoServiceUrl = 'https://example.com/user-info';\n\n    var doCrossSiteRequest = function (url, callback) {\n        var script = document.createElement('script');\n        script.src = url + '?callback=' + callback;\n        var head = document.getElementsByTagName('head');\n        if (head[0]) {\n            head.append(script);\n        }\n    };\n\n    document.querySelector('#btnShowNickName').addEventListener('click', function () {\n        doCrossSiteRequest(userInfoServiceUrl, 'showNickname');\n    });\n})();\n```\n\n而 `https://example.com/user-info` 的服务端内容为：\n\n```\n<?php\n\n$callback = isset($_GET['callback']) ? $_GET['callback'] : null;\nif ($callback === null) die('invalid request');\n\n$userInfo = [\n    'nickname' => 'net-user'\n];\n$json = json_encode($userInfo);\n\necho \"{$callback}({$json});\";\n```\n\n那么在浏览器加载了 `https://example.com/user-info` 的脚本为，得到的是：\n\n```\nshowNickname({\"nickname\":\"net-user\"});\n```\n\n这就和我们最先在 `http://example.com` 留下的 `window['showNickname']` 对接上了。\n","slug":"/browser/浏览器异步加载和同源策略","toc":[{"name":"静态页面","depth":2,"anchor":"#静态页面","children":[]},{"name":"动态页面","depth":2,"anchor":"#动态页面","children":[]},{"name":"异步加载","depth":2,"anchor":"#异步加载","children":[]},{"name":"同源策略","depth":2,"anchor":"#同源策略","children":[]},{"name":"绕过同源策略","depth":2,"anchor":"#绕过同源策略","children":[]}],"keywords":[],"mtime":1615393171080},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"craft","url":"/post/craft","children":[{"name":"制作一个属于自己的语言","url":"/post/craft/create_your_own_lang.html","children":[]}]},{"name":"go","url":"/post/go","children":[{"name":"Go 语言中的 Generic 设计缺陷","url":"/post/go/bad_in_generic_syntax.html","children":[]}]},{"name":"daily","url":"/post/daily","children":[{"name":"初唐四杰","url":"/post/daily/初唐四杰.html","children":[]}]}],"title":"The hard ways"}},"currentRoute":{"pattern":"/post","href":{"pathname":"/post"}},"pageModules":{"/index":["/pages/index.js"],"/post":["/pages/post.css","/pages/post.js"],"/sitemap":["/pages/sitemap.css","/pages/sitemap.js"],"/post/*":["/pages/post.css","/pages/post.js"]},"router":{"basename":"/","hash":false,"routes":["/index","/post","/sitemap","/post/*"]}};</script><script crossorigin="anonymous" src="/app.js"></script><script crossorigin="anonymous" src="/foundation.js"></script><script crossorigin="anonymous" src="/lib.js"></script><script crossorigin="anonymous" src="/shared-pages_post_tsx.js"></script><script crossorigin="anonymous" src="/pages/post.js"></script></body></html>