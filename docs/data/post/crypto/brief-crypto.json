{"code":200,"data":{"post":{"filename":"brief-crypto","rawMeta":{"title":"加密算法调研"},"content":"# 加密算法调研\n\n需求需要对数据进行加解密，所以需要对一些常见加密算法做一些调研。\n\n## 对称加密\n\n对称加密 [Symmetric-key algorithms](https://en.wikipedia.org/wiki/Symmetric-key_algorithm) 有如下几个特点：\n\n1. 使用相同的密匙进行加解密\n2. 加解密速度相比非对称加密要快\n3. 对 plaintext 的大小理论上没有限制\n4. 加密后的密文大小的增幅不大\n\n## 非对称加密\n\n非对称加密 [Public-key cryptography, or asymmetric cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography) 有如下几个特点\n\n1. 使用一个公私匙对进行加解密\n2. 加密速度相比对称加密要慢很多\n2. 在特定情况下，对 plaintext 的大小有限制\n3. 加密后的密文大小的增幅很大\n\n常见的非对称加密算法有：\n\n1. RSA (HTTPS 中使用)\n2. ECDSA ([Bitcoin 中使用](https://en.bitcoin.it/wiki/How_bitcoin_works))\n\nRSA 和 ECDSA 的比较可以参考 [ECDSA and RSA](https://equaleyes.com/blog/2018/04/06/ecdsa-and-rsa-algorithms/)，简单的来说 ECDSA 有如下几个优点\n\n1. 在与 RSA 达到相同加密程度下的 key 尺寸更小 见 [Elliptic_Curve_Cryptography](https://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography)\n2. 在与 RSA 达到相同加密程度下的 key 生成更快\n3. 加解密比 RSA 快点\n\n_RSA 的加密程度与 key 的大小成正比。_\n\n\n## 几个引用\n\n### ref1 \n\n[RSA maximum bytes to encrypt, comparison to AES in terms of security?\n](https://security.stackexchange.com/questions/33434/rsa-maximum-bytes-to-encrypt-comparison-to-aes-in-terms-of-security#answer-33445)\n\n主要说明非对称加密算法之一的 RSA 在某些情况下对 plaintext 的大小是有限制的。\n\n另外说明了非对称加密的通常使用方式是做 [Enveloped Encryption](https://en.wikipedia.org/wiki/Public-key_cryptography#Enveloped_Public_Key_Encryption)\n\n### ref2\n\n[Why is asymmetric cryptography bad for huge data](https://crypto.stackexchange.com/questions/5782/why-is-asymmetric-cryptography-bad-for-huge-data#answer-5790)\n\n主要说明非对称加密会消耗更对的空间来存储密文，比明文高出 49%。\n\n相比非对称加密更慢消耗更多的性能，这点在移动设备上应该更为突出。\n\n其中的一条补充应该是对 ref1 中:\n\n> the maximum size of data which can be encrypted with RSA is 245 bytes. No more.\n\n的补充，所以我感觉用 “特性情况” 下对 plaintext 的大小有限制这样来表述比较准确。\n\n另一条补充强调了任何的 public-key encryption 都会导致密文大小变大。\n\n## 小结\n\n所以为了达到一个性能和安全性通用的程度，我们还是应该采取常见的 Enveloped Encryption 方式。\n\n为了达到贴合 Bitcoin 的目的，可以使用 ECDSA 配合 AES 来对数据加密，具体的加密步骤如下：\n\n1. 随机生成密匙 AK 用于 AES 加密\n2. 对数据 Data 使用 AK 进行 AES 加密得到 AES(Data)\n3. 使用 ECDSA 公钥对 AK 进行加密得到 ECDSA(AK)\n4. 将 ECDSA(AK) 和 AES(Data) 写入文件，即为加密文件\n\n对于每个文件的加密，都执行上述步骤，即每次的 AK 不同。\n\n具体的解密步骤如下：\n\n1. 打开加密文件得到数据 ECDSA(AK) 和 AES(Data)\n2. 使用对应的 ECDSA 私钥解密 ECDSA(AK) 得到 AK\n3. 使用 AK 进行 AES 解密 AES(Data) 得到 Data\n4. 将 Data 写入文件，即为原始文件\n\n这样有几个好处：\n\n1. 利用了非对称加密的特性: 速度快，密文增幅小\n2. 密文仅自己可以见，因为加密时使用的公钥进行的加密\n\n上述步骤不能直接使用在数据需要分享的情况下，因为数据使用了公钥进行加密，解密时需要对应的私钥。\n\n未来需要增加分享功能时，我们可提供功能，使得用户可以用他所期望的数据接收方的公钥、来使用上述步骤加密数据，数据接收方得到数据后，按上述的步骤进行解密即可。\n\n","slug":"/crypto/brief-crypto","toc":[{"name":"对称加密","depth":2,"anchor":"#对称加密","children":[]},{"name":"非对称加密","depth":2,"anchor":"#非对称加密","children":[]},{"name":"几个引用","depth":2,"anchor":"#几个引用","children":[{"name":"ref1","depth":3,"anchor":"#ref1","children":[]},{"name":"ref2","depth":3,"anchor":"#ref2","children":[]}]},{"name":"小结","depth":2,"anchor":"#小结","children":[]}],"keywords":[],"mtime":1615393171068},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"react","url":"/post/react","children":[{"name":"build-from-source","url":"/post/react/build-from-source.html","children":[]},{"name":"bootstrap","url":"/post/react/bootstrap.html","children":[]}]}],"title":"The hard ways"}}