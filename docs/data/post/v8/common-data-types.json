{"code":200,"data":{"post":{"filename":"common-data-types","rawMeta":{"title":"v8 常见数据类型"},"content":"# v8 常见数据类型\n\n在编写 node-addon 的时候，了解 v8 的常用数据类型非常重要，否则就会淹没在各种莫名的类型转换中，另外通过 v8 的类型，也可以对 v8 的内部实现加以了解\n\n所以既是作为常见类型的速查手册，也是对实现的简单了解，同时补充一下 cpp 知识，因此不会停留在表面的 API 传译\n\n## Maybe\n\n[Maybe<T>](https://github.com/v8/v8/blob/master/include/v8.h#L10085) 就是 tagged union 的实现，表示 T「存在」或者「不存在」两种情况\n\n`IsNothing` 成员方法表示不存在\n\n`IsJust` 成员方法表示存在\n\n`Check` 判断 T 是否存在，如果不存在则报错并终止程序\n\n`ToChecked` 和 `FromJust` 完全一样，存在则返回 T 值，否则报错并终止程序\n\n`To(T* out)` 用于访问 Maybe 内部的 T 值，如果 T 存在，则将其地址赋值给 `out`、并返回 `true`，否则仅返回 `false`\n\n`Maybe<T>` 的作用是：\n\n- 用于表示某些返回值类型为 T 的 subroutine 的返回值，因为这些 subroutine 内部可能因为某种操作失败导致无法正确返回 T，因此通过返回「不存在」的 `Maybe<T>` 表示内部操作失败\n- 提供安全的访问可能不存在的 T 值的方式（可以从上面的成员方法看出），基本上都需要开发者主动思考 T 不存在的情况\n\n## Local\n\n[Local<T>](https://github.com/v8/v8/blob/master/include/v8.h#L197) 表示的是被 GC 管理的对象\n\n> It is safe to extract the object stored in the handle by\n> dereferencing the handle (for instance, to extract the Object* from\n> a `Local<Object>`); the value will still be governed by a handle\n> behind the scenes and the same rules apply to these values as to\n> their handles.\n\n可以安全的使用 dereferencing 来访问 Local 内部的对象，该对象依然会被 GC 妥善处理\n\n> Local handles are light-weight and transient and typically used in\n> local operations.  They are managed by HandleScopes. That means that a\n> HandleScope must exist on the stack when they are created and that they are\n> only valid inside of the HandleScope active during their creation.\n> For passing a local handle to an outer HandleScope, an EscapableHandleScope\n> and its Escape() method must be used.\n\n使用 Local 或者其内部的对象时，需要注意它的生命周期属于其之前外部声明的 `HandleScope`，当其所属的 `HandleScope` 因为离开作用域而销毁时，会连同该对象一起销毁\n\n当需要在不同的 `HandleScope` 之间传递对象时，就需要借助 `EscapableHandleScope` 和 `Escape` 方法\n\n## MaybeLocal\n\n[MaybeLocal](https://github.com/v8/v8/blob/master/include/v8.h#L369) 是针对 `Local<>` 的 `Maybe<>`，所以就很好理解了\n\n主要的疑点在于：\n\n```cpp\ntemplate <class T>\nclass MaybeLocal {\n public:\n  V8_INLINE MaybeLocal() : val_(nullptr) {}\n  template <class S>\n  V8_INLINE MaybeLocal(Local<S> that)\n      : val_(reinterpret_cast<T*>(*that)) {\n    static_assert(std::is_base_of<T, S>::value, \"type check\");\n  }\n private:\n  T* val_;\n}\n```\n\n`reinterpret_cast` 和 `static_cast` 的区别：\n\n- 使用 static_cast 时，类型系统会在需要转换的 from 和 to 之间做静态类型校验，确保它们之间是可以进行转换的（语义上、数据类型等维度）\n  \n  比如 `void*` 是可以 static_casting 到 `int*` 的，而 `int*` 是不可以 static_casting 到 `double*` 的\n\n- 使用 `reinterpret_cast` 则是强制类型系统进行转换，由开发者自己确保转换的正确性\n\n考虑下面的表达式：\n\n```cpp\nauto str = MaybeLocal<String>(pattern);\n```\n\n`T` 就是 `MaybeLocal<String>` 中的 `String`，而 `S` 则是 `pattern` 在静态分析阶段推导出的类型，如果 S 和 T 之间没有显式地确定转换规则，使用 static_cast 就会报错，比如这里如果 pattern 的类型是 `Function`\n\n由于没有 `Function -> String` 的规则，所以无法完成 static_cast，于是这里使用了 `reinterpret_cast`，但是这样又会导致 `pattern` 可以传任意的值，于是加上一个 `is_base_of` 的静态校验，校验 S 必须是 T 的派生类型\n\n这样就不必为形如 `Local<String> -> Local<Object>` 编写显式地拷贝构造函数了 - 简单确认下 String 是 Object 的派生类型就可以符合业务场景了\n\n\n参考来源：\n\n- [v8](https://github.com/v8)\n- [Learning Google V8](https://github.com/danbev/learning-v8)\n","slug":"/v8/common-data-types","toc":[{"name":"Maybe","depth":2,"anchor":"#Maybe","children":[]},{"name":"Local","depth":2,"anchor":"#Local","children":[]},{"name":"MaybeLocal","depth":2,"anchor":"#MaybeLocal","children":[]}],"keywords":[],"mtime":1615393171067},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"craft","url":"/post/craft","children":[{"name":"制作一个属于自己的语言","url":"/post/craft/create_your_own_lang.html","children":[]}]}],"title":"The hard ways"}}