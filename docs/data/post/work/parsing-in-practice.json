{"code":200,"data":{"post":{"filename":"parsing-in-practice","rawMeta":{"title":"Parsing in practice"},"content":"<!--\n{\n  \"title\": \"Parsing in practice\"\n}\n-->\n# Parsing in practice\n\n现在工作中的项目是一个数据展示类的项目，主要负责将后端分析过的数据，通过 charts 显示到页面中。项目是前后端分离的，它构架是：\n\n```\n前端页面 -> nodejs 中间层 -> java 服务\n```\n\n比如现在页面中需要显示三个指标：访客数(UV)，支付订单数(PAY\\_ORDER\\_CNT)，退货率\n\n对于前两个指标，要得到它们的数值非常简单，就是把括号中的字母内容作为 key 提交给接口服务，接口服务就会返回 key 所对应的数值，前端得到数据直接显示即可。我们可以暂且把这种可以直接由 key 取到内容的指标成为 \"简单指标\"，并且由于接口不支持多个 key 同时查询，所以每个简单指标必须独立为一个接口请求。\n\n对于退货率这个指标，我们可以称之为 \"复合指标\"，它是由几个简单指标计算得来的，比如这个退货率，它在后端提供的文档中描述的表达式是:\n\n```\nRETURN_ORDER_CNT / (RETURN_ORDER_CNT + SUB_PAY_ORDER_CNT)\n```\n\n这个表达式中涉及的两个简单指标是：退货订单数(RETURN\\_ORDER\\_CNT) 和 正向支付订单数(SUB\\_PAY\\_ORDER\\_CNT)。然而，在实际操作中，会有各种简单指标进行运算组合的复合指标，而且由于复合指标的需求是会不断更改和增加的，所以如果只是针对每个复合指标不断写子处理程序的话，那么工作量以及维护成本将会很高。对于复合指标的计算，本应该放在服务端运行，由接口直接提供计算结果，但是由于它们机械繁琐的工作量，后端没人愿意做。\n\n毕竟到了前端就没人可以说理去了，总不能让用户自己来算复合指标吧。这时我们的编译技术排上了用场。\n\n首先复合指标都是一些简单的数学表达式，把这些复合指标的计算表达式形容成 DSL 也不过份吧。\n\n要计算复合指标，只需要分两步：\n\n1. 分别请求计算复合指标所需的每个简单指标的值\n2. 对表达式进行求值\n\n好在这个 DSL 非常的简单，只要处理表达式的解，而且只有双目运算，就省去了结合性的考虑，只要处理运算符优先级就可以了。\n\n因为只是处理运算符的优先级，利用 [Shunting Yard Algorithm](https://en.wikipedia.org/wiki/Shunting-yard_algorithm) 就好了。将表达式由 中缀(infix) 转换成 后缀(postfix) 形式，保存在一个栈中，\n\n```\nRETURN_ORDER_CNT/(RETURN_ORDER_CNT+SUB_PAY_ORDER_CNT)\n```\n  \n就被处理成了 \n  \n```\n// 栈底 -> 栈顶\nRETURN_ORDER_CNT RETURN_ORDER_CNT SUB_PAY_ORDER_CNT + /\n```\n\n然后逐个弹出栈中的内容，如果是运算符，就分别弹出两个操作数，如果操作数又是运算符，那么就递归调用，如果操作数是标识符，那么就带入之前的简单指标请求的结果，最后根据不同的运算符来对两个操作数进行运算。\n\n这是一个在线的预览 [复合指标计算](https://jsfiddle.net/hsiaosiyuan/cr17w07q/5/)，点击了 run 之后，打开 console 看下是否有没有通过的 assert 就可以了。\n","slug":"/work/parsing-in-practice","toc":[],"keywords":[],"mtime":1615393171081},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"object-in-v8","url":"/post/nodejs/object-in-v8.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"react","url":"/post/react","children":[{"name":"build-from-source","url":"/post/react/build-from-source.html","children":[]},{"name":"bootstrap","url":"/post/react/bootstrap.html","children":[]}]}],"title":"The hard ways"}}