{"code":200,"data":{"post":{"filename":"汇编语言学习小结","rawMeta":{"title":"汇编语言学习小结"},"content":"# 汇编语言学习小结\n\n学习汇编语言书「guide-to-assembly-language-programming-in-linux」的收获:\n\n1. 了解汇编语言的语法\n2. 了解 CPU 和 内存的基本结构\n3. 栈及其相关操作\n4. 了解汇编语言层面如何进行 Procedure 调用，包括传参和返回值和返回点如何处理\n5. 了解汇编语言和 C 语言如何相互调用，以及 C 语言是如何编译成汇编语言\n\n## 汇编语言的语法\n\n汇编语言的语法包括预处理和指令生成两种，预处理部分在汇编的预处理阶段被处理，而指令生成部分则会在编译阶段生成具体的指令。\n比如预处理阶段的 `macro` 和 `%define` 以及指令生成阶段的 `add AX, 1`。\n\n对于指令生成的语法，都是每一行对应一条指令，且语法形式为 `opode operand1, operand2, ...` 即操作码接操作数的形式。\n\n## 了解 CPU 和内存的基本结构\n\nCPU 由各种运算电路以及寄存器组成。运算电路负责实际的运算，而寄存器用于存放参数，临时结果，最终结果。寄存器分为通用寄存器和特定用途寄存器。\n\n特定用途寄存器又大致分为： 段寄存器，标志寄存器和指令指针寄存器，等。对于 EBP 和 ESP 这两个寄存，有时又被称为特殊通用寄存器，这是因为在进行栈的相关操作时这两个寄存器会有特殊用途。所谓“通用”指的是，该寄存器可以作为计算或者存放临时结果的寄存器，而特殊寄存器则被限定了其用途，比如指令指针寄存器，只可以用于存放接下来的指令的位置。\n\n之所以 ESP 和 EBP 被称为通用寄存器就是因为，这两个寄存器也是可以在计算时用于存放临时结果的，只不过在栈相关操作时，为了方便将他们的功能基于约定地限定了。\n\n对于内存的基本结构而言，CPU 并不能够直接访问内存上的数据，而是要通过地址总线，数据总线和控制总线，来指挥内存芯片来读取或者写入内存数据。由于内存以及 CPU 的设计结构限制，会有存在内存上的数据需要进行对齐的要求，如前所述，该要求并不是绝对的。数据对齐一般都是有编译器自动完成的，这在 C 语言中就涉及到数据 padding。\n\n## 栈及其相关操作\n\n栈是一个后进先出的结构，并且向低地址方向增长，栈中只会存放 word 和 double words 长度的元素，不会单独存放单个字节。TOS 指向的是栈顶元素的最低字节，栈中元素被 pop 后，只是将 TOS 向高地址方向进行移动，以此达到元素被移出的效果。移出元素的内存中的数据则实在下一次的入栈操作时被覆写。\n\n## 了解 Procedure 调用细节\n\n过程调用时的参数可以通过寄存器或者栈进行传递。使用寄存器和栈个有利弊。使用寄存器能获取更高的性能，这是因为减少了内存操作，操作数直接存在于寄存器中了。使用寄存器的弊端就是，寄存器数量是有限的，所以主要还是应该将它们用于计算。使用栈传递的参数的好处就是可以将原本用于传参的寄存器解放出来，用于计算，弊端就是在涉及到具体的计算时，需要将数据从栈中载入寄存器。\n\n参数的释放，可以由调用者或者被调用者来释放。在参数长度固定的情况下，由被调用者进行参数的释放，比较符合模块化的设计思路。当参数长度不固定时，则只能有调用者来进行参数的释放。\n\n在过程内部，在需要使用寄存器时，首先需要想将其进行压栈备份，然后在过程执行完毕后，进行出栈恢复。\n\ncall 指令的操作数并不是过程的相对代码段基地址的偏移量，而是相对被调用过程的第一条指令想对于 call 指令的下一条指令的相对偏移量，比如：\n\n```nasm\n%include \"io.mac\"\n.DATA\nprompt_msg1  db   \"Please input the first number: \",0\nprompt_msg2  db   \"Please input the second number: \",0\nsum_msg      db   \"The sum is \",0\n\n.CODE\n      .STARTUP\n      PutStr  prompt_msg1    ; request first number\n      GetInt  CX             ; CX = first number\n\n      PutStr  prompt_msg2    ; request second number\n      GetInt  DX             ; DX = second number\n\n      call    sum            ; returns sum in AX\n      PutStr  sum_msg        ; display sum\n      PutInt  AX\n      nwln\ndone:\n      .EXIT\n\n;-----------------------------------------------------------\n; Procedure sum receives two integers in CX and DX.\n; The sum of the two integers is returned in AX.\n;-----------------------------------------------------------\nsum:\n      mov     AX,CX          ; sum = first number\n      add     AX,DX          ; sum = sum + second number\n      ret\n```\n\n上面代码中的 `call sum` 执行过程如下:\n\n1. `call sum` 指令被读取，此时 EIP 寄存器已经为 `PutStr  sum_msg` 相对代码段基地址的偏移量了，假设 `call sum` 的地址为 `x`，则此时 EIP 的内容为 `x+1`。\n2. `call sum` 的操作数为 `sum` 第一条指令的地址 `mov AX，CX` 相对于 `PutStr  sum_msg` 的相对偏移量。假设 `mov AX，CX` 地址为 y，此时 call 的操作数为 `y - (x + 1)`。因此，call 指令执行完成后，即对 EIP 中的地址进行调整，使得 EIP 中的地址变为了 `sum` 第一条命令的地址，即 `y = (y - (x + 1) + (x + 1))`。\n\n除了修改 EIP 的内容达到指令跳转的功能外，call 指令还会将当前(修改前)的 EIP 内容压入栈中，因此在被调用过程的内部，可以使用 ret 指令进行返回。有一点需要注意的时，在执行 ret 指令时，ESP 必须指向栈上的记录返回地址的元素，这在由被调用的过程释放参数的情况下需要注意，可以使用 ret 的操作数来完成释放并返回的效果:\n\n```nasm\nret     optional-value\n; 类似\nEIP=SS:ESP\nESP=ESP + optional-value\n```\n\n局部变量的处理，通过使用 enter 和 leave 指令来完成:\n\nenter 指令的格式为:\n\n```nasm\nenter   bytes,level\n\n```\n\nlevel 用于高级语言中表示栈的嵌套层次\n\n\n```nasm\nenter   XX,0\n; 等价于\npush    EBP \nmov     EBP,ESP\nsub     ESP,XX\n```\n\n注意上面的 `sub ESP,XX`，前面提到栈是往低地址进行增长的，这里的减就是这个意思。\n\n\nleave 指令的执行类似:\n\n```nasm\nmov     ESP,EBP\npop     EBP\n```\n\n注意这里是将 EBP 赋值给了 ESP，而 EBP 的内容是在进入被调用过程后立即保存的 ESP 的值。\n\n一般的过程调用模板类似，当然这是由被调用函数释放参数的过程:\n\n```nasm\nproc-name:\n    enter   XX,0\n    ;procedure body\n    leave\n    ret     YY\n```\n\n如果过程需要使用到局部变量，那么 XX 将是一个非零的值。YY 目的是释放传入的参数。\n\n再补充一下 call 与 jmp 的区别：\n\n* jmp 指令只会跳转到指定的位置\n* call 指令除了会进行跳转之外，还会将将钱 EIP 寄存器的内容压入栈中\n\n这里分别是 call 和 jmp 的手册: [call](https://c9x.me/x86/html/file_module_x86_id_26.html)， [jmp](https://c9x.me/x86/html/file_module_x86_id_147.html)\n\n可以看到，上文的描述并不是完全的准确，call 和 jmp 一样，根据跳转的距离分为 short, near，far。在 short 和 near(部分) 情况下，使用的相对位移，其他情况使用的是绝对地址。\n\n## 和 C 语言相互调用\n\n本书的 C 编译成汇编的例子在实际操作中可能因为 gcc 版本的差异，导致汇编结果不同。而且汇编的结果显示:\n\nC 代码:\n\n```c\nint test(int x, int y, int z) {\n    return x + y + z;\n}\n\nint main(void) {\n    int x = 25, y = 70;\n    int value;\n    value = test(x, y, 5);\n}\n```\n\n的汇编结果为，使用 `gcc -S -masm=intel test.c`:\n\n```nasm\n\t.file\t\"test.c\"\n\t.intel_syntax noprefix\n\t.text\n\t.globl\ttest\n\t.type\ttest, @function\ntest:\n.LFB0:\n\t.cfi_startproc\n\tpush\trbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmov\trbp, rsp\n\t.cfi_def_cfa_register 6\n\tmov\tDWORD PTR -4[rbp], edi\n\tmov\tDWORD PTR -8[rbp], esi\n\tmov\tDWORD PTR -12[rbp], edx\n\tmov\tedx, DWORD PTR -4[rbp]\n\tmov\teax, DWORD PTR -8[rbp]\n\tadd\tedx, eax\n\tmov\teax, DWORD PTR -12[rbp]\n\tadd\teax, edx\n\tpop\trbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\ttest, .-test\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB1:\n\t.cfi_startproc\n\tpush\trbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmov\trbp, rsp\n\t.cfi_def_cfa_register 6\n\tsub\trsp, 16\n\tmov\tDWORD PTR -12[rbp], 25\n\tmov\tDWORD PTR -8[rbp], 70\n\tmov\tecx, DWORD PTR -8[rbp]\n\tmov\teax, DWORD PTR -12[rbp]\n\tmov\tedx, 5\n\tmov\tesi, ecx\n\tmov\tedi, eax\n\tcall\ttest\n\tmov\tDWORD PTR -4[rbp], eax\n\tmov\teax, 0\n\tleave\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE1:\n\t.size\tmain, .-main\n\t.ident\t\"GCC: (Ubuntu 7.3.0-27ubuntu1~18.04) 7.3.0\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n```\n\n可以看到并没有使用栈进行传参，而是使用的寄存器，所以问题在就在如果代码是 C 和汇编进行的混编，那么汇编的部分如何知道 C 语言使用的是哪几个寄存器进行的传参？后续看到的再进行补充","slug":"/assembly/汇编语言学习小结","toc":[{"name":"汇编语言的语法","depth":2,"anchor":"#汇编语言的语法","children":[]},{"name":"了解 CPU 和内存的基本结构","depth":2,"anchor":"#了解CPU和内存的基本结构","children":[]},{"name":"栈及其相关操作","depth":2,"anchor":"#栈及其相关操作","children":[]},{"name":"了解 Procedure 调用细节","depth":2,"anchor":"#了解Procedure调用细节","children":[]},{"name":"和 C 语言相互调用","depth":2,"anchor":"#和C语言相互调用","children":[]}],"keywords":[],"mtime":1615393171076},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"react","url":"/post/react","children":[{"name":"build-from-source","url":"/post/react/build-from-source.html","children":[]},{"name":"bootstrap","url":"/post/react/bootstrap.html","children":[]}]},{"name":"ripplet","url":"/post/ripplet","children":[{"name":"create_your_own_lang","url":"/post/ripplet/create_your_own_lang.html","children":[]}]},{"name":"esbuild","url":"/post/esbuild","children":[]}],"title":"The hard ways"}}