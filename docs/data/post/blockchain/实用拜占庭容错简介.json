{"code":200,"data":{"post":{"filename":"实用拜占庭容错简介","rawMeta":{"title":"实用拜占庭容错简介"},"content":"# 实用拜占庭容错简介\n\n容错性一直是分布式系统中需要处理的问题，而拜占庭将军问题被认为是容错性问题中最难的问题类型之一。分布式账本作为一个分布式系统，也面临该问题，著名的比特币则是采用的 PoW 来应对该问题，类似的还有以太坊中的 PoS 等。本文则简单介绍了另一种解决方案，即实用拜占庭容错算法(Practical Byzantine Fault Tolerance) 该算法的衍生版本也在一些分布式账本系统中得到应用，比如 [Neo](https://neo.org)。\n\n关于拜占庭将军问题的简单描述如下：\n\n> 一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。\n\n以上内容摘自 [维基百科-拜占庭将军问题](https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98)。\n\n在早期 1982 年的[论文](https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98#cite_note-BGP_Paper-1)中提出的算法，并不具备非常高的实用性。因为为了达成共识，节点需要观察其余节点对消息的反应，这就需要消息需要以一个类似“递归”的形式在不同的轮次中的各个节点间传递。如果需要进一步了解其中的细节，除了参考论文实现外，还可以参考这篇文章 [Mark Nelson - The Byzantine Generals Problem](https://marknelson.us/posts/2007/07/23/byzantine.html) 。\n\n而实用拜占庭容错算法，则提供了一个相对于早期算法而言，更易于实现、更高效的算法。\n\n实用拜占庭容错算法，其实是将拜占庭将军问题简化成以下两点来考虑：\n\n1. 系统中的消息，存在不可达的可能性，由于网络问题，软件自身错误等，简称 fail-stop\n2. 系统中可能存在恶意节点，故意破坏系统的一致性，简称 malicious\n\n当系统只存在问题  1 时，该问题的其实就回到类似内网中的节点同步问题。[Viewstamped Replication](http://pmg.csail.mit.edu/papers/vr-revisited.pdf) 或者 paxos 等算法都提供了对该问题的解决方案。而实用拜占庭容错算法，实际是在 Viewstamped Replication 算法上的升级、额外提供了对问题  2 的解决方案。\n\n实用拜占庭容错算法，可以粗略的描述为：\n\n在实用拜占庭容错算法中，将每次的共识称之为 view，在每次共识中，都会选择其中一个节点作为 primary，其余节点为 backups。每次的共识，即 view 都有一个自增的 id。当次 view 中的 primary 的选取规则为 `P = v mod |R|` v 表示 view id，`|R|` 表示节点总数，R 为 replica 的简写。\n\n算法工作流程为：\n\n1. 客户端向 primary 发起一个操作请求\n2. primary 向其余 backups 广播上述请求\n3. 所有节点都执行该请求，并将执行结果反馈给客户端\n4. 客户端等待来自不同节点的 f + 1 个相同的反馈，该反馈结果，即为操作结果。\n\n实用拜占庭容错算法，对共识节点的数量做了如下要求，假设节点总数为 n，恶意节点数为 f，`n = 3f + 1` 为可以容纳 f 个恶意节点的最少总数。下面对这个数值关系做更加进一步的说明。\n\n首先要知道，系统中采用的是少数服从多数的原则。当系统中只存在问题 1 时，那么当一个操作到达时，最优情况下，会接受到 n 个节点的反馈，也就是 f 为 0。当 f 不为 0 时，则可以接收到的反馈数量为 `n-f`，此时为了得到共识结果，必须满足 `n - f > f`。如果进一步了解 Viewstamped Replication 算法的话，会发现这一步的数值关系和其中要求的一样。这里的容错的 f 表示的是 fail-stop 节点数。\n\n当引入的问题 2 后，接收到的 `n - f` 个反馈中，还可能存在 f 个反馈是恶意的，那么此时为了达成共识，则要求 `n - f - f > f`，即 `n > 3f`。\n\n当我们在实现性地部署一些使用拜占庭容错算法实现的软件时，文档中会建议采用 4 个节点来做实验，并且让建议关掉其中 1 台，观察到系统仍然可以完成共识。这里实际上会让人产生一些错误的映像，认为 4 个节点只能容纳 1 个节点出错。其实这个实验仅仅展示了系统可以容纳 1 台 fail-stop 节点。在容纳一台 fail-stop 节点的同时，仍然可以存在另一台 malicious 节点，换句话说，完整的实验是，关掉一台节点，模拟 fail-stop，于此同时，让一台节点进行错误的反馈，最终发现系统仍能达成共识。","slug":"/blockchain/实用拜占庭容错简介","toc":[],"keywords":[],"mtime":1615393171079},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"react","url":"/post/react","children":[{"name":"build-from-source","url":"/post/react/build-from-source.html","children":[]},{"name":"bootstrap","url":"/post/react/bootstrap.html","children":[]}]},{"name":"ripplet","url":"/post/ripplet","children":[{"name":"码个自己的语言","url":"/post/ripplet/create_your_own_lang.html","children":[]}]},{"name":"dev","url":"/post/dev","children":[]},{"name":"esbuild","url":"/post/esbuild","children":[]}],"title":"The hard ways"}}