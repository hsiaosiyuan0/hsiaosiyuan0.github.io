{"code":200,"data":{"post":{"filename":"crypto-conditions 简述","rawMeta":{"title":"crypto-conditions 简述"},"content":"# crypto-conditions 简述\n\n> 下文将 crypto-conditions 简称为 cc\n> cc 的详细的文档描述见 [ietf](https://tools.ietf.org/html/draft-thomas-crypto-conditions-04)\n\n在现有的 public-key 这样的签名策略下，消息的传递过程如下:\n1. 消息发送方 A 先将需要发送给消息接受方 B 的消息 M 进行摘要 `H = hash(M)`\n2. A 用自己的私钥对摘要进行加密得到 AEH (A's encrypted hash 即 signature)\n3. A 将要发送的消息 M 以及签名 AEH 发送给 B\n4. B 接受到 M 后，对 M 进行摘要得到 BH\n5. B 使用 A 的公钥对 AEH 进行解密，得到 AH\n6. B 通过判断 `BH == AH` 是否成立来确定消息是否来自于 A\n\n可以看到在 public-key 策略下，对一个消息的合法性的校验，发送方被限制成了单个实体 (one keypair)、单个条件 (签名匹配)\n\n而 cc，则提供一个将现有加密验证算法进行条件组合的功能，比如上面的例子是 A 给 B 发送了消息，B 希望验证这个消息是 A 发送的。通过 cc，可以实现 A、C、D 一起给 B 发送了一个消息，B 可以验证 A、C、D 一起发送的，又或者 A、C、D 一起给 B 发送了一个消息，同时告诉 B，它们之间只要确定两个人，就可以证明消息的正确性，那么当 B 验证时，只要确保三人之间通过两人即可。\n\n在 chaindb 的关于 cc 的[文档](https://docs.bigchaindb.com/projects/server/en/v0.8.2/data-models/crypto-conditions.html)中，有这样的例子：\n\n```js\n{\n    \"cid\": \"<condition index>\",\n    \"condition\": {\n        \"details\": {\n            \"bitmask\": 41,\n            \"subfulfillments\": [\n                {\n                    \"bitmask\": 32,\n                    \"public_key\": \"<new owner 1 public key>\",\n                    \"signature\": null,\n                    \"type\": \"fulfillment\",\n                    \"type_id\": 4,\n                    \"weight\": 1\n                },\n                {\n                    \"bitmask\": 32,\n                    \"public_key\": \"<new owner 2 public key>\",\n                    \"signature\": null,\n                    \"type\": \"fulfillment\",\n                    \"type_id\": 4,\n                    \"weight\": 1\n                }\n            ],\n            \"threshold\": 2,\n            \"type\": \"fulfillment\",\n            \"type_id\": 2\n        },\n        \"uri\": \"cc:2:29:ytNK3X6-bZsbF-nCGDTuopUIMi1HCyCkyPewm6oLI3o:206\"},\n        \"owners_after\": [\n            \"owner 1 public key>\",\n            \"owner 2 public key>\"\n        ]\n}\n```\n\n这里条件被划分为两个子条件，包含在 `subfulfillments`  中，`threshold` 为 2，表示需要两个子条件同时满足。\n\n在 cc 的文档中有描述到，[sec 4.3](https://tools.ietf.org/html/draft-thomas-crypto-conditions-04#section-4.3)：\n\n>  Crypto-conditions elegantly support weighted multi-signatures and\n>  multi-level signatures.  A threshold condition has a number of\n>  subconditions, and a target threshold.  Each subcondition can be a\n>  signature or another threshold condition.  This provides flexibility\n>  in forming complex conditions.\n>\n>  For example, consider a threshold condition that consists of two\n>  subconditions, one each from Wayne and Alf. Alf's condition can be a\n>  signature condition while Wayne's condition is a threshold condition,\n>  requiring both Claude and Dan to sign for him.\n>\n>  Multi-level signatures allow more complex relationships than simple\n>  M-of-N signing.  For example, a weighted condition can support an\n>  arrangement of subconditions such as, \"Either Ron, Mac, and Ped must\n>  approve; or Smithers must approve.\"\n\n就是条件理论上是支持被无限的划分为子条件的，那么在验证的时候，势必需要一个递归的程序，所以文档中还包含了 `cost` 的概念，因为每个条件的最终表现形态 (atom) 还是利用的已有的加密算法，比如 hash，rsa 等等，那么对每个已有的加密算法，都指定一个固定的 cost，而当条件制定方在制定自己的条件时，同时也将给出其中包含的所有 atom 元素的 cost 加法结果。当然校验方也不会仅仅认定条件方给出的 cost 值，不过可以作为一个预先的判断。\n\ncost 的目的是，上文说道在校验时势必有一个递归的程序，那么如果接受任意嵌套的条件的话，比如会受到恶意攻击，比如构造一个足够深入的条件，导致校验方在校验条件时花费过多的资源，甚至宕机。\n\n总的来说，cc 并没有提供或者创新一个新的加密算法，只是提供一个将现有加密算法进行一个条件组装，并对组装后的条件如何验证进行描述的一套机制。\n\n参考 chaindb 的实现，至少在 js driver 中，虽然利用了 cc，不过也只是支持了 cc 中单个扁平条件下的 `ED25519-SHA256`，换句话说，和现有的 public-key 机制没有任何区别。\n\n以使用 neo 搭建私有链的经验来看 [搭建私有链 - 第 5 节](http://docs.neo.org/zh-cn/network/private-chain/private-chain.html)，多方签名是需要多方进行配合的，比如在 neo wallet 中会让你将一个账号的签名结果拿出来给到另一个钱包账号再进行签名，在 chaindb 中没有看到提供这样的手段。\n\n最初认为 cc 只需要简单的了解下，但是在这几天对 chaindb 的逐步了解中，会发现这是其中的重要一环。\n\nchaindb 的构架\n\n```\nchaindb-core\n   +   ^\n   |   |\n   v   +\n tendermint\n```\n\n可以看到，core 是基于 tendermint 之上的，因为 tendermint 将分布式以及共识的任务都完成了，准确的说是分布式完成，以及共识接口的完成，具体的共识细节，则需要由位于他上层的应用来实现，比如这里的 core。\n\n那么现在很明显，各个节点之间，需要就什么来达成共识? 对于分布式记账系统而言，无非就是交易 (tx)，那么共识的内容无非也就是验证交易的合法性。交易的合法性除了包括简单的交易格式是否正确，是否双花等等，其中重要的一环就是交易是否由 owner(s) 授权，这就是 cc 所涉及的部分。\n\n所以接下来，将会新的深入的角度，通过分析 [five-bells-condition](https://github.com/interledgerjs/five-bells-condition) 的代码来次深入的学习 cc。\n\n`five-bells-condition` 是 cc 的 js 实现。 ","slug":"/blockchain/crypto-conditions 简述","toc":[],"keywords":[],"mtime":1615393171079},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"react","url":"/post/react","children":[{"name":"build-from-source","url":"/post/react/build-from-source.html","children":[]},{"name":"bootstrap","url":"/post/react/bootstrap.html","children":[]}]},{"name":"ripplet","url":"/post/ripplet","children":[{"name":"create_your_own_lang","url":"/post/ripplet/create_your_own_lang.html","children":[]}]},{"name":"esbuild","url":"/post/esbuild","children":[]}],"title":"The hard ways"}}