{"code":200,"data":{"post":{"filename":"ternjs","rawMeta":{"title":"使用 Rust 重写 ternjs"},"content":"# 使用 Rust 重写 ternjs\n\n[ternjs](https://ternjs.ne) 是一个完全使用 JavaScript 编写的针对 JavaScript 的代码静态分析工具。它是我目前发现的用来入门静态分析最好的项目了：\n\n- 没有复杂的流程分析\n- 推导的算法简单清晰\n- 相对详实的文档\n- 完全使用 JavaScript 实现\n\n静态分析程序的核心的就是其使用的分析算法，传统的对静态语言进行静态分析的算法、有比较固定的格式，即结合数据和控制流程的分析，这样的方式对于动态语言 JavaScript 来说或许不是非常合适。ternjs 作者另辟蹊径，采用一种非常简单精巧的算法，也能达到不错的分析结果，其分析结果虽然不能完全用作 Lint 工具，但是作为类型提示或者代码补全工具却是绰绰有余\n\n另外这还是一个价值 **16,535 欧元**（2013年左右）的算法<sup><a href=\"https://www.indiegogo.com/projects/tern-intelligent-javascript-editing#/\" target=\"_blank\">1</a></sup>，实在没有理由不收入囊中\n\n## 学习方式\n\n因为我们知道这是一个代码静态分析工具，就像我们看程序一般从 `main` 开始尝试梳理脉络一样，我们可以从 [infer](https://ternjs.net/doc/manual.html#infer) 部分开始看。在 infer 的介绍中，作者提到了一些实现细节，比如需要一个 error-tolerant parser 以及 The syntax tree format 是参考的 [Mozilla parser API](https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API)\n\n上面这些基本都是轻车熟路了：先得到程序结构的抽象描述，然后基于这个抽象结果做文章。做文章所需的推导算法，作者已经给出了比较详细的[描述](https://marijnhaverbeke.nl/blog/tern.html)，既然有了算法的描述，就不必傻乎乎的直接去看代码了，按照这个算法先撸一版出来，有问题再去看源码，毕竟是重写而不是抄写\n\n假如从头开始撸的话，对于已经是编写 Recursive Descent Parser 的老司机来说未免显得在准备工作上花费了太多时间了，所以解析器的工作，我们直接选用 [swc](https://github.com/swc-project/swc) 了，另外介绍一下从 swc 的 slack 问来的其名字的含义：\n\n> Speedy Web Compiler. It’s fast, and it compiles transpiles (js and ts) code to a web-consumable form.\n\n貌似 swc 没有 error-tolerant parser，不过问题不大，可以在发现无法通过 parsing 时直接停止继续执行，因为原本 error-tolerant parser 的结果也是不置可否，唯一的好处就是不会 break 当前的进程；The syntax tree format 的问题因为使用了 swc 应该也解决了，它的输出结果应该是用的 ESTree\n\n\n\n","slug":"/static-analysis/ternjs","toc":[{"name":"学习方式","depth":2,"anchor":"#学习方式","children":[]}],"keywords":[],"mtime":1615393171085},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"craft","url":"/post/craft","children":[{"name":"制作一个属于自己的语言","url":"/post/craft/create_your_own_lang.html","children":[]}]}],"title":"The hard ways"}}