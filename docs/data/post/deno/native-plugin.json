{"code":200,"data":{"post":{"filename":"native-plugin","rawMeta":{"title":"deno native plugin 内部实现机制"},"content":"# deno native plugin 内部实现机制\n\n## demo\n\n可以使用 [create-deno-plugin](https://github.com/chiefbiiko/create-deno-plugin) 创建一个插件工程，方便对插件有个具象化的感知\n\n## 插件注册\n\n1. 首先是载入 dynamic library 见 [deno/cli/ops/plugin.rs#L59](https://github.com/denoland/deno/blob/master/cli/ops/plugin.rs#L59)，并找到模块中的符号 `deno_plugin_init`，这是 deno 扩展机制和插件开发者约定的入口\n\n2. 然后调用模块中的 `deno_plugin_init` 方法，来注册模块希望暴露给 js 环境的方法，注册的步骤见 [deno/cli/ops/plugin.rs#L71](https://github.com/denoland/deno/blob/master/cli/ops/plugin.rs#L71)\n\n3. 模块中是以何种形式将自己的方法注册的呢，详见 [webview_deno/src/lib.rs#L31](https://github.com/webview/webview_deno/blob/master/src/lib.rs#L31)，挑部分简单看下：\n\n```rust\n#[no_mangle] // 很重要，否则第2步就找不到符号了，因为 rust 支持重载之类的特性，所以编译后函数名会有变动\npub fn deno_plugin_init(interface: &mut dyn Interface) {\n  interface.register_op(\"webview_free\", webview_free);\n}\n\n#[json_op]\nfn webview_free(\n  json: Value,\n  _zero_copy: &mut [ZeroCopyBuf],\n) -> Result<Value, AnyError> {\n  // ...\n}\n```\n\n可以看到，就是很语义化的一条注册语句 `register_op`\n\n4. 简单看一下 `register_op` 的实现，详见 [deno/cli/ops/plugin.rs#L103](https://github.com/denoland/deno/blob/master/cli/ops/plugin.rs#L103)\n\n```rust\nfn register_op(\n  &mut self,\n  name: &str,\n  dispatch_op_fn: plugin_api::DispatchOpFn,\n) -> OpId {\n  // ...\n  let plugin_op_fn = move |state_rc: Rc<RefCell<OpState>>,\n                            mut zero_copy: BufVec| {\n    // ...\n    let op = dispatch_op_fn(&mut interface, &mut zero_copy);\n    // ...\n  };\n  self\n    .state\n    .op_table\n    .register_op(name, metrics_op(Box::new(plugin_op_fn)))\n}\n```\n\n`dispatch_op_fn` 是插件注册的方法，比如上文的 `webview_free`，然后包装成另一个函数 `plugin_op_fn` 后注册，目前看来包装的目的应该是做一个出入参的调整，包装好后的函数被注册到了 `state.op_table` 中\n\n如果进入 `metrics_op` 的实现查看的话，会发现它又包了一层 [deno/cli/metrics.rs#L82](https://github.com/denoland/deno/blob/master/cli/metrics.rs#L82) 暂时看不知道原因\n\n注册的步骤就到此为止了，流程可以大致梳理为：\n\n- 从 dylib 中找到插件入口\n- 调用插件中的注册方法\n- 将方法经过2层包装，放到 `op_table` 中，以注册时 `name` 为键名，比如 `\"webview_free\"`\n\n## 调用\n\n下面开始看下调用的方式，从 js 的调用开始入手：\n\n```js\nDeno.openPlugin(pluginPath);\nvar { asyncOp: asyncOpId, syncOp: syncOpId } = Deno.core.ops();\n\nexport function syncOpWrapper(zeroCopy) {\n  return Deno.core.dispatch(syncOpId, zeroCopy);\n}\n```\n\n`openPlugin` 的定义在 [deno/cli/rt/40_plugins.js#L6](https://github.com/denoland/deno/blob/master/cli/rt/40_plugins.js#L6)\n\n`code.dispatch` 的定义在 [deno/core/core.js#L185](https://github.com/denoland/deno/blob/master/core/core.js#L185)，其内部又是使用的 `send`，而 `send` 和 `recv` 的定义在 [deno/core/bindings.rs#L139](https://github.com/denoland/deno/blob/master/core/bindings.rs#L139)\n\n`send` 的实现在 [deno/bindings.rs#L385](https://github.com/denoland/deno/blob/master/core/bindings.rs#L385)，其中的关键方法就是：\n\n```rust\nlet op = OpTable::route_op(op_id, state.op_state.clone(), bufs);\n```\n\n可以看到和注册部分已经串联起来了，简单说就是注册是将方法添加到 hashmap 中，key 是方法名，value 是方法实现，调用的时候，再去 hashmap 里面根据 key 找实现，然后调用\n\n可以看下 `OpTable::route_op` 的实现 [deno/core/ops.rs#L86](https://github.com/denoland/deno/blob/master/core/ops.rs#L86)，其中关键调用是：\n\n```rust\nmatch op_fn {\n  Some(f) => (f)(state, bufs), // 这里\n  None => Op::NotFound,\n}\n```\n\n可以看到是直接的函数调用\n\n另外 js -> rust 的调用时，并没有对参数进行序列化操作，而是使用的 `ZeroCopyBuf`，按照它的注释来看，它并没有做内存拷贝，而是将对应的原本由 v8 的 GC 控制的内存，绑定到 `ZeroCopyBuf` 实例的生命周期中，最坏情况下（rust 方法内没有显式地提前释放），就是这块内存直到相应的 `rust` 方法执行完毕后才会被释放\n\n当然也有序列化的版本 [json_op_sync](https://github.com/denoland/deno/blob/master/core/ops.rs#L180)，这样参数就会经过 JSON 的序列化和反序列化\n\n上面只分析了同步调用的情况，异步调用的情况目前看来，可以将简单看成是将 js 的主线程和 rust 主线程绑定到了一起，剩下的异步操作，依赖了 rust 的 async 实现自动做调度\n\n\n## 访问 Isolate 信息\n\n最初的学习是希望 native plugin 中可以访问到 `v8::Isolate` 从而拿到运行时的信息做简单的监控，目前看来插件 API 并没有将这块的访问开放出来，可能需要提个 issue 去问一问\n\n目前看来可以通过自己定义调用签名的方式来完成调用，有待验证其他方法，因为 version 是在 read-only 区的，也就是 `'static` lifetime 的，所以成功的结果不太有力：\n\n```rust\nextern \"C\" {\n    fn v8__V8__GetVersion() -> *const c_char;\n}\n\npub fn gc_stats(_interface: &mut dyn Interface, _zero_copy: &mut [ZeroCopyBuf]) -> Op {\n    unsafe {\n        let c_str: &CStr =  CStr::from_ptr(v8__V8__GetVersion());\n        println!(\"{:?}\", c_str.to_str());\n    }\n    Op::Sync(Box::new([]))\n}\n```\n","slug":"/deno/native-plugin","toc":[{"name":"demo","depth":2,"anchor":"#demo","children":[]},{"name":"插件注册","depth":2,"anchor":"#插件注册","children":[]},{"name":"调用","depth":2,"anchor":"#调用","children":[]},{"name":"访问 Isolate 信息","depth":2,"anchor":"#访问Isolate信息","children":[]}],"keywords":[],"mtime":1615393171068},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"在 VSCode 中调试 v8 源码","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"从源码构建 node.js","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"Node.js 扩展","url":"/post/nodejs/node-addon.html","children":[]},{"name":"Node 源码中的常见代码","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"Midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"Crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"craft","url":"/post/craft","children":[{"name":"制作一个属于自己的语言","url":"/post/craft/create_your_own_lang.html","children":[]}]},{"name":"go","url":"/post/go","children":[{"name":"Go 语言中的 Generic 设计缺陷","url":"/post/go/bad_in_generic_syntax.html","children":[]}]},{"name":"scratch","url":"/post/scratch","children":[{"name":"初唐四杰","url":"/post/scratch/初唐四杰.html","children":[]}]}],"title":"The hard ways"}}