{"code":200,"data":{"post":{"filename":"解析 JSON 的成本","rawMeta":{"title":"解析 JSON 的成本"},"content":"# 解析 JSON 的成本\n\n今天看到大神 mathias 的推，说如果程序中使用 JSON 格式来保存大量配置信息的时候，可以通过形如 `JSON.parse('{\"foo\":42,\"bar\":1337}');` 的方式来加速程序的启动\n\n我了解后发现，v8 为了加速对 JS 程序的解析，将 One-pass parsing 拆分为了 Preparsing 和 Lazy parsingv8 会将函数的函数体编译为字节码，而在 Preparsing 中，不会将所有函数的函数体都一股脑地编译为字节码，而是将对非 [PIFE](https://v8.dev/blog/preparser#pife) 的函数的函数体的编译动作延迟到程序中第一次使用它们的时候，这就是 Lazy parsing\n\n虽然 Preparsing 中不会对函数体进一步处理，它还是会扫描整个 JS 文件，保证函数体中的内容是符合语法定义的所以如果在程序中直接使用对象字面量来存放配置信息，比如：\n\n```js\nfunction start() {\n  let cfg = {\n    foo: 42,\n    bar: 1337\n  };\n  // consume cfg\n}\nstart()\n```\n\n会对对象字面量进行两次解析，一次发生在 Preparsing 中，目的是为了保证其语法正确性；另一次发生在 Lazy parsing 中，因为 `start` 函数被调用了，于是需要将其函数体进行编译，此时会解析第二次\n\n而如果将程序改成:\n\n```js\nfunction start() {\n  let cfg = JSON.parse('{\"foo\":42,\"bar\":1337}');\n  // consume cfg\n}\nstart()\n```\n\n我们直接使用了对象字面量对应的字符串形式，然后使用 `JSON.parse` 将对其的解析放到了运行时，这就使得 Preparsing 不需要解析对象字面量，取而代之的是解析对象字面量对应的字符串，因此可以加速解析过程，最终会加速程序的启动\n\n不建议大家直接使用这一方式进行优化，可以对自己的项目使用此优化方式前后的性能差异来做最终的决定另一方面，使用这样的方式，会导致 IDE 无法直接感知 `cfg` 中的内容，所以最好看看有没有 babel 插件可以用或者自制一个也是相当简单的\n\n回想到垠神的 [对 Parser 的误解](http://www.yinwang.org/blog-cn/2015/09/19/parser) 一文中，有这样的描述：\n\n> 很多人写 parser，很在乎所谓的“one-pass parser”他们试图扫描一遍代码文本就构造出最终的 AST 结构可是如果你放松这个条件，允许用多 pass 的parser，就会容易很多你可以在第一遍用很容易的办法构造一个粗略的树结构，然后再写一个递归树遍历过程，把某些在第一遍的时候没法确定的结构进行小规模的转换，最后得到正确的 AST\n>\n> 想要一遍就 parse 出最终的 AST，可以说是一种过早优化（premature optimization）有些人盲目地认为只扫描一遍代码，会比扫描两遍要快一些然而由于你必须在这一遍扫描里进行多度复杂的操作，最终的性能也许还不如很快的扫完第一遍，然后再很快的遍历转换由此生成的树结构\n\nv8 中这样的优化方式，刚好可以作为垠神描述的例证\n","slug":"/javascript/解析 JSON 的成本","toc":[],"keywords":[],"mtime":1666194871732},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"在 VSCode 中调试 v8 源码","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"从源码构建 node.js","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"Node.js 扩展","url":"/post/nodejs/node-addon.html","children":[]},{"name":"Node 源码中的常见代码","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"Midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"Crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"craft","url":"/post/craft","children":[{"name":"制作一个属于自己的语言","url":"/post/craft/create_your_own_lang.html","children":[]}]},{"name":"go","url":"/post/go","children":[{"name":"Go 语言中的 Generic 设计缺陷","url":"/post/go/bad_in_generic_syntax.html","children":[]}]},{"name":"scratch","url":"/post/scratch","children":[{"name":"初唐四杰","url":"/post/scratch/初唐四杰.html","children":[]},{"name":"最好的博客工具","url":"/post/scratch/最好的博客工具.html","children":[]}]}],"title":"The hard ways"}}