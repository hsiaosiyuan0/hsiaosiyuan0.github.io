{"code":200,"data":{"post":{"filename":"generator function","rawMeta":{"title":"Generator Function"},"content":"# Generator Function\n\n目前在我的玩具 JS 引擎 [naive](https://github.com/hsiaosiyuan0/naive) 中还没有实现 Generator，所以这篇除了可以当做是预先调研之外，也可以作为稍微深入到 Generator 实现细节的介绍\n\n## 普通函数\n由于 Generator Function 和普通函数长得太像了，所以先回顾一下普通函数实现细节\n\n我们知道在 C 语言中函数最终体现为代码段中的一段内容，该段内容就是函数体内容对应的机器码，而函数名则为该段代码的首地址，在编译期间会被替换处理\n\n但是在学习 JS 的时候，并不是每个地方都能以 C 语言来参考，这里把 C 换成任何其他语言也说得通；可以在一些问题发生的时候，使用已经掌握的知识来参考联想，但是最终还是要回归到该语言自身的[技术规格文档](https://www.ecma-international.org/ecma-262/6.0/)中\n\n在 JS 中，函数作为一个对象，该对象包含了以下几个内容：\n\n1. 形参信息\n2. 函数体内容所对应的字节码\n4. 与之关联的[闭包](https://github.com/hsiaosiyuan0/blog/blob/master/%2Fposts%2Fjavascript%2F%E9%97%AD%E5%8C%85.md)\n\n当我们调用函数的时候，引擎就会做以下的事情：\n\n1. 创建一个表示调用信息的对象 `CallInfo`\n2. 将第一步创建的对象添加到调用栈中\n3. 引擎根据调用栈顶层的调用信息继续执行\n\n而 `CallInfo`，包含下面的内容：\n\n1. 调用的函数对象\n2. PC，表示接下来需要被执行的字节码的地址\n3. `this` 对象，用于在执行 `THIS` 指令的时候取得对应的对象\n\n另外 JS 引擎在运行时会用到两个栈结构，一个作为调用栈，一个作为操作数栈我们上面介绍的是调用栈，而操作数栈用于存放指令执行时所用到的操作数，包括局部变量和临时变量\n\n## 生成器函数\n\n我们来看一个典型的生成器函数的例子：\n\n```js\nfunction* idMaker() {\n  var index = 0;\n  while(true)\n    yield index++;\n}\n```\n\n想必大家第一次接触到这个语法的时候一头雾水，因为一直以来 `while(true){ /* no break or return */ }` 这样的形式，直接告诉我们该循环为一个死循环恰好上面的例子中，`while` 语句中也没有 `break` 和 `return`，如果是死循环，那么这段代码肯定就失去意义了，如果不是死循环，又打破了我们之前的认知\n\n其实 `yield` 语句，不过是一个语法糖(Syntactic sugar)所谓语法糖就是一些方便程序员书写代码的语法，它们总能找到不使用该语法的对应写法如果我们参考了[技术规格文档](https://www.ecma-international.org/ecma-262/6.0/)，那么发现其实 `yield` 隐含了 `return` 的语义，知道这个就放心了，原来我们之前的认知是准确无误的\n\n在了解了 `yield` 隐含了 `return` 的语义后，死循环的问题可以先不用考虑了，但是产生了一个新的问题：在普通函数中，一旦 `return` 出去了，等于函数主动放弃了执行权，那么再没有办法恢复之前的执行状态但是我们的生成器函数，是可以不断执行的，换句话说，在 `yield` 隐含的 `return` 语义生效后依然可以保持执行状态，以便下一次执行时从上一次暂停点继续执行\n\n因为 JS 引擎是一个单线程的引擎，所以同一时间内，只有一段 JS 代码(函数)会被执行，换句话说，这段时间内执行的代码就占据了程序(引擎)的控制权，而当当前函数(callee)执行完毕后，引擎转而继续执行 caller 中的内容，就称函数交出了对引擎的控制权我们可以显式地交出控制权，通过显式地 `return` 语句；或者隐式地交出控制权，通过编译器在每个函数末尾自动插入的 `return` 语句之所以普通函数 `return` 之后无法再之前恢复状态是因为，保存之前调用信息的 `CallInfo` 对象已经从调用栈中被移除了，也就无法知道之前的 `PC` 等信息了\n\n不知道大家看到这里会不会有灵光一闪的感觉：如果 `CallInfo` 对象在调用结束后，能以一种方式保存它，那么后续再次调用它时，不就能继续执行了吗？没错，生成器函数本质上就是这个道理\n\n\n","slug":"/javascript/generator function","toc":[{"name":"普通函数","depth":2,"anchor":"#普通函数","children":[]},{"name":"生成器函数","depth":2,"anchor":"#生成器函数","children":[]}],"keywords":[],"mtime":1666194698392},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"在 VSCode 中调试 v8 源码","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"从源码构建 node.js","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"Node.js 扩展","url":"/post/nodejs/node-addon.html","children":[]},{"name":"Node 源码中的常见代码","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"Midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"Crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"craft","url":"/post/craft","children":[{"name":"制作一个属于自己的语言","url":"/post/craft/create_your_own_lang.html","children":[]}]},{"name":"go","url":"/post/go","children":[{"name":"Go 语言中的 Generic 设计缺陷","url":"/post/go/bad_in_generic_syntax.html","children":[]}]},{"name":"scratch","url":"/post/scratch","children":[{"name":"初唐四杰","url":"/post/scratch/初唐四杰.html","children":[]},{"name":"最好的博客工具","url":"/post/scratch/最好的博客工具.html","children":[]}]}],"title":"The hard ways"}}