{"code":200,"data":{"post":{"filename":"魔数0x7c00","rawMeta":{"title":"魔数 0x7c00"},"content":"# 魔数 0x7c00\n\n在涉及到计算机系统引导部分的内容时，经常会看到这个魔数(maigc number) `0x7c00`。\n\n找到一篇文章讲述这个魔数的来龙去脉 [Why BIOS loads MBR into 0x7C00 in x86 ](https://www.glamenv-septzen.net/en/view/6)，简单地小结下文中的内容:\n\n1. 0x7c00 这个魔数和 CPU 没有直接关系，并不属于 CPU 手册中的规定内容\n2. 它第一次出现在 `IBM PC 5150 ROM BIOS INT 19h handler`，就是 IBM PC 5150 基础输入输出系统中的第19个中断处理句柄中\n3. 之所以在 CPU 手册中没有任何关于 0x7c00 的细节，是因为它完全是属于 BIOS 的规格参数。\n4. 来自 IBM PC 5150 开发团队的解释是：\n   \n   1. 他们在设计系统时以内存最小为 32KiB 为目标\n   2. 他们希望在 32KiB 之内流出更多的空间给 OS 来完成自身的引导\n   3. 8086/8088 使用 0x0-0x3FF 来存放中断矢量，紧随其后的是 BIOS 的数据段\n   4. 引导扇区(boot sector) 是 512字节，并且引导引导程序的栈大小为 512字节\n   5. 所以 BIOS 将引导程序载入到 0x7c00 位置，引导程序将使用 32KiB 的最后 1024B 的内容\n      \n    在 OS 载入完成后，引导扇区在内存中占据的内容将不再被使用，因此 OS 和应用程序可是使用这块内存。在 OS 载入后，内存中的情形类似:\n\n    ```\n    +--------------------- 0x0\n    | Interrupts vectors\n    +--------------------- 0x400\n    | BIOS data area\n    +--------------------- 0x5??\n    | OS load area\n    +--------------------- 0x7C00\n    | Boot sector\n    +--------------------- 0x7E00\n    | Boot data/stack\n    +--------------------- 0x7FFF\n    | (not used)\n    +--------------------- (...)\n    ```\n\n    其实我感觉上面的 原因2 真的有些牵强。因为可以将 OS load area 和 boot sector/boot data 调换一个位置。将 OS load area 夹在中间的设计真的让人摸不着头脑。 BIOS 将控制权交给 boot loader 之后，boot loader 去哪里载入 OS 就不关 BIOS 的事情了。\n\n所以概括性地来说，0x7c00 对于 BIOS 开发者来说是向后兼容的结果。而对于 boot loader 的开发者来说，由于 BIOS 会将引导程序载入到 0x7c00 的位置，因此相关的代码要根据这个因素进行调整，这也就是引导程序的汇编代码中都会在头部出现类似 `ORG 0x7C00` 的原因。","slug":"/os/魔数0x7c00","toc":[],"keywords":[],"mtime":1644851009608},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"v8 Heapsnapshot 文件解析","url":"/post/nodejs/heap-snapshot.html","children":[]},{"name":"Libuv 之 - 只看这篇是不够的","url":"/post/nodejs/libuv.html","children":[]},{"name":"Objects in V8","url":"/post/nodejs/object-in-v8.html","children":[]},{"name":"Libuv 之上的 Node","url":"/post/nodejs/node-on-libuv.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"craft","url":"/post/craft","children":[{"name":"制作一个属于自己的语言","url":"/post/craft/create_your_own_lang.html","children":[]}]},{"name":"daily","url":"/post/daily","children":[{"name":"初唐四杰","url":"/post/daily/初唐四杰.html","children":[]}]}],"title":"The hard ways"}}