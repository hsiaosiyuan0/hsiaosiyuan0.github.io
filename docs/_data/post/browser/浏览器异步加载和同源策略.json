{"code":200,"data":{"post":{"filename":"浏览器异步加载和同源策略","rawMeta":{"title":"浏览器异步加载和同源策略"},"content":"## 静态页面\n在浏览器脚本的概念没有出现之前，所有的网页都是静态的。我们知道浏览器的工作模式是：\n\n1. 浏览器向网站服务器发起请求\n2. 网站接受浏览器的请求，返回一些字符串（比如一些组成页面的 HTML 字符串）\n3. 浏览器接收到网站返回的用于组成页面的字符串后，就可以关闭连接了\n4. 浏览器将组成页面的字符串渲染到屏幕上，使得用户可以看到一个可视化的结果\n\n看起来就像下面这样：\n\n```\n                                                                                  \n                                       Client Request                              \n              +-------------+                                     +--------+       \n+------+      |  User Agent | +-------------------------------->  |        |       \n| User +------>             |                                     | Server |       \n+--^---+      |  (Browser)  | <--------------------------------+  |        |       \n   |          +-------+-----+                                     +--------+       \n   |                  |                Server Response                             \n   |                  |                                                            \n   |                  |                                                            \n   |        +---------v--------+                                                   \n   |        | Close Connection |                                                   \n   |        +---------+--------+                                                   \n   |                  |                                                            \n   |                  |                                                            \n   |         +--------v--------+                                                   \n   ^---------+ Render response |                                                   \n             +-----------------+                                                   \n```\n\n我们看到，一旦用户代理（浏览器）关闭了和服务器之间的链接之后，客户端和服务器之间将不能继续通信。\n\n## 动态页面\n为了让页面可以给用户带来更多的交互，浏览器开发厂商们制造出了名为浏览器脚本的东西。比如你在浏览一个页面的时候，你觉得页面的字体太小了。在静态页面的时候，页面制作者在右上角给你提供了名为 “放大字体” 的按钮，你点击那个按钮，然后开启一轮新的请求，显著的说就是说你感觉到浏览器刷新了。这其实是浏览器重新从服务器加载页面的资源，只不过这一次的资源是用于显示字体放大后的页面。(尽管这个例子现在看来有些奇怪，因为如果仅仅是改变页面字体大小的话，似乎直接操作 `element.style.fontSize` 就可以了，不过请求另外一个包含更大字体的内联 CSS 页面在最终效果上也是说得通的，所以这里还请多多包含了。)\n\n浏览器脚本就是一小段由浏览器执行的代码，页面制作者将这一小段代码，和网页面的内容（比如一篇优美的散文，和它右上角的 “放大字体” 按钮）一起返回给浏览器。浏览器接收到页面资源后，首先就是先将散文和 “放大字体” 按钮显示出来。注意到返回的内容实际上还有一段由浏览器执行的代码，页面制作者在这段带代码中告诉浏览器：如果用户点击了 “放大字体” 按钮，那么你就将页面的字体放大。于是，当你点击 “放大字体” 按钮之后，浏览器严格执行页面制作者在脚本中撰写的内容 - 将页面的字体放大。\n\n## 异步加载\n注意在静态页面中浏览器和服务器之间的通信过程。浏览器在向服务器发起了对页面的请求之后，在服务器没有将页面的内容返回之前，页面是无法被显示出来的，最显著的特征就是我们在点击了浏览器的 “刷新” 按钮之后，页面会 “白屏” 一小段时间。\n\n起初浏览器脚本是没有网络通信的功能的，只能做一些页面的特效，比如“点击按钮放大了字体”。不过浏览器厂商发现，如果给脚本赋予网络通信的功能，将使得页面制作者可以给用户提供更好的页面交互体验。于是在早期的 IE 浏览器中，首先赋予了浏览器脚本的通信功能。\n\n浏览器脚本可以和服务器进行网络通信之后，页面制作者可以做出具有更好体验的页面。比如你现在需要搜索商品，假设是要买一本编程的书，你在网页的搜索框中输入了 “编程的数”，很明显是输错了，你将 “书” 错输成了 “数”。在你点击了 “搜索” 按钮之后，进过短暂的白屏之后，页面中显示了：\n\n> 找不到关于 “编程的数” 的产品，你是不是要找 “编程的书”\n\n很不错，网站给了我们一个提示，这样我们就可以发现自己的输入错误。不过这个体验还是有待提高的，因为每一次的搜索都会有一个短暂的 “白屏”，在白屏期间用户只能等待。在浏览器脚本可以通信之后，搜索就可以以一个异步的方式进行：\n\n1. 用户在浏览器中输入搜索页面的地址 “http://search.shop.com”\n2. 浏览器会向网站请求搜索页面的内容，用于显示这个页面\n3. 网站在返回页面的显示内容的同时，包含了一小段脚本，脚本的内容是告诉浏览器 “用户在点击了搜索之后，你给用户一个提示，让用户知道服务器正在紧张的搜索用户所需的资源，然后你显示了提示后，你再向服务器请求搜索的结果，当得到搜索结果后，你再把搜索结果显示给用户”\n\n这样的话，用户不必在搜索时面对页面的刷新时的 “白屏” 了，有一个提示框告诉用户稍等片刻。\n\n## 同源策略\n为了定位网络上的资源，我们采用了统一资源定位符 URL，就像是一个门牌号一样， URL 标识出资源在网络上的位置。我们浏览的网页，其中的内容可能会来自不同的提供者，比如散文来自一位作家，而其中的配图来自一位美术家。散文的 URL 是 `http://writer.com/new-world`，配图的 URL 是 `http://artist.com/new-world`。\n\n我们需要有一种方式将网络上的资源（比如散文和图画）标识出来，区别它们是来自于不同的作者。如果我们将颗粒度定位到每一个独立的资源，理论上是可行的，但是我们知道作家不可能只有一篇散文，而美术家也不会只有一幅画。于是我们选择了使用：通信协议，完整的域名，以及端口号去描述一个源，只有三者都相同，才标识两个资源是同源的。\n\n下面的几个资源是同源的：\n\n```\nhttp://example.com/ \nhttp://example.com:80/ \nhttp://example.com/path/file\n```\n\n下面的资源是不同源的：\n\n```\nhttp://example.com/ \nhttp://example.com:8080/ \nhttp://www.example.com/ \nhttps://example.com:80/ \nhttps://example.com/ \nhttp://example.org/ \nhttp://ietf.org/\n```\n\n现在知道了同源，那么同源策略是什么意思呢？同源策略就是，两个不同源的资源相互是不能访问对方的资源的。同源策略主要就是限制脚本的网络访问。\n\n比如我们打开了一个页面 `http://example.com`，这个页面有两段脚本，一个段使用的内联的方式称为 A，它主要就是在用户点击了按钮之后显示一段文字，告诉用户点击了按钮；另一段作为外部资源进行加载称为 B，B 是 A 的基础代码，比如 B 是 jQuery，它被放在了 `http://cdn.jquery.com` 上。首先我们知道，这两段代码如果按照同源的定义，肯定是不同源的。也就是说我们在 `http://example.com` 的页面上是不能加载 `http://cdn.jquery.com` 上的资源的。\n\n好像与现实情况有点矛盾。之所以现在可以，是因为浏览器为了适应实际的生产情况，放宽了对同源策略的检查，因为我们知道，不可能将所有的资源都放在同一台机器上。那么在页面完全加载好之后，页面中的脚本（内联的和外部引入）的都被浏览器归纳到了和当前页面相同的源，都属于 `http://example.com` 了。这么做的意思就是，脚本无法访问与之不同源的资源，也就是此时的脚本（内联的和外部引入的）无法访问资源 `https://example.com/user-info`。\n\n## 绕过同源策略\n有时比如上面的例子，我们确实需要在脚本中加载和当前页面不同源的资源，比如在 `http://example.com` 页面中使用脚本加载 `https://example.com/user-info` 中的内容。那么如何绕过浏览器的同源策略呢？\n\n我们知道直接在页面中载入不同源的外部资源是可以的，那么我们就可以动态的载入一段外部的脚本。\n\n首先，我们的 `http://example.com` 中有这么一段脚本：\n\n```\n(function () {\n    window['showNickname'] = function (json) {\n        alert(json['nickname']);\n    };\n\n    var userInfoServiceUrl = 'https://example.com/user-info';\n\n    var doCrossSiteRequest = function (url, callback) {\n        var script = document.createElement('script');\n        script.src = url + '?callback=' + callback;\n        var head = document.getElementsByTagName('head');\n        if (head[0]) {\n            head.append(script);\n        }\n    };\n\n    document.querySelector('#btnShowNickName').addEventListener('click', function () {\n        doCrossSiteRequest(userInfoServiceUrl, 'showNickname');\n    });\n})();\n```\n\n而 `https://example.com/user-info` 的服务端内容为：\n\n```\n<?php\n\n$callback = isset($_GET['callback']) ? $_GET['callback'] : null;\nif ($callback === null) die('invalid request');\n\n$userInfo = [\n    'nickname' => 'net-user'\n];\n$json = json_encode($userInfo);\n\necho \"{$callback}({$json});\";\n```\n\n那么在浏览器加载了 `https://example.com/user-info` 的脚本为，得到的是：\n\n```\nshowNickname({\"nickname\":\"net-user\"});\n```\n\n这就和我们最先在 `http://example.com` 留下的 `window['showNickname']` 对接上了。\n","slug":"/browser/浏览器异步加载和同源策略","toc":[{"name":"静态页面","depth":2,"anchor":"#静态页面","children":[]},{"name":"动态页面","depth":2,"anchor":"#动态页面","children":[]},{"name":"异步加载","depth":2,"anchor":"#异步加载","children":[]},{"name":"同源策略","depth":2,"anchor":"#同源策略","children":[]},{"name":"绕过同源策略","depth":2,"anchor":"#绕过同源策略","children":[]}],"keywords":[],"mtime":1615393171080},"catalog":[{"name":"v8","url":"/post/v8","children":[{"name":"debug-v8-in-vscode","url":"/post/v8/debug-v8-in-vscode.html","children":[]},{"name":"v8 常见数据类型","url":"/post/v8/common-data-types.html","children":[]}]},{"name":"deno","url":"/post/deno","children":[{"name":"deno native plugin 内部实现机制","url":"/post/deno/native-plugin.html","children":[]}]},{"name":"crypto","url":"/post/crypto","children":[{"name":"加密算法调研","url":"/post/crypto/brief-crypto.html","children":[]}]},{"name":"nodejs","url":"/post/nodejs","children":[{"name":"Cluster 模块分析","url":"/post/nodejs/Cluster 模块分析.html","children":[]},{"name":"build-from-source","url":"/post/nodejs/build-from-source.html","children":[]},{"name":"node-addon","url":"/post/nodejs/node-addon.html","children":[]},{"name":"common-snippet","url":"/post/nodejs/common-snippet.html","children":[]},{"name":"heap-snapshot","url":"/post/nodejs/heap-snapshot.html","children":[]}]},{"name":"websocket","url":"/post/websocket","children":[{"name":"WebSocket 协议 1~4 节","url":"/post/websocket/WebSocket 协议 1~4 节.html","children":[]},{"name":"WebSocket 协议 5~10 节","url":"/post/websocket/WebSocket 协议 5~10 节.html","children":[]}]},{"name":"assembly","url":"/post/assembly","children":[{"name":"汇编语言学习小结","url":"/post/assembly/汇编语言学习小结.html","children":[]}]},{"name":"typescript","url":"/post/typescript","children":[{"name":"Decorator in babel and tsc","url":"/post/typescript/decorator.html","children":[]}]},{"name":"rust","url":"/post/rust","children":[{"name":"Lifetime","url":"/post/rust/lifetime.html","children":[]}]},{"name":"oop","url":"/post/oop","children":[{"name":"midway 分析","url":"/post/oop/ioc.html","children":[]}]},{"name":"php","url":"/post/php","children":[{"name":"为什么 PHP 不适合长时间运行","url":"/post/php/为什么 PHP 不适合长时间运行.html","children":[]}]},{"name":"blockchain","url":"/post/blockchain","children":[{"name":"crypto-conditions 简述","url":"/post/blockchain/crypto-conditions 简述.html","children":[]},{"name":"实用拜占庭容错简介","url":"/post/blockchain/实用拜占庭容错简介.html","children":[]}]},{"name":"browser","url":"/post/browser","children":[{"name":"浏览器异步加载和同源策略","url":"/post/browser/浏览器异步加载和同源策略.html","children":[]}]},{"name":"cpp","url":"/post/cpp","children":[{"name":"The as-if rule","url":"/post/cpp/the-as-if-rule.html","children":[]}]},{"name":"work","url":"/post/work","children":[{"name":"Parsing in practice","url":"/post/work/parsing-in-practice.html","children":[]}]},{"name":"os","url":"/post/os","children":[{"name":"大小端序","url":"/post/os/大小端序.html","children":[]},{"name":"UTF-8 编码及检查其完整性","url":"/post/os/UTF-8 编码及检查其完整性.html","children":[]},{"name":"魔数 0x7c00","url":"/post/os/魔数0x7c00.html","children":[]},{"name":"字符集和字符编码","url":"/post/os/字符集和字符编码.html","children":[]}]},{"name":"javascript","url":"/post/javascript","children":[{"name":"Generator Function","url":"/post/javascript/generator function.html","children":[]},{"name":"解析 JSON 的成本","url":"/post/javascript/解析 JSON 的成本.html","children":[]},{"name":"Javascript 内部的字符编码","url":"/post/javascript/Javascript 内部的字符编码.html","children":[]},{"name":"闭包的作用","url":"/post/javascript/闭包的作用.html","children":[]},{"name":"闭包是什么","url":"/post/javascript/闭包是什么.html","children":[]}]},{"name":"static-analysis","url":"/post/static-analysis","children":[{"name":"使用 Rust 重写 ternjs","url":"/post/static-analysis/ternjs.html","children":[]}]},{"name":"react","url":"/post/react","children":[{"name":"build-from-source","url":"/post/react/build-from-source.html","children":[]},{"name":"bootstrap","url":"/post/react/bootstrap.html","children":[]}]}],"title":"The hard ways"}}