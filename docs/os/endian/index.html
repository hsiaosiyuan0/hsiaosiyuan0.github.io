<!DOCTYPE html>
<html lang="en-us">
  <head>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/images/site.webmanifest">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>大小端序 | hsiaosiyuan</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="http://hsiaosiyuan0.github.io/css/theme-override.css">
    <header>

  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="http://hsiaosiyuan0.github.io/">~/hsiaosiyuan</a>
      </li>
      

      

    </ul>
  </nav>
</header>

  </head>

  <body>
    <br/>

<div class="article-meta">
<h1><span class="title">大小端序</span></h1>

<h2 class="date">2019/06/17</h2>
<p class="terms">
  
  
  
  
  
</p>
</div>


<div class="content-wrapper">
  <main>
    <blockquote>
<p>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；</p>
</blockquote>
<blockquote>
<p>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。</p>
</blockquote>
<p>比如现在有一块四个字节的内存，并且地址是从左往右递增的。为了方便，都置为 0</p>
<pre><code>1000:1000 00 00 00 00
</code></pre><p>现有一个十六进制数 <code>0x12345678</code>，这个十六进制数刚好可以使用上面的那块内存去存放，因为它们都是 32bits。</p>
<h2 id="大端序">大端序</h2>
<p>如果是大端序，内存表现将会是这样</p>
<pre><code>1000:1000 12 34 56 78
</code></pre><p>可以发现，<code>12</code> 是原十六进制数 <code>0x12345678</code>的高位，而这个 <code>12</code> 放在上面那块内存地址的最低单元中（因为前面说了，这块内存地址是从左往右递增的，所以左边是相对低位，右边是相对高位）。这就是这段话的意思</p>
<blockquote>
<p>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中</p>
</blockquote>
<h2 id="小端序">小端序</h2>
<p>如果是小端序，内存表现是这样的</p>
<pre><code>1000:1000 78 56 34 12
</code></pre><p>可以发现，<code>78</code> 是原十六进制数 <code>0x12345678</code>的低位，而此时它也放在了最低的内存单元中，这就是这段话的意思</p>
<blockquote>
<p>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中</p>
</blockquote>
<p>另外，可以发现，大小端序对字节内容是没有影响的，<code>12</code>还是 <code>12</code> 并没有变成 <code>21</code></p>
<p>另外，对于类似下面情形，一般为内存或者文件 dump 工具的输出内容，通常的阅读顺序是，从左往右、从上到下:</p>
<pre><code>0AEC:0000  CD 20 FF 9F 00 9A EE FE-1D F0 4F 03 50 05 8A 03
0AEC:0010  50 05 17 03 50 05 16 04-01 01 01 00 02 FF FF FF
0AEC:0020  FF FF FF FF FF FF FF FF-FF FF FF FF 06 05 4E 01
0AEC:0030  10 0A 14 00 18 00 EC 0A-FF FF FF FF 00 00 00 00
0AEC:0040  05 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00
0AEC:0050  CD 21 CB 00 00 00 00 00-00 00 00 00 00 20 20 20
0AEC:0060  20 20 20 20 20 20 20 20-00 00 00 00 00 20 20 20
0AEC:0070  20 20 20 20 20 20 20 20-00 00 00 00 00 00 00 00
</code></pre><h2 id="8086-端序">8086 端序</h2>
<p>如何知道当前的 8086 是大端序还是小端序，可以使用下面的汇编代码测试</p>
<pre><code>; 设置 data segment 的段地址
mov ax, 1000
mov ds, ax

; 一次将一个字的数据 0001h 写入数据段的第一个单元开始的一个字的内存中
; 一个字占用 2 个字节，那么如果是大端序，内存中应该是 00 01
; 如果是小端序，内存中就会使 01 00
mov ax, 1h
mov [0], ax

; 先将 bx 置 0，便于下面的查看
sub bx, bx

; 将数据段中的第一个内存单元的内容放置到 bl 中，因为 bl 是 8 位的，所以这样可以
; 达到只获取第一个字节的目的，现在可以查看寄存器 bx 的值，如果它是 0001，则说明
; 内存中的数据是 01 00 这样的格式，则设备是小端序的，反之亦然
mov bl, [0]
</code></pre>
    <a href="/"> >> Home</a>
  </main>
</div>
    <footer>
      
<script>
(function() {
  function center_el(tagName) {
    var tags = document.getElementsByTagName(tagName), i, tag;
    for (i = 0; i < tags.length; i++) {
      tag = tags[i];
      var parent = tag.parentElement;
      
      if (parent.childNodes.length === 1) {
        
        if (parent.nodeName === 'A') {
          parent = parent.parentElement;
          if (parent.childNodes.length != 1) continue;
        }
        if (parent.nodeName === 'P') parent.style.textAlign = 'center';
      }
    }
  }
  var tagNames = ['img', 'embed', 'object'];
  for (var i = 0; i < tagNames.length; i++) {
    center_el(tagNames[i]);
  }
})();
</script>

      
      <hr/>
      <a href="https://github.com/hsiaosiyuan0">GitHub</a>
      
    </footer>
  </body>
</html>

