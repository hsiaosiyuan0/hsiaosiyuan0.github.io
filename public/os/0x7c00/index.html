<!DOCTYPE html>
<html lang="en-us">
  <head>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/images/site.webmanifest">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>魔数 0x7c00 | hsiaosiyuan</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="http://example.org/css/theme-override.css">
    <header>

  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="http://example.org/">~/hsiaosiyuan</a>
      </li>
      

      

    </ul>
  </nav>
</header>

  </head>

  <body>
    <br/>

<div class="article-meta">
<h1><span class="title">魔数 0x7c00</span></h1>

<h2 class="date">2019/03/09</h2>
<p class="terms">
  
  
  
  
  
</p>
</div>


<div class="content-wrapper">
  <main>
    <h1 id="魔数-0x7c00">魔数 0x7c00</h1>
<p>在涉及到计算机系统引导部分的内容时，经常会看到这个魔数(maigc number) <code>0x7c00</code>。</p>
<p>找到一篇文章讲述这个魔数的来龙去脉 <a href="https://www.glamenv-septzen.net/en/view/6">Why BIOS loads MBR into 0x7C00 in x86 </a>，简单地小结下文中的内容:</p>
<ol>
<li>
<p>0x7c00 这个魔数和 CPU 没有直接关系，并不属于 CPU 手册中的规定内容</p>
</li>
<li>
<p>它第一次出现在 <code>IBM PC 5150 ROM BIOS INT 19h handler</code>，就是 IBM PC 5150 基础输入输出系统中的第19个中断处理句柄中</p>
</li>
<li>
<p>之所以在 CPU 手册中没有任何关于 0x7c00 的细节，是因为它完全是属于 BIOS 的规格参数。</p>
</li>
<li>
<p>来自 IBM PC 5150 开发团队的解释是：</p>
<ol>
<li>他们在设计系统时以内存最小为 32KiB 为目标</li>
<li>他们希望在 32KiB 之内流出更多的空间给 OS 来完成自身的引导</li>
<li>8086/8088 使用 0x0-0x3FF 来存放中断矢量，紧随其后的是 BIOS 的数据段</li>
<li>引导扇区(boot sector) 是 512字节，并且引导引导程序的栈大小为 512字节</li>
<li>所以 BIOS 将引导程序载入到 0x7c00 位置，引导程序将使用 32KiB 的最后 1024B 的内容</li>
</ol>
<p>在 OS 载入完成后，引导扇区在内存中占据的内容将不再被使用，因此 OS 和应用程序可是使用这块内存。在 OS 载入后，内存中的情形类似:</p>
<pre><code>+--------------------- 0x0
| Interrupts vectors
+--------------------- 0x400
| BIOS data area
+--------------------- 0x5??
| OS load area
+--------------------- 0x7C00
| Boot sector
+--------------------- 0x7E00
| Boot data/stack
+--------------------- 0x7FFF
| (not used)
+--------------------- (...)
</code></pre><p>其实我感觉上面的 原因2 真的有些牵强。因为可以将 OS load area 和 boot sector/boot data 调换一个位置。将 OS load area 夹在中间的设计真的让人摸不着头脑。 BIOS 将控制权交给 boot loader 之后，boot loader 去哪里载入 OS 就不关 BIOS 的事情了。</p>
</li>
</ol>
<p>所以概括性地来说，0x7c00 对于 BIOS 开发者来说是向后兼容的结果。而对于 boot loader 的开发者来说，由于 BIOS 会将引导程序载入到 0x7c00 的位置，因此相关的代码要根据这个因素进行调整，这也就是引导程序的汇编代码中都会在头部出现类似 <code>ORG 0x7C00</code> 的原因。</p>

    <a href="/"> >> Home</a>
  </main>
</div>
    <footer>
      
<script>
(function() {
  function center_el(tagName) {
    var tags = document.getElementsByTagName(tagName), i, tag;
    for (i = 0; i < tags.length; i++) {
      tag = tags[i];
      var parent = tag.parentElement;
      
      if (parent.childNodes.length === 1) {
        
        if (parent.nodeName === 'A') {
          parent = parent.parentElement;
          if (parent.childNodes.length != 1) continue;
        }
        if (parent.nodeName === 'P') parent.style.textAlign = 'center';
      }
    }
  }
  var tagNames = ['img', 'embed', 'object'];
  for (var i = 0; i < tagNames.length; i++) {
    center_el(tagNames[i]);
  }
})();
</script>

      
      <hr/>
      <a href="https://github.com/hsiaosiyuan0">GitHub</a>
      
    </footer>
  </body>
</html>

