<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rusts on hsiaosiyuan</title>
    <link>http://example.org/rust/</link>
    <description>Recent content in Rusts on hsiaosiyuan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 19 Aug 2020 00:00:00 +0800</lastBuildDate><atom:link href="http://example.org/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lifetime</title>
      <link>http://example.org/rust/lifetime/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0800</pubDate>
      
      <guid>http://example.org/rust/lifetime/</guid>
      <description>Lifetime Rust 的绝大部分语法都非常简洁、易于理解，而其为了保证内存安全引入的 lifetime 概念则对大部分人来说是第一次接触
变量的作用域 孤零零的「作用域」是不明确的，所以这里的标题是「变量的作用域」，因为作用域的概念，指的就是一个区间、在改区间内，某个变量是可用的。这里「区间」的定义不同，又分为静态作用域或者动态作用域，更多的可以参考 闭包的作用
Rust 受到 OCaml 这样函数式语言的影响，对变量的 Scope 定义有着一些相似的理解，比如在 OCaml 中通过下面的方式定义变量：
let add_vect v1 v2 = let len = min (Array.length v1) (Array.length v2) in // ---------+-- s1 let res = Array.make len 0.0 in // ---+- s2 | for i = 0 to len - 1 do // | | res.(i) &amp;lt;- v1.(i) +. v2.(i) // | | done; // ---+-----+ 上面这段代码，定义了一个名为 add_vect 的函数，该函数具有两个形参：v1 v2，let a in b 语句表示定义了变量 a，它的 lifetime（可用期）在随后的（in 之后）的语句内，换句话说 in 之后出现了一个新的 scope，在这个 scope 中 a 是可用的</description>
    </item>
    
  </channel>
</rss>
