<!DOCTYPE html>
<html lang="en-us">
  <head>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/images/site.webmanifest">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>解析 JSON 的成本 | hsiaosiyuan</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="http://example.org/css/theme-override.css">
    <header>

  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="http://example.org/">~/hsiaosiyuan</a>
      </li>
      

      

    </ul>
  </nav>
</header>

  </head>

  <body>
    <br/>

<div class="article-meta">
<h1><span class="title">解析 JSON 的成本</span></h1>

<h2 class="date">2019/06/26</h2>
<p class="terms">
  
  
  
  
  
</p>
</div>


<div class="content-wrapper">
  <main>
    <h1 id="解析-json-的成本">解析 JSON 的成本</h1>
<p>今天看到大神 @mathias 的推，说如果程序中使用 JSON 格式来保存大量配置信息的时候，可以通过形如 <code>JSON.parse('{&quot;foo&quot;:42,&quot;bar&quot;:1337}');</code> 的方式来加速程序的启动。</p>
<p>我了解后发现，v8 为了加速对 JS 程序的解析，将 One-pass parsing 拆分为了 Preparsing 和 Lazy parsing。v8 会将函数的函数体编译为字节码，而在 Preparsing 中，不会将所有函数的函数体都一股脑地编译为字节码，而是将对非 <a href="https://v8.dev/blog/preparser#pife">PIFE</a> 的函数的函数体的编译动作延迟到程序中第一次使用它们的时候，这就是 Lazy parsing。</p>
<p>虽然 Preparsing 中不会对函数体进一步处理，它还是会扫描整个 JS 文件，保证函数体中的内容是符合语法定义的。所以如果在程序中直接使用对象字面量来存放配置信息，比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">start</span>() {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">cfg</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">foo</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">42</span>,
    <span style="color:#a6e22e">bar</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1337</span>
  };
  <span style="color:#75715e">// consume cfg
</span><span style="color:#75715e"></span>}
<span style="color:#a6e22e">start</span>()
</code></pre></div><p>会对对象字面量进行两次解析，一次发生在 Preparsing 中，目的是为了保证其语法正确性；另一次发生在 Lazy parsing 中，因为 <code>start</code> 函数被调用了，于是需要将其函数体进行编译，此时会解析第二次。</p>
<p>而如果将程序改成:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">start</span>() {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">cfg</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#e6db74">&#39;{&#34;foo&#34;:42,&#34;bar&#34;:1337}&#39;</span>);
  <span style="color:#75715e">// consume cfg
</span><span style="color:#75715e"></span>}
<span style="color:#a6e22e">start</span>()
</code></pre></div><p>我们直接使用了对象字面量对应的字符串形式，然后使用 <code>JSON.parse</code> 将对其的解析放到了运行时，这就使得 Preparsing 不需要解析对象字面量，取而代之的是解析对象字面量对应的字符串，因此可以加速解析过程，最终会加速程序的启动。</p>
<p>不建议大家直接使用这一方式进行优化，可以对自己的项目使用此优化方式前后的性能差异来做最终的决定。另一方面，使用这样的方式，会导致 IDE 无法直接感知 <code>cfg</code> 中的内容，所以最好看看有没有 babel 插件可以用或者自制一个也是相当简单的。</p>
<p>回想到垠神的 <a href="http://www.yinwang.org/blog-cn/2015/09/19/parser">对 Parser 的误解</a> 一文中，有这样的描述：</p>
<blockquote>
<p>很多人写 parser，很在乎所谓的“one-pass parser”。他们试图扫描一遍代码文本就构造出最终的 AST 结构。可是如果你放松这个条件，允许用多 pass 的parser，就会容易很多。你可以在第一遍用很容易的办法构造一个粗略的树结构，然后再写一个递归树遍历过程，把某些在第一遍的时候没法确定的结构进行小规模的转换，最后得到正确的 AST。</p>
<p>想要一遍就 parse 出最终的 AST，可以说是一种过早优化（premature optimization）。有些人盲目地认为只扫描一遍代码，会比扫描两遍要快一些。然而由于你必须在这一遍扫描里进行多度复杂的操作，最终的性能也许还不如很快的扫完第一遍，然后再很快的遍历转换由此生成的树结构。</p>
</blockquote>
<p>v8 中这样的优化方式，刚好可以作为垠神描述的例证。</p>

    <a href="/"> >> Home</a>
  </main>
</div>
    <footer>
      
<script>
(function() {
  function center_el(tagName) {
    var tags = document.getElementsByTagName(tagName), i, tag;
    for (i = 0; i < tags.length; i++) {
      tag = tags[i];
      var parent = tag.parentElement;
      
      if (parent.childNodes.length === 1) {
        
        if (parent.nodeName === 'A') {
          parent = parent.parentElement;
          if (parent.childNodes.length != 1) continue;
        }
        if (parent.nodeName === 'P') parent.style.textAlign = 'center';
      }
    }
  }
  var tagNames = ['img', 'embed', 'object'];
  for (var i = 0; i < tagNames.length; i++) {
    center_el(tagNames[i]);
  }
})();
</script>

      
      <hr/>
      <a href="https://github.com/hsiaosiyuan0">GitHub</a>
      
    </footer>
  </body>
</html>

