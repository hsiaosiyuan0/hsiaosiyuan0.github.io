<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascripts on hsiaosiyuan</title>
    <link>http://example.org/javascript/</link>
    <description>Recent content in Javascripts on hsiaosiyuan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 06 Aug 2019 00:00:00 +0800</lastBuildDate><atom:link href="http://example.org/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>闭包的作用</title>
      <link>http://example.org/javascript/the-duty-of-closure/</link>
      <pubDate>Tue, 06 Aug 2019 00:00:00 +0800</pubDate>
      
      <guid>http://example.org/javascript/the-duty-of-closure/</guid>
      <description>闭包的作用 这里我们将主要关注闭包的作用。至于到底什么是闭包，可以参考 闭包。
如果被问到「闭包有什么作用？」想必有同学首先会想到「模拟私有变量」，又或者「在回调中有时会用到」，又或者最接近正确答案的「用于捕获变量」等等诸如此类。
这些回答显然都是正确的，不过它们并不是「闭包的作用」，而是闭包的一些具体的使用场景。其实如果被问到「闭包的作用」，那么这个问题本身就模棱两可，问一个东西的作用时，需要限定它的适用场景，把它放到一个前置环境下，再问它的作用。好比我问你平口起子的作用，你如果回答用它来在课桌上划三八线，我觉得也未尝不可。
而如果什么都不限定的问一句「平口起子的作用是什么」，那么我们从「平口起子最初是为什么被制造的」这个点来回来，才算是答其所问了。同样的，如果被问到「闭包有什么作用」，那么回答为什么需要闭包，才是答其所问，而不是闭包都能干什么。
当明白了问题之后，就已经成功了一大步。
作用域 首先我们知道编程语言中有一个「作用域」的概念，那么为什么是作用域呢？作用域就是程序中的「一段范围」在这个范围之内，某些变量是有效的。那么为什么要提出这个概念呢？没有作用域就不能编程吗？当然不是，没有作用域也是可以编程的，我们知道机器语言就没有作用域的概念，我曾经见过有前辈直接使用机器码编写出音乐播放器。
那么既然没有作用域也能编程，为什么要引入这个概念呢？这是因为高级编程语言中要尽量的提供丰富地表达程序的能力，因此提出了变量名的概念，而编程中的词汇是相对匮乏的，毕竟编程是一定程度上的对现实抽象的内容。想象一下，如果程序中对于同一个变量名只能使用一次，那么必定是一个噩梦，比如我们在写循环的时候经常使用 i，这下好了，程序中只能出现一个 i，其余都得是 i1 i2 ... iN 这样了。
有了作用域之后，我们在每个作用域中都能使用 i 了，这样就使得大家的词汇量得到了解放，也一定程序上使得程序表达更加简洁清晰，否则因为是程序中第 100 个循环就使用变量 i100 多少会让人感到有点傻。
一段范围 注意我们在介绍作用域中提到的：作用域就是程序中的「一段范围」在这个范围之内，某些变量是有效的。这个一段范围，在现有的编程语言实现中具有两种不同的解释：
 静态作用域，又称为词法作用域 动态作用域  静态作用域 在具有静态作用域的语言中，它们对「一段范围」的解释是，代码中的一段范围。换句话说，变量的作用域是直接体现在代码中的、即静态的；在解析阶段就可以确定的、即词法的。静态作用域的好处就是，通过阅读代码，我们和解析程序就能够确定一个变量的作用域，当然就很方便理解了。
动态作用域 在那些使用动态作用域的语言中，它们对「一段范围」的解释是，程序执行中的某个时间点。换句话说，变量的作用域是又程序运行阶段的行为确定的，是不可预测的，因此在人肉确定变量的作用域时会花费一些精力。
静态作用域的例子： // 一段用于演示静态作用域的 C 语言程序 #include&amp;lt;stdio.h&amp;gt; int x = 10; int f() { return x; } int g() { int x = 20; return f(); } int main() { printf(&amp;#34;%d&amp;#34;, g()); printf(&amp;#34;\n&amp;#34;); return 0; } 结果打印 10</description>
    </item>
    
    <item>
      <title>Generator Function</title>
      <link>http://example.org/javascript/generator-function/</link>
      <pubDate>Sun, 04 Aug 2019 00:00:00 +0800</pubDate>
      
      <guid>http://example.org/javascript/generator-function/</guid>
      <description>Generator Function 目前在我的玩具 JS 引擎 naive 中还没有实现 Generator，所以这篇除了可以当做是预先调研之外，也可以作为稍微深入到 Generator 实现细节的介绍。
普通函数 由于 Generator Function 和普通函数长得太像了，所以先回顾一下普通函数实现细节。
我们知道在 C 语言中函数最终体现为代码段中的一段内容，该段内容就是函数体内容对应的机器码，而函数名则为该段代码的首地址，在编译期间会被替换处理。
但是在学习 JS 的时候，并不是每个地方都能以 C 语言来参考，这里把 C 换成任何其他语言也说得通；可以在一些问题发生的时候，使用已经掌握的知识来参考联想，但是最终还是要回归到该语言自身的技术规格文档中。
在 JS 中，函数作为一个对象，该对象包含了以下几个内容：
 形参信息 函数体内容所对应的字节码 与之关联的闭包  当我们调用函数的时候，引擎就会做以下的事情：
 创建一个表示调用信息的对象 CallInfo 将第一步创建的对象添加到调用栈中 引擎根据调用栈顶层的调用信息继续执行  而 CallInfo，包含下面的内容：
 调用的函数对象 PC，表示接下来需要被执行的字节码的地址 this 对象，用于在执行 THIS 指令的时候取得对应的对象  另外 JS 引擎在运行时会用到两个栈结构，一个作为调用栈，一个作为操作数栈。我们上面介绍的是调用栈，而操作数栈用于存放指令执行时所用到的操作数，包括局部变量和临时变量。
生成器函数 我们来看一个典型的生成器函数的例子：
function* idMaker() { var index = 0; while(true) yield index++; } 想必大家第一次接触到这个语法的时候一头雾水，因为一直以来 while(true){ /* no break or return */ } 这样的形式，直接告诉我们该循环为一个死循环。恰好上面的例子中，while 语句中也没有 break 和 return，如果是死循环，那么这段代码肯定就失去意义了，如果不是死循环，又打破了我们之前的认知。</description>
    </item>
    
    <item>
      <title>Unicode 和 BMP</title>
      <link>http://example.org/javascript/javascript-internal-encoding/</link>
      <pubDate>Sun, 04 Aug 2019 00:00:00 +0800</pubDate>
      
      <guid>http://example.org/javascript/javascript-internal-encoding/</guid>
      <description>Unicode 和 BMP Unicode 通过一个确切的名称以及一个整数 (这个整数被叫做该字符的码位 code point) 来标识不同的字符。比如，字符 © 的名称是 “版权标识 (copyright sign)”、它的 code point 是 U+00A9 &amp;ndash; 0xA9 (十进制的 169)。
Unicode 的编码空间被分离成了 17 个平面，每个平面包含 2^16 (十进制 65,536 即十六进制 0xFFFF) 个码位 (code point)。其中的一些码位尚未被分配到字符，还有一些码位作为私有用途，还有一些永久保留、不存放任何字符 (U+D800到U+DFFF)。每个平面中的码位 (code point) 的取值范围在 xy0000 ~ xyFFFF，xy 表示的是该码位所属的平面，上面提到编码空间被分离成了 17 个平面，这里的 xy 就是这 17 个平面的编号就的十六进制表示，即 00 ~ 10。
第一个平面 (即上面的 xy 为 00) 被称为 基本多语言平面 (Basic Multilingual Plane ) 简称 BMP，它所包含的码位范围是 U+0000 ~ U+FFFF，这些都是使用频率最高的字符。
剩余的十六个平面 (U+100000 ~ U+10FFFF) 被称为 补充平面 (supplementary planes or astral planes)。这里将不继续讨论它们，只要记住字符分为 BMP 字符和 非-BMP (non-BMP) 字符，后者又被称为补充平面。</description>
    </item>
    
    <item>
      <title>闭包</title>
      <link>http://example.org/javascript/closure/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/javascript/closure/</guid>
      <description>闭包 很多分享都会解释什么是闭包，不得不说大都管中窥豹。比如某 star 1k 的项目中描述
 所有函数都是闭包
 是不恰当的。但是在有 1k stars 的情况下，居然没有 issue 指出其中的错误。
首先必须说，闭包就取名和中文翻译而言，在你正在理解了它之后，会发现它恰到好处。如果你还觉得命名很奇怪，那么就说明你并不理解它。
就如同它的名字描述的一般，闭包表示的是一个封闭的内存空间。每个函数被创建的时候，都有一个与之关联的闭包。在了解闭包的使用场景之前，先看下面一个例子：
function f() { var i = 0; console.log(i); } f(); 这段代码非常简单。我们知道一旦 f 执行完毕，那么它本次执行的栈上的数据将会被释放，所以每次调用结束后，栈上的 i 都会被及时的释放。
再来看另一个例子：
function f() { var i = 0; return function () { // f1  console.log(i); } } var ff = f(); ff(); 和第一个例子一样，这段代码同样会打印 0。但是这似乎打破了我们第一个例子的总结，按照第一个例子的说法，f 运行结束后，本次调用的栈上的 i 应该被释放掉了。但是我们随后调用返回的匿名函数，发现并没有报错，这就归功于闭包。
每个函数被创建的时候，都会有一个与之关联的闭包被同时创建。在新创建的函数内部，如果引用了外部作用域中的变量，那么这些变量都会被添加到该函数的闭包中。
注意上面代码的注释，为了方便描述，我们将匿名函数取名为 f1。当 f 被调用的时候，f1 被创建，同时与之关联的闭包也被创建。由于 f1 内部引用了位于其作用域之外的、f 作用域中的变量 i，因此 f 作用域中的 i 被拷贝到了 f1 的闭包中。这就解释了，为什么 f 执行完成之后，调用 f1 依然可以打印 0。</description>
    </item>
    
    <item>
      <title>解析 JSON 的成本</title>
      <link>http://example.org/javascript/the-cost-of-json-parsing/</link>
      <pubDate>Wed, 26 Jun 2019 00:00:00 +0800</pubDate>
      
      <guid>http://example.org/javascript/the-cost-of-json-parsing/</guid>
      <description>解析 JSON 的成本 今天看到大神 @mathias 的推，说如果程序中使用 JSON 格式来保存大量配置信息的时候，可以通过形如 JSON.parse(&#39;{&amp;quot;foo&amp;quot;:42,&amp;quot;bar&amp;quot;:1337}&#39;); 的方式来加速程序的启动。
我了解后发现，v8 为了加速对 JS 程序的解析，将 One-pass parsing 拆分为了 Preparsing 和 Lazy parsing。v8 会将函数的函数体编译为字节码，而在 Preparsing 中，不会将所有函数的函数体都一股脑地编译为字节码，而是将对非 PIFE 的函数的函数体的编译动作延迟到程序中第一次使用它们的时候，这就是 Lazy parsing。
虽然 Preparsing 中不会对函数体进一步处理，它还是会扫描整个 JS 文件，保证函数体中的内容是符合语法定义的。所以如果在程序中直接使用对象字面量来存放配置信息，比如：
function start() { let cfg = { foo: 42, bar: 1337 }; // consume cfg } start() 会对对象字面量进行两次解析，一次发生在 Preparsing 中，目的是为了保证其语法正确性；另一次发生在 Lazy parsing 中，因为 start 函数被调用了，于是需要将其函数体进行编译，此时会解析第二次。
而如果将程序改成:
function start() { let cfg = JSON.parse(&amp;#39;{&amp;#34;foo&amp;#34;:42,&amp;#34;bar&amp;#34;:1337}&amp;#39;); // consume cfg } start() 我们直接使用了对象字面量对应的字符串形式，然后使用 JSON.</description>
    </item>
    
  </channel>
</rss>
