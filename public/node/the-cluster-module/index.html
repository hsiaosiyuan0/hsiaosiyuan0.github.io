<!DOCTYPE html>
<html lang="en-us">
  <head>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/images/site.webmanifest">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>Cluster 模块分析 | hsiaosiyuan</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="http://example.org/css/theme-override.css">
    <header>

  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="http://example.org/">~/hsiaosiyuan</a>
      </li>
      

      

    </ul>
  </nav>
</header>

  </head>

  <body>
    <br/>

<div class="article-meta">
<h1><span class="title">Cluster 模块分析</span></h1>

<h2 class="date">2019/06/17</h2>
<p class="terms">
  
  
  
  
  
</p>
</div>


<div class="content-wrapper">
  <main>
    <h1 id="cluster-模块分析">Cluster 模块分析</h1>
<ul>
<li><a href="#cluster-%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90">Cluster 模块分析</a>
<ul>
<li><a href="#%E9%A2%84%E5%A4%87%E5%B7%A5%E4%BD%9C">预备工作</a></li>
<li><a href="#%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98">发现问题</a></li>
<li><a href="#%E9%97%AE%E9%A2%981-work-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA">问题1. work 进程的创建</a></li>
<li><a href="#%E9%97%AE%E9%A2%982-listen-%E6%96%B9%E6%B3%95">问题2. listen 方法</a></li>
<li><a href="#%E9%97%AE%E9%A2%983-%E4%B8%8D%E9%80%80%E5%87%BA">问题3. 不退出</a></li>
<li><a href="#%E9%97%AE%E9%A2%984-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82">问题4. 处理请求</a></li>
</ul>
</li>
</ul>
<h2 id="预备工作">预备工作</h2>
<p>分析的是从 node 源码的角度进行的，所以需要先配置源码的调试环境。</p>
<p>需要准备的内容为:</p>
<ol>
<li>node 源码</li>
<li><a href="https://www.jetbrains.com/clion/">CLion</a></li>
</ol>
<p>node 源码的获取，通过以下命令行:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git clone https://github.com/nodejs/node.git
<span style="color:#75715e"># 本文针对的版本</span>
git checkout tags/v11.6.0
</code></pre></div><p>获取了 node 源码之后，需要在 CLion 中导入项目，详细可以参考此文 <a href="http://hiihl.com/articles/2018/1/15/learnnode1.md">使用 cLion 调试 node.js 源码</a>。</p>
<p>上文中提到的源码编译指令为:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">make -C out BUILDTYPE<span style="color:#f92672">=</span>Debug -j <span style="color:#ae81ff">4</span>
</code></pre></div><p><code>-j 4</code> 的意义是同时执行的任务数，一般设定为 CPU 核数，可以通过下面指令获得 CPU 核数:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span> <span style="color:#66d9ef">$(</span>uname<span style="color:#66d9ef">)</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Darwin&#39;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> sysctl -n hw.logicalcpu_max <span style="color:#f92672">||</span> lscpu -p | egrep -v <span style="color:#e6db74">&#39;^#&#39;</span> | wc -l
</code></pre></div><p>如果希望加快 node 源码的编译速度的话，可以先尝试获取核数，然后调整 <code>-j</code> 的值。</p>
<p>node 中的 js 实现都在 lib 目录下，需要注意的是，当 node 编译完成之后，这些 js 文件是都会被打包到编译结果中的。当 node 在运行中要引入 lib 下的 js 文件时，并不会从我们的源码目录中读取了，而是采用的编译时打包进去的 js 内容。所以在修改了 lib 目录下的 js 文件后，需要重新对 node 进行编译。</p>
<h2 id="发现问题">发现问题</h2>
<p>为了测试 Cluster 的运行，需要准备一小段测试代码，保存到 <code>./test-cluster.js</code>:</p>
<blockquote>
<p>如果没有特别说明，接下来文件路径中的 <code>.</code> 都表示的是 node 源码目录</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">cluster</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;cluster&#39;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">http</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;http&#39;</span>);
<span style="color:#75715e">// 下面的代码会依据 numCPUs 的值来创建对应数量的子进程，
</span><span style="color:#75715e">// 由于目前硬件核数都会比较多，为了使调试时的输出内容尽可能的清晰，所以设定为 2
</span><span style="color:#75715e">// const numCPUs = require(&#39;os&#39;).cpus().length;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">numCPUs</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">isMaster</span>) {
    <span style="color:#75715e">// 如果是 master 进程:
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 1. 打印进程号
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 2. 根据 numCPUs 的值来创建对应数量的子进程
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;master pid: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">pid</span>);

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">numCPUs</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
        <span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">fork</span>();
    }
} <span style="color:#66d9ef">else</span> {
    <span style="color:#75715e">// 如果是子进程:
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 1. 打印进程号
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 2. 创建 http server 实例
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 3. 并调用上一步创建的实例的 listen 方法
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;isMaster: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">isMaster</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; pid: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">pid</span>);

    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">srv</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">createServer</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">req</span>, <span style="color:#a6e22e">res</span>) {
        <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">writeHead</span>(<span style="color:#ae81ff">200</span>);
        <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">end</span>(<span style="color:#e6db74">&#34;hello world\n&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">pid</span>);
    });

    <span style="color:#a6e22e">srv</span>.<span style="color:#a6e22e">listen</span>(<span style="color:#ae81ff">8000</span>);
}
</code></pre></div><p>接下来需要使用在 <a href="#%E9%A2%84%E5%A4%87%E5%B7%A5%E4%BD%9C">预备工作</a> 中编译好的 node 来运行上述代码:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">./out/Debug/node test-cluster.js
</code></pre></div><p>会得到如下的输出:</p>
<pre><code>master pid: 30094
isMaster: false pid: 30095
isMaster: false pid: 30096
</code></pre><p>通过对比输出内容，代码执行的过程类似:</p>
<ol>
<li>master 开始运行，即条件分支中的 <code>cluster.isMaster</code> 分支被执行，创建了 2 个子进程</li>
<li>在 2 个子进程中 <code>else</code> 分支被执行</li>
</ol>
<p>这里有几个值得思考的问题:</p>
<ol>
<li>cluster 模块是如何区别 master 和 work 进程的；换言之，work 进程是如何被创建的</li>
<li>多个 work 进程中，都执行了 <code>listen</code> 方法，为什么没有报错 <code>ERR_SERVER_ALREADY_LISTEN</code></li>
<li>为什么 master 进程在完成了创建进程的任务后没有退出</li>
<li>请求是如何传递到 work 进程中并被处理的</li>
</ol>
<p>对于问题3，准备下面两个文件</p>
<p><code>./test-fork-exit.js</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">numCPUs</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">const</span> {<span style="color:#a6e22e">fork</span>} <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;child_process&#39;</span>);

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;master pid: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">pid</span>);

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">numCPUs</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
    <span style="color:#a6e22e">fork</span>(<span style="color:#e6db74">&#34;./test-fork-sub.js&#34;</span>)
}
</code></pre></div><p><code>./test-fork-sub.js</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;sub: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">pid</span>);
</code></pre></div><p>运行 <code>./out/Debug/node test-fork-exit.js</code> 后，会发现 master 进程在创建了两个进程后退出了。</p>
<p>接下来将对上述几个问题进行分析。</p>
<h2 id="问题1-work-进程的创建">问题1. work 进程的创建</h2>
<p>在运行了 <code>./out/Debug/node test-cluster.js</code> 命令之后，master 进程即被启动，在该进程中，运行 <code>test-cluster.js</code> 中的代码。</p>
<p>首先执行的就是 <code>const cluster = require('cluster');</code>。打开 cluster 模块的源码 <code>./lib/child_process.js</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">childOrMaster</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;NODE_UNIQUE_ID&#39;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">env</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;child&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;master&#39;</span>;
<span style="color:#a6e22e">module</span>.<span style="color:#a6e22e">exports</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">`internal/cluster/</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">childOrMaster</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</code></pre></div><p>可以看到，代码会根据 <code>childOrMaster</code> 的值来决定引入的是 <code>internal/cluster/child</code> 还是 <code>internal/cluster/master</code> 模块。而 <code>childOrMaster</code> 的值取决于环境变量中是否设定了 <code>NODE_UNIQUE_ID</code>，如果设定了，那么加载对应的 <code>child</code> 模块，否则加载对应的 <code>master</code> 模块。</p>
<p>显然，默认环境变量中是没有对 <code>NODE_UNIQUE_ID</code> 标识进行设定的，于是引入的就是 <code>./internal/cluster/master.js</code></p>
<p>注意下面的代码片段:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">isMaster</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</code></pre></div><p>于是，在接下来的条件判断 <code>cluster.isMaster</code> 为 <code>true</code>，进而会执行子进程的创建，也就是调用 master 模块中的 <code>fork</code> 方法。</p>
<p>注意 fork 方法中的片段:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">setupMaster</span>();
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">id</span> <span style="color:#f92672">=</span> <span style="color:#f92672">++</span><span style="color:#a6e22e">ids</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">workerProcess</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">createWorkerProcess</span>(<span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">env</span>);
</code></pre></div><p>只需要注意自增的 id，接下来看下 <code>createWorkerProcess</code> 的代码片段:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">workerEnv</span>.<span style="color:#a6e22e">NODE_UNIQUE_ID</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">id</span>;

<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fork</span>(<span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">settings</span>.<span style="color:#a6e22e">exec</span>, <span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">settings</span>.<span style="color:#a6e22e">args</span>, {
  <span style="color:#a6e22e">cwd</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">settings</span>.<span style="color:#a6e22e">cwd</span>,
  <span style="color:#a6e22e">env</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">workerEnv</span>,
  <span style="color:#a6e22e">silent</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">settings</span>.<span style="color:#a6e22e">silent</span>,
  <span style="color:#a6e22e">windowsHide</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">settings</span>.<span style="color:#a6e22e">windowsHide</span>,
  <span style="color:#a6e22e">execArgv</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">execArgv</span>,
  <span style="color:#a6e22e">stdio</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">settings</span>.<span style="color:#a6e22e">stdio</span>,
  <span style="color:#a6e22e">gid</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">settings</span>.<span style="color:#a6e22e">gid</span>,
  <span style="color:#a6e22e">uid</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">settings</span>.<span style="color:#a6e22e">uid</span>
});
</code></pre></div><p>于是发现其实是调用的 <code>child_process</code> 模块中的 <code>fork</code> 方法，并设置了环境变量 <code>NODE_UNIQUE_ID</code>，上文提到 <code>cluster</code> 模块被引入的时候，会根据环境变量是否存在 <code>NODE_UNIQUE_ID</code> 标识而决定引入 <code>child</code> 还是 <code>master</code>。</p>
<p>另外，<a href="https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options">child_process.fork</a> 方法第一个参数为 <code>modulePath</code>，也就是需要在子进程中执行的 js 文件路径，对应上述代码中 <code>cluster.settings.exec</code> 的值，对该变量的设定代码在 <code>setupMaster</code> 方法中:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">settings</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">args</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">argv</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">2</span>),
  <span style="color:#a6e22e">exec</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">argv</span>[<span style="color:#ae81ff">1</span>],
  <span style="color:#a6e22e">execArgv</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">execArgv</span>,
  <span style="color:#a6e22e">silent</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>
};
</code></pre></div><p><code>process.argv[1]</code> 为当前进程的入口文件，对于这个例子中的主进程而言，即为: <code>./test-cluster.js</code>（实际值为对应的绝对路径）</p>
<p>于是 cluster 模块作用下的 master 进程中的 fork 方法执行的内容可以简单部分归纳为:</p>
<ol>
<li>设置环境变量 <code>NODE_UNIQUE_ID</code></li>
<li>执行 <code>child_process.fork</code>，参数 <code>modulePath</code> 为主进程入口文件</li>
</ol>
<p>接下来就是子进程中执行的过程。</p>
<p>子进程进来执行的还是与主进程相同的文件，之所以执行了 <code>cluster.isMaster</code> 为 <code>false</code> 的分支，是因为 <code>./internal/cluster/child.js</code> 的代码片段:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">isMaster</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</code></pre></div><h2 id="问题2-listen-方法">问题2. listen 方法</h2>
<p>子进程中都执行了 <code>listen</code> 方法，但是却没有报错，于是尝试分析 <code>listen</code> 的执行细节。</p>
<p><code>http</code> 模块中的 <code>Server</code> 是继承于 <code>net.Server</code>，见 <code>./lib/_http_server.js</code> 中:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Server</span>(<span style="color:#a6e22e">options</span>, <span style="color:#a6e22e">requestListener</span>) {
 <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Server</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>, { <span style="color:#a6e22e">allowHalfOpen</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span> });
 <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>而 listen 方法存在于 <code>net.Server</code> 上。查看 <code>net.Server.listen</code> 中主要的动作都是对参数的 normalization，然后调用 <code>net.Server::listenInCluster</code> 方法:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">isMaster</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">exclusive</span>) {
  <span style="color:#75715e">// Will create a new handle
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// _listen2 sets up the listened handle, it is still named like this
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// to avoid breaking code that wraps this method
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">_listen2</span>(<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">port</span>, <span style="color:#a6e22e">addressType</span>, <span style="color:#a6e22e">backlog</span>, <span style="color:#a6e22e">fd</span>, <span style="color:#a6e22e">flags</span>);
  <span style="color:#66d9ef">return</span>;
}

<span style="color:#a6e22e">cluster</span>.<span style="color:#a6e22e">_getServer</span>(<span style="color:#a6e22e">server</span>, <span style="color:#a6e22e">serverQuery</span>, <span style="color:#a6e22e">listenOnMasterHandle</span>);
</code></pre></div><p>这里需要注意的是，listen 方法都是在子进程中执行的，所以 <code>cluster.isMaster</code> 为 <code>false</code>，而 <code>exclusive</code> 是未设定的，故也为 <code>false</code>。于是，子进程中的 listen 实际执行的是 <code>cluster._getServer</code> 方法，并且这里的 <code>cluster</code> 模块实际是引入的 <code>./lib/internal/cluster/child.js</code>，于是查看该文件中的 <code>_getServer</code> 方法片段:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">message</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">util</span>.<span style="color:#a6e22e">_extend</span>({
  <span style="color:#a6e22e">act</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;queryServer&#39;</span>,
  <span style="color:#a6e22e">index</span>,
  <span style="color:#a6e22e">data</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">null</span>
}, <span style="color:#a6e22e">options</span>);

<span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">message</span>, (<span style="color:#a6e22e">reply</span>, <span style="color:#a6e22e">handle</span>) =&gt; {
  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">_setServerData</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;function&#39;</span>)
    <span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">_setServerData</span>(<span style="color:#a6e22e">reply</span>.<span style="color:#a6e22e">data</span>);

  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">handle</span>)
    <span style="color:#a6e22e">shared</span>(<span style="color:#a6e22e">reply</span>, <span style="color:#a6e22e">handle</span>, <span style="color:#a6e22e">indexesKey</span>, <span style="color:#a6e22e">cb</span>);  <span style="color:#75715e">// Shared listen socket.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">else</span>
    <span style="color:#a6e22e">rr</span>(<span style="color:#a6e22e">reply</span>, <span style="color:#a6e22e">indexesKey</span>, <span style="color:#a6e22e">cb</span>);              <span style="color:#75715e">// Round-robin.
</span><span style="color:#75715e"></span>});
</code></pre></div><p><code>send</code> 方法最终会调用 <code>./lib/internal/cluster/utils.js</code> 中的 <code>sendHelper</code> 方法，而该方法会向父进程发送 <code>{ cmd: 'NODE_CLUSTER' }</code> 消息，根据文档的 <a href="https://nodejs.org/api/child_process.html#child_process_subprocess_send_message_sendhandle_options_callback">描述</a>，<code>NODE_</code> 起头的 <code>cmd</code> 为 内部消息(<code>internalMessage</code>)，需要通过 <code>.on('internalMessage', lister)</code> 来监听它。</p>
<p>由于这个消息是从子进程发往父进程的、即主进程的，于是在 <code>./lib/internal/cluster/master.js</code> 中找到了相关的监听代码片段:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;internalMessage&#39;</span>, <span style="color:#a6e22e">internal</span>(<span style="color:#a6e22e">worker</span>, <span style="color:#a6e22e">onmessage</span>));
</code></pre></div><p>接着通过 <code>onmessage</code> 方法定位到 <code>queryServer</code> 方法中的代码片段:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">address</span><span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">port</span><span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">addressType</span><span style="color:#e6db74">}</span><span style="color:#e6db74">:`</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">fd</span><span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">index</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">handle</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">handles</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">key</span>);

<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">handle</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">address</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">address</span>;

  <span style="color:#75715e">// Find shortest path for unix sockets because of the ~100 byte limit
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">port</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">address</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span> <span style="color:#f92672">&amp;&amp;</span>
      <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">platform</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#39;win32&#39;</span>) {

    <span style="color:#a6e22e">address</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">relative</span>(<span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">cwd</span>(), <span style="color:#a6e22e">address</span>);

    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">address</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">address</span>.<span style="color:#a6e22e">length</span>)
      <span style="color:#a6e22e">address</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">address</span>;
  }

  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">constructor</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">RoundRobinHandle</span>;
  <span style="color:#75715e">// UDP is exempt from round-robin connection balancing for what should
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// be obvious reasons: it&#39;s connectionless. There is nothing to send to
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// the workers except raw datagrams and that&#39;s pointless.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">schedulingPolicy</span> <span style="color:#f92672">!==</span> <span style="color:#a6e22e">SCHED_RR</span> <span style="color:#f92672">||</span>
      <span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">addressType</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;udp4&#39;</span> <span style="color:#f92672">||</span>
      <span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">addressType</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;udp6&#39;</span>) {
    <span style="color:#a6e22e">constructor</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">SharedHandle</span>;
  }

  <span style="color:#a6e22e">handle</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">key</span>,
                           <span style="color:#a6e22e">address</span>,
                           <span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">port</span>,
                           <span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">addressType</span>,
                           <span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">fd</span>,
                           <span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">flags</span>);
  <span style="color:#a6e22e">handles</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">handle</span>);
}
</code></pre></div><p>当这段代码首次被运行时，会创建一个 handle，并将其和 key 关联起来。对于 TCP 链路，在没有特别指定 <code>schedulingPolicy</code> 的情况下，handle 均为 <code>RoundRobinHandle</code> 的实例。而查看 <code>./lib/internal/cluster/round_robin_handle.js</code> 文件中的 <code>RoundRobinHandle</code> 构造函数细节，则发现具体的 listen 绑定动作:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">fd</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>)
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">listen</span>({ <span style="color:#a6e22e">fd</span> });
<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">port</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">listen</span>({
    <span style="color:#a6e22e">port</span>,
    <span style="color:#a6e22e">host</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">address</span>,
    <span style="color:#75715e">// Currently, net module only supports `ipv6Only` option in `flags`.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ipv6Only</span><span style="color:#f92672">:</span> Boolean(<span style="color:#a6e22e">flags</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">constants</span>.<span style="color:#a6e22e">UV_TCP_IPV6ONLY</span>),
  });
} <span style="color:#66d9ef">else</span>
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">listen</span>(<span style="color:#a6e22e">address</span>);  <span style="color:#75715e">// UNIX socket path.
</span></code></pre></div><p>由于两个子进程都在先后顺序不确定的情况下向 master 发送 queryServer 内部消息，所以上面的代码会被执行两次。如果两次的 key 不一样，就会导致 <code>handle === undefined</code> 的条件判断为 <code>true</code>，进而 listen 两次，最终发生 <code>ERR_SERVER_ALREADY_LISTEN</code> 错误。但是在上面的运行过程中，并没有报错，说明了两次的 key 是相同的。</p>
<p>来看下 key 的内容:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">address</span><span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">port</span><span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">addressType</span><span style="color:#e6db74">}</span><span style="color:#e6db74">:`</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">fd</span><span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">index</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
</code></pre></div><p>很显然，对于分别来自两个子进程的消息而言，除了 <code>message.index</code> 之外，其余项的内容都是相同的，那么 <code>message.index</code> 的生成过程在 <code>./lib/internal/cluster/child.js</code> 中的代码片段:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">indexesKey</span> <span style="color:#f92672">=</span> [<span style="color:#a6e22e">address</span>,
                    <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">port</span>,
                    <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">addressType</span>,
                    <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">fd</span> ].<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#39;:&#39;</span>);

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">indexes</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">indexesKey</span>);

<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">index</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span>)
  <span style="color:#a6e22e">index</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">else</span>
  <span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>;
</code></pre></div><p>可见，两个子进程在分别执行这段代码的时候，<code>index</code> 首次都将为 <code>0</code>，从而印证了上面的 key 是相同的假设。</p>
<p>之所以子进程中都会执行 listen 方法，而不报错的原因小结如下:</p>
<ol>
<li>子进程中并没有执行实际的 listen 动作，取而代之的是通过发送消息，请求父进程来执行 listen</li>
<li>父进程中的 listen 由于相同的 key 使得多次动作被合并，最终只 listen 了一次</li>
</ol>
<h2 id="问题3-不退出">问题3. 不退出</h2>
<p>答案现阶段只能先从文档中寻找答案，详细见 <a href="https://nodejs.org/api/child_process.html#child_process_options_stdio">options.stdio</a>，以下为节选:</p>
<blockquote>
<p>It is worth noting that when an IPC channel is established between the parent and child processes, and the child is a Node.js process, the child is launched with the IPC channel unreferenced (using unref()) until the child registers an event handler for the &lsquo;disconnect&rsquo; event or the &lsquo;message&rsquo; event. This allows the child to exit normally without the process being held open by the open IPC channel.</p>
</blockquote>
<p>简单的说，如果子进程中没有对事件 <code>disconnect</code> 和 <code>message</code> 进行监听的话，那么主进程在等待子进程执行完毕之后，会正常的退出。后半句的「主进程会等待&hellip;」见 <a href="https://nodejs.org/api/child_process.html#child_process_options_detached">options.detached</a>，以下为节选:</p>
<blockquote>
<p>By default, the parent will wait for the detached child to exit.</p>
</blockquote>
<p>为了印证，可以先将 <code>./test-fork-sub.js</code> 代码改为:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> {<span style="color:#a6e22e">execSync</span>} <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;child_process&#39;</span>);

<span style="color:#a6e22e">execSync</span>(<span style="color:#e6db74">&#34;sleep 3&#34;</span>);
</code></pre></div><p>执行 <code>./out/Debug/node test-fork-exit.js</code> 会发现，在大约等待了几秒之后，也就是子进程执行完毕之后，主进程进行了退出。</p>
<p>再次将 <code>./test-fork-sub.js</code> 代码改为:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> {<span style="color:#a6e22e">execSync</span>} <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;child_process&#39;</span>);

<span style="color:#a6e22e">execSync</span>(<span style="color:#e6db74">&#34;sleep 3&#34;</span>);

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`child: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">pid</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> resumed`</span>);
<span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#34;message&#34;</span>, () =&gt; {});
</code></pre></div><p>可以发现，由于子进程监听了 <code>message</code> 事件，使得主进程和子进程之间的 IPC channel 阻止了主进程的退出。</p>
<p>在 <code>./lib/internal/cluster/child.js</code> 中的 <code>_setupWorker</code> 方法中的片段:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">once</span>(<span style="color:#e6db74">&#39;disconnect&#39;</span>, () =&gt; {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>});
</code></pre></div><p>也印证了这一点。</p>
<h2 id="问题4-处理请求">问题4. 处理请求</h2>
<p>回到 <code>./lib/internal/cluster/round_robin_handle.js</code> 文件，注意构造函数 <code>RoundRobinHandle</code> 中的代码片段，注意该代码是在主进程中调用的:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">createServer</span>(<span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">fail</span>);
<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">once</span>(<span style="color:#e6db74">&#39;listening&#39;</span>, () =&gt; {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handle</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">_handle</span>;
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handle</span>.<span style="color:#a6e22e">onconnection</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">handle</span>) =&gt; <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">distribute</span>(<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">handle</span>);
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">_handle</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
});
</code></pre></div><p><code>net.createServer</code> 的参数如果是函数的话，那么该函数的作用实际是用来处理 <code>connection</code> 的回调函数。之所以会达到回调的效果，是因为在 <code>./lib/net.js</code> 中的 <code>Server</code> 构造函数的片段:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">options</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;function&#39;</span>) {
  <span style="color:#a6e22e">connectionListener</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">options</span>;
  <span style="color:#a6e22e">options</span> <span style="color:#f92672">=</span> {};
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;connection&#39;</span>, <span style="color:#a6e22e">connectionListener</span>);
} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">options</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">options</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;object&#39;</span>) {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>那么上面传递的是 <code>assert.fail</code>，也就是说，如果该方法成功地被回调了的话，那么进程应该报错。
既然没有报错，那么说明在新的 <code>connection</code> 进来之后，没有触发 <code>connection</code> 事件。要搞清楚这点，就要看看 <code>net.Server</code> 上的 <code>connection</code> 事件是如何被触发的。</p>
<p><code>net.Server</code> 上的 <code>connection</code> 事件是在该文件内的 <code>onconnection</code> 方法中被触发的:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">emit</span>(<span style="color:#e6db74">&#39;connection&#39;</span>, <span style="color:#a6e22e">socket</span>);
</code></pre></div><p>而 <code>onconnection</code> 顾名思义也是一个 event listener，它是在相同文件内的 <code>setupListenHandle</code> 中被引用的:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_handle</span>.<span style="color:#a6e22e">onconnection</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onconnection</span>;
</code></pre></div><p>而 <code>setupListenHandle</code> 函数是在调用 <code>net.Server</code> 上的 listen 方法被逐步调用到的:</p>
<ol>
<li>RoundRobinHandle 构造函数内部的 listen</li>
<li>net.Server 上的 listen</li>
<li>net.Server 上的 listenInCluster</li>
<li>net.Server 上的 _listen2</li>
<li>net.Server 内的 setupListenHandle</li>
</ol>
<p>最终在 <code>setupListenHandle</code> 的代码片段中发现:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_handle</span>.<span style="color:#a6e22e">onconnection</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onconnection</span>;
</code></pre></div><p>回到上面列出的 <code>RoundRobinHandle</code> 中的代码:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">once</span>(<span style="color:#e6db74">&#39;listening&#39;</span>, () =&gt; {
  <span style="color:#75715e">// 这里的 this.server._handle 是对 listen fd 的 wrapper
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handle</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">_handle</span>;
  <span style="color:#75715e">// 回调中的 handle 是对 connection fd 的 wrapper
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handle</span>.<span style="color:#a6e22e">onconnection</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">handle</span>) =&gt; <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">distribute</span>(<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">handle</span>);
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">_handle</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
});
</code></pre></div><p>可以看出，在真正的 listen 动作执行成功之后，<code>listening</code> 事件被触发，进入到上面的代码中，然后上面的代码复写了 handle 对象上的 <code>onconnection</code> 属性的值，在此之前，该属性的值即为 <code>assert.fail</code>。handle 对象此时还是一个 TCP_Wrapper 对象 (对 CPP 层面对象的包裹的一个对象)。</p>
<p>由于 master 环境下 <code>RoundRobinHandle</code> 构造 <code>net.Server</code> 对象的目的仅仅是希望获得其内部的 listen fd handle 对象，因为 master 只需要将接下来的 connection fd handle 派发给 works 即可，所以上面的回调中在获得了该对象之后，取消了对 <code>net.Server</code> 对象的引用。</p>
<p>跟进上述代码中的 <code>distribute</code> 方法，发现其会调用 <code>handoff</code> 方法，向 work 发送 connection fd handle。也就是说，当 master 进程接收到新连接之后，会将其派发给 work。接下来需要在 <code>./lib/internal/cluster/child.js</code> 文件中找到事件监听函数:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">onmessage</span>(<span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">handle</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">act</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;newconn&#39;</span>)
    <span style="color:#a6e22e">onconnection</span>(<span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">handle</span>);
  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">act</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;disconnect&#39;</span>)
    <span style="color:#a6e22e">_disconnect</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">worker</span>, <span style="color:#66d9ef">true</span>);
}
</code></pre></div><p>进一步发现 <code>onconnection</code> 方法中:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">server</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">handles</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">key</span>);
<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">onconnection</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">handle</span>);
</code></pre></div><p>接来下先搞清楚 <code>server</code> 是什么时候被添加进 <code>handles</code> 中的，然后再看看 <code>server.onconnection</code> 做了什么。</p>
<p>回顾下子进程中所做的事情，可以结合上面的章节。另外，为了方便结合代码进行理解，故同时给出具体的代码位置:</p>
<ol>
<li>work 进程调用 httpServer 上的 listen 方法，该方法继承自父类 <code>net.Server</code> <a href="https://github.com/nodejs/node/blob/v11.6.0/lib/_http_server.js#L289">code</a></li>
<li>work 进程调用 <code>net.Server</code> 上的 listen 方法 <a href="https://github.com/nodejs/node/blob/v11.6.0/lib/net.js#L1335">code</a></li>
<li>work 进程调用 <code>net.Server::listenInCluster</code> <a href="https://github.com/nodejs/node/blob/v11.6.0/lib/net.js#L1293">code</a></li>
<li>work 进程调用 cluster child 模块上的 <code>_getServer</code>，并期望被回调 <a href="https://github.com/nodejs/node/blob/v11.6.0/lib/net.js#L1316">code</a></li>
<li>work 向 master 进程发送 <code>queryServer</code> 消息，并期望被回调 <a href="https://github.com/nodejs/node/blob/v11.6.0/lib/internal/cluster/child.js#L86">code</a></li>
<li>master 构造 <code>RoundRobinHandle</code> 实例，并将发来 <code>queryServer</code> 消息的 work 注册到其中，并期望被回调。在回调中，会向 work 发送消息，触发第 5 步中 work 期望的回调 <a href="https://github.com/nodejs/node/blob/v11.6.0/lib/internal/cluster/master.js#L317">code</a></li>
<li>第 6 步中的回调参数 handle 都将是 false 值 <a href="https://github.com/nodejs/node/blob/v11.6.0/lib/internal/cluster/round_robin_handle.js#L42">code</a></li>
<li>从而当回调到第 5 步时，work 进程将执行 <code>rr</code> 方法，该方法会伪造一个 handle 对象，加入到 handles 中，并以该对象回调第 4 步 <a href="https://github.com/nodejs/node/blob/v11.6.0/lib/internal/cluster/child.js#L171">code</a></li>
<li>work 进程中开始执行第 4 步的回调函数 <code>listenOnMasterHandle</code>，该函数中设定了 <code>server._handle = handle</code>，注意这里的 handle 即为上一步产生的 handle；并调用了 <code>listen2</code> <a href="https://github.com/nodejs/node/blob/v11.6.0/lib/net.js#L1327">code</a></li>
<li><code>listen2</code> 即为 <code>setupListenHandle</code>，而 <code>setupListenHandle</code> 内部设定了 handle 对象的 <code>onconnection</code> 属性 <a href="https://github.com/nodejs/node/blob/v11.6.0/lib/net.js#L1246">code</a></li>
</ol>
<p>接下来 work 进程中处理请求的逻辑就都与不使用 clsuter 模块时的请求处理逻辑一致了，因为是使用的同样的<a href="https://github.com/nodejs/node/blob/v11.6.0/lib/net.js#L1471">处理函数</a>，只不过是在 work 进程中执行。</p>
<p>请求的处理逻辑可以小结为:</p>
<ol>
<li>master 进程进行实际的 listen 动作，并等待客户端连接</li>
<li>客户端连接由 master 进程，通过消息派发给 work 进程</li>
<li>work 进程中复用一般情况下的请求处理代码、对请求进行处理</li>
</ol>
<p>最后看下 RoundRobinHandle 中的派发机制:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">RoundRobinHandle</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">port</span>, <span style="color:#a6e22e">addressType</span>, <span style="color:#a6e22e">fd</span>, <span style="color:#a6e22e">flags</span>) {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">key</span>;
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">all</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>();
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">free</span> <span style="color:#f92672">=</span> [];
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handles</span> <span style="color:#f92672">=</span> [];

  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">once</span>(<span style="color:#e6db74">&#39;listening&#39;</span>, () =&gt; {
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    
    <span style="color:#75715e">// 1. 当接收到新的客户端连接后，调用 this.distribute 方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handle</span>.<span style="color:#a6e22e">onconnection</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">handle</span>) =&gt; <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">distribute</span>(<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">handle</span>);
    
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  });
}

<span style="color:#75715e">// master 进程接收到 work 进程的 `queryServer` 消息后，会调用该方法。
</span><span style="color:#75715e">// 1. 先将 work 记录到 this.all 这个 map 中
</span><span style="color:#75715e">// 2. 调用 this.handoff 方法，该方法导致两个结果:
</span><span style="color:#75715e">//   2.1 如果此时有 pending handle 的话，那么即刻使用 work 处理
</span><span style="color:#75715e">//   2.2 否则，则将 work 加入到 this.free 这个 map 中
</span><span style="color:#75715e"></span><span style="color:#a6e22e">RoundRobinHandle</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">add</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">worker</span>, <span style="color:#a6e22e">send</span>) {
  <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>  
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">all</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">worker</span>);
  
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">done</span> <span style="color:#f92672">=</span> () =&gt; {
    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handle</span>.<span style="color:#a6e22e">getsockname</span>) {
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">out</span> <span style="color:#f92672">=</span> {};
      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handle</span>.<span style="color:#a6e22e">getsockname</span>(<span style="color:#a6e22e">out</span>);
      <span style="color:#75715e">// TODO(bnoordhuis) Check err.
</span><span style="color:#75715e"></span>      <span style="color:#a6e22e">send</span>(<span style="color:#66d9ef">null</span>, { <span style="color:#a6e22e">sockname</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">out</span> }, <span style="color:#66d9ef">null</span>);
    } <span style="color:#66d9ef">else</span> {
      <span style="color:#a6e22e">send</span>(<span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">null</span>);  <span style="color:#75715e">// UNIX socket.
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handoff</span>(<span style="color:#a6e22e">worker</span>);  <span style="color:#75715e">// In case there are connections pending.
</span><span style="color:#75715e"></span>  };

  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">// 该方法的作用就是讲 connection handle 进行派发
</span><span style="color:#75715e">// 1. 先将 handle 加入到 pending 队列中
</span><span style="color:#75715e">// 2. 尝试使用 this.free 的第一个 work 处理 pending 队列。如果存在 free work 的话，
</span><span style="color:#75715e">//    该 work 还将会被移出 this.free 
</span><span style="color:#75715e"></span><span style="color:#a6e22e">RoundRobinHandle</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">distribute</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">handle</span>) {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handles</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">handle</span>);
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">worker</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">free</span>.<span style="color:#a6e22e">shift</span>();

  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">worker</span>)
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handoff</span>(<span style="color:#a6e22e">worker</span>);
};

<span style="color:#75715e">// 该方法包含了具体的派发动作
</span><span style="color:#75715e">// 1. 从 pending handle 队列取出第一个项目，如果队列为空，则将 work 加入到
</span><span style="color:#75715e">//    this.free map 中，否则进行派发动作
</span><span style="color:#75715e">// 2. 派发是通过将 handle 经由消息发送给 work 进程的，即 sendHelper 部分
</span><span style="color:#75715e"></span><span style="color:#a6e22e">RoundRobinHandle</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">handoff</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">worker</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">all</span>.<span style="color:#a6e22e">has</span>(<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">id</span>) <span style="color:#f92672">===</span> <span style="color:#66d9ef">false</span>) {
    <span style="color:#66d9ef">return</span>;  <span style="color:#75715e">// Worker is closing (or has closed) the server.
</span><span style="color:#75715e"></span>  }

  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handle</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handles</span>.<span style="color:#a6e22e">shift</span>();

  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">handle</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">free</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">worker</span>);  <span style="color:#75715e">// Add to ready queue again.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
  }

  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">message</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">act</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;newconn&#39;</span>, <span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">key</span> };

  <span style="color:#a6e22e">sendHelper</span>(<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">process</span>, <span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">handle</span>, (<span style="color:#a6e22e">reply</span>) =&gt; {
    <span style="color:#75715e">// 该回调由 ./lib/internal/cluster/child.js#L180 触发
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">reply</span>.<span style="color:#a6e22e">accepted</span>)
      <span style="color:#75715e">// work 进程表示它可以处理该 handle，handle 发送到 work 进程中时应该是
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 使用的副本的形式。所以主进程则可以关闭属于其上下文的 handle。handle 内部的
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// fd 被加入到 work 进程的 event loop 中
</span><span style="color:#75715e"></span>      <span style="color:#a6e22e">handle</span>.<span style="color:#a6e22e">close</span>();
    <span style="color:#66d9ef">else</span>
      <span style="color:#75715e">// 如注释所描述的，重新调用一次 this.distribute，尝试其他的 work
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">distribute</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">handle</span>);  <span style="color:#75715e">// Worker is shutting down. Send to another.
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 再次调用 this.handoff
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果还有 pending handle，则处理之，否则将 work 重新加入到 this.free 中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handoff</span>(<span style="color:#a6e22e">worker</span>);
  });
};
</code></pre></div><p>调度的机制可以简单理解为:</p>
<ol>
<li>连接 conn 到来之后，如果有空闲的 work，则告知其处理 conn</li>
<li>否则将 conn 加入 pending 队列</li>
<li>由于 work 的激活是由 connection 事件触发的，所以在 work 处理完 conn 之后，需要主动的再次消化 pending 队列中的内容，该过程连续进行，直到当发现队列为空时，将自身重新标记为 free，等待下一次的 connection 事件对其进行激活</li>
</ol>
<p>另外需要注意的是，cluster 模块中对 works 进程没有重启的机制，work 进程如果遇到没有主动处理的异常就会退出，master 进程不会自动的补齐 works 数量，当所有的 works 都退出后，即不存在任一个 IPC channel 了，master 进程也将退出。</p>

    <a href="/"> >> Home</a>
  </main>
</div>
    <footer>
      
<script>
(function() {
  function center_el(tagName) {
    var tags = document.getElementsByTagName(tagName), i, tag;
    for (i = 0; i < tags.length; i++) {
      tag = tags[i];
      var parent = tag.parentElement;
      
      if (parent.childNodes.length === 1) {
        
        if (parent.nodeName === 'A') {
          parent = parent.parentElement;
          if (parent.childNodes.length != 1) continue;
        }
        if (parent.nodeName === 'P') parent.style.textAlign = 'center';
      }
    }
  }
  var tagNames = ['img', 'embed', 'object'];
  for (var i = 0; i < tagNames.length; i++) {
    center_el(tagNames[i]);
  }
})();
</script>

      
      <hr/>
      <a href="https://github.com/hsiaosiyuan0">GitHub</a>
      
    </footer>
  </body>
</html>

