<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Phps on hsiaosiyuan</title>
    <link>http://example.org/php/</link>
    <description>Recent content in Phps on hsiaosiyuan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 17 Jun 2019 00:00:00 +0800</lastBuildDate><atom:link href="http://example.org/php/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>为什么 PHP 不适合长时间运行</title>
      <link>http://example.org/php/why-php-is-not-good-for-long-time-running/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0800</pubDate>
      
      <guid>http://example.org/php/why-php-is-not-good-for-long-time-running/</guid>
      <description>为什么 PHP 不适合长时间运行 首先需要先看下这篇 Reference Counting Basics 文章，该文章描述了引用计数的基本概念以及它是如何应用在 PHP 引擎中的。
通过阅读上文我们就知道，基于引用计数这种内存管理方式的语言在编写代码的时候，都有一个需要程序员来解决的问题，那就是避免循环引用 (circular reference)。
但是对于上了一定规模的程序而言，靠人脑是很难避免循环引用的。同样使用引用计数的语言比如 Objc，它是通过提供一些编程规范，比如 Advanced Memory Management Programming Guide，然后配以工具进行静态分析，帮助程序员来在程序运行前就发现可能的循环引用。
PHP 作为动态类型的语言，我想应该很难复用静态类型语言中的分析技术 (比如 Objc 中的)，来给程序员提供一个分析工具以发现潜在的循环引用。但是我想 PHP 团队之所以没有提供静态分析工具的另外一个主要原因就是 Reference Counting Basics 所说的：
 Fortunately, PHP will clean up this data structure at the end of the request, but before then, this is taking up valuable space in memory.
 PHP 作为一个 WEB 专门的语言，最常用的方式就是嵌入到 cgi 程序中，在请求结束时，会一次性的释放当次请求所占用的内存，以此避免存泄漏。 当然 Reference Counting Basics 也说了：
 This is especially problematic in long running scripts, such as daemons where the request basically never ends, or in large sets of unit tests</description>
    </item>
    
  </channel>
</rss>
